연산이 이루어지는 데이터나 데이터 타입을 알 수 없다면 코드를 이해하기 어렵다. 타입 시스템의 큰 장점 중 하나는 데이터 타입을 명확히 알 수 있어 코드를 이해하기 쉽다는 것이다.

### 아이템28.유효한 상태만 표현하는 타입을 지향하기

타입을 잘 설계하면 코드는 직관적으로 작성할 수 있다. 그러나 타입 설계가 엉망이라면 어떠한 기억이나 문서도 도움이 되지 못한다. 효과적으로 타입을 설계 하려면, 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 가장 중요하다.

타입을 설계할 때는 어떤 값들을 포함하고 어떤 값들을 제외할지 신중하게 생각해야 한다. 유효한 상태를 표현하는 값만 허용한다면 코드를 작성하기 쉬워지고 타입 체크가 용이해 진다. 유효한 상태만 허용하는 것은 매우 일반적인 원칙이다.

###### 요약
- 유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발한다.
- 유효한 상태만 표현하는 타입을 지향해야 한다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 주일 수 있다.
---
### 아이템29.사용할 때는 너그럽게, 생성할 때는 엄격하게

> 당신의 작업은 엄격하게 하고, 다른 사람의 작업은 너그럽게 받아들여야 한다.

함수의 매개변수는 타입의 범위가 넓어도 되지만, 결과를 반환할 때는 일반적으로 타입의 범위가 구체적 이어야 한다. 매개 변수의 타입의 범위가 넓으면 사용하기 편리하지만, 반환 타입의 범위가 넓으면 불편하다. 즉 사용하기 편리한 API일수록 반환 타입이 엄격해야한다.

###### 요약
- 보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있다. 선택적 속성과 유니온 타입은 반환 타입보다 매개변수 타입에 더 일반적이다.
- 매개변수와 반환 타입의 재사용성을 위해서 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)을 도입하는 것이 좋다.
---
### 아이템30. 문서에 타입 정보를 쓰지 않기

코드와 주석이 맞지 않는다면, 둘 다 잘못된 것이다.
타입스크립트의 타입 구문 시스템은 간결하고,구체적이며,쉽게 읽을 수 있도록 설계되었다. 함수의 입력과 출력의 타입을 코드로 표현하는 것이 주석보다 더 나은 방법이다.

타입 구문은 타입스크립트 컴파일러가 체크해 주기 때문에, 구현체와 정합성이 어긋나지 않는다.
누군가 강제하지 않는 이상 주석은 코드와 동기화되지 않는다. 그러나 타입 구문은 타입스크립트 타입 체커가 타입 정보를 동기화하도록 강제한다.

###### 요약
- 주석과 변수명에 타입 정보를 적는 것은 피해야 한다. 타입 선언이 중복 되는 것으로 끝나면 다행이지만 최악의 경우는 타입 정보에 모순이 발생하게 된다.
- 타입이 명확하지 않은 경우는 변수명에 단위 정보를 포함하는 것을 고려하는 것이 좋다.
---
### 아이템31.타입 주변에 null값 배치하기

값이 전부 null 이거나 전부 null이 아닌 경우로 분명히 구분된다면, 값이 섞여 있을 때보다 다루기 쉽다. 타입에 null을 추가하는 방식으로 이러한 경우를 모델링 할 수 있다.

undefined를 포함하는 객체는 다루기 어렵고 절대 권장하지 않는다.

###### 요약
- 한 값의 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안된다.
- API 작성 시에는 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null이거나 null이 아니게 만들어야 한다. 사람과 타입 체커 모두에게 명료한 코드가 된다.
- 클래스를 만들 때는 필요한 모든 값이 준비되었을때 생성하여 null이 존재 하지 않도록 하는 것이 좋다.
- strictNullChecks를 설정하면 코드에 많은 오류가 표시되지만, null값과 관련된 문제를 찾아 낼 수 있어 반드시 필요하다.
---
### 아이템32. 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기

유니온 타입의 속성을 가지는 인터페이스를 작성 중이라면, 혹시 인터페이스의 유니온 타입을 사용하는게 더 알맞지 않을지 검토 해야 한다.

여러 개의 선택적 필드가 동시에 값이 있거나 동시에 undefined인 경우도 태그 된 유니온 패턴이 잘 맞는다.
- 인터페이스 내 해당 값을 묶어서 표기 한다.
	- 값이 있거나 또는 undefined(선택적 속성)

```
interface Name {  
	name: string;  
}  
  
interface PersonWithBirth extends Name {  
	placeOfBirth: string;  
	dateOfBirth: Date;  
}  
  
type Person1 = Name | PersonWithBirth;  
  
function getPersonName(person: Person1): Person1 {  
	if ('placeOfBirth' in person) {
		// 블라블라 처리  
		return person;  
	}
	
	// 블라블라 처리  
	return person;  
}
```

###### 요약
- 유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생하므로 주의햐야 한다.
- 유니온의 인터페이스 보다 인터페이스 유니온이 더 정확하고 타입스크립트가 이해하기 좋다.
- 타입스크립트가 제어 흐름을 분석할 수 있도록 타입에 태그를 넣는 것을 고려해야 한다. 태그 된 유니온은 타입스크립트와 매우 잘 맞기 때문에 자주 볼 수 있는 패턴이다.
---
### 아이템33.string 타입보다 더 구체적인 타입 사용하기

string 타입의 범위는 매우 넓다. string 타입으로 변수를 선언 하려 한다면, 혹시 그보다 더 좁은 타입이 적절 하지는 않을지 검토해야 한다.

string 타입이 남용된 코드를 "문자열을 남발하여 선언되었다(stringly typed)"고 표현하기도 한다.

string 타입이 아닌 명시적 타입의 이점
1. 타입을 명시적으로 정의함으로써 다른 곳으로 값이 전달 되어도 타입 정보가 유지된다.
2. 타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 사용 할 수 있다.
3. keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능해진다.
	1.![[Pasted image 20241104152436.png]]

string타입은 any와 비슷한 문제를 가지고 있다. 따라서 잘못 사용하게 되면 무효한 값을 허용하고 타입 간의 관계도  감추어 버린다. 이러한 문제점은 타입 체크를 방해하고 실제 버그를 찾지 못하게 한다. 타입스크립트에서 string의 부분 집합을 정의할 수 있는 기능은 자바스크립트 코드에 타입 안전성을 크게 높인다. 보다 정확한 타입을 사용하면 오류를 방지하고 코드의 가독성도 향상 시킬 수 있다.

###### 요약
- 문자열을 남발하여 선언된 코드를 피하는게 좋다. 모든 문자열을 할당할 수 있는 string 타입보다는 더 구체적인 타입을 사용하는 것이 좋다.
- 변수의 범위를 보다 정확하게 표현하고 싶다면 string 타입보다는 문자열 리터럴 타입의 유니온을 사용하면 된다. 타입 체크를 더 엄격히 할 수 있고 생산성을 향상시킬 수 있다.
- 객체의 속성 이름을 함수 매개변수로 받을 때는 string보다 keyof T를 사용하는게 좋다.
---
### 아이템34. 부정확한 타입보다는 미완성 타입을 사용하기

타입 선언을 작성하다 보면 코드의 동작을 더 구체적으로 또는 덜 구체적으로 모델링하게 되는 상황을 맞이하게 된다. 일반적으로 타입이 구체적일수록 버그를 더 많이 잡고 타입스크립트가 제공하는 도구를 활용할 수 있게 된다. 그러나 타입 선언의 정밀도를 높이는 일에는 주의를 기울여야 한다. 실수가 발생하기 쉽고 잘못된 타입은 차라리 타입이 없는 것보다 못할 수 있기 때문이다.

일반적으로 any 같은 매우 추상적인 타입은 정제하는것이 좋다. 그러나 타입이 구체적으로 정제된다고 해서 정확도가 무조건 올라가지는 않는다. 타입에 의존하기 시작하면 부정확함으로 인해 발생하는 문제가 더 커질 수 있다.

###### 요약
- 타입 안전성에서 불쾌한 꼴자기는 피해야 한다. 타입이 없는 것보다 잘못된 게 더 나쁘다.
- 정확하게 타입을 모델링 할 수 없다면, 부정확하게 모델링하지 말아야 한다. 또한 any와 unknown를 구별해서 사용해야 한다.
- 타입 정보를 구체적으로 만들수록 오류 메시지와 자동 완성 기능에 주의를 기울여야 한다. 정확도 뿐만 아니라 개발 경험과도 관련 된 것이다.
---
### 아이템35.데이터가 아닌, API와 명세를 보고 타입 만들기

타입을  직접 작성하지 않고 자동으로 생성 할 수 있다면 매우 유용하다.
파일 형식, API, 명세 등 우리가 다루는 타입 중 최소한 몇 개는 프로젝트 외부에서 비롯된 것이다. 이러한 경우는 타입을 직접 작성하지 않고 자동으로 생성 할 수 있다. 명세를 참조해 타입을 생성 하면 타입스크립트는 사용자가 실수를 줄일 수 있게 도와준다.

###### 요약
- 코드의 구석 구석까지 타입 안전성을 얻기 위해 API 또는 데이터 형식에 대한 타입 생성을 고려해야 한다.
- 데이터에 드러나지 않는 예외적인 경우들이 문제가 될 수 있기 때문에 데이터보다는 명세로부터 코드를 생성하는 것이 좋다.
---
### 아이템36. 해당 분야의 용어로 타입 이름 짓기

이름 짓기 역시 타입 설계에서 중요한 부분이다. ==엄선된 타입,속성,변수의 이름은 의도를 명확히 하고 코드와 타입의 추상화 수준을 높여 준다.== 잘못 선택한 타입 이름은 코드의 의도를 왜곡하고 잘못된 개념을 심어 주게 된다.

코드로 표현하고자 하는 모든 분야에는 주제를 설명하기 위한 전문 용어들이 있다. 자체적으로 용어를 만들어 내려고 하지 말고, 해당 분야에 이미 존재하는 용어를 사용해야 한다. 이런 용어들은 현장에서 실제로 사용 되고 있기 때문이다. 이런 용어들을 사용하면 사용자와 소통에 유리하며 타입의 명확성을 올릴 수 있다.

- 동일한 의미를 나타낼 때는 같은 용어를 사용해야 한다. 의미적으로 구분이 되어야 하는 경우에만 다른 용어를 사용해야 한다.
- data, object, thing, item, info, entity 같은 모호하고 의미 없는 이름은 피해야 한다. 특정 용어가 해당 분야에서 특별한 의미를 가진다며 괜찮다.
- 이름을 지을 때는 포함된 내용이나 계산 방식이 아니라 데이터 자체가 무엇인지를 고려해야 한다. 좋은 이름은 추상화의 수준을 높이고 의도치 않은 충돌의 위험성을 줄여준다.

###### 요약
- 가동성을 높이고, 추상화 수준을 올리기 위해서 해당 분야의 용어를 사용해야 한다.
- 같은 의미에 다른 이름을 붙이면 안된다. 특별한 의미가 있을 때만 용어를 구분해야 한다.
---
### 아이템37.공식 명칭에는 상표를 붙이기

공식 명칭을 사용하는 것은, 타입이 아니라 값의 관점에서 말하는 것이다. 공식 명칭 개념을 타입스크립트에서 흉내 내려면 태그 된 유니온을 사용하면 된다.

```
// 아래와 같은 타입의 값은 생성 할 수 없다. 단지 브랜드 타입을 확인하기 위한 타입스크립 영역의 타입이다.
type A = string & {  
	brand: 'a';  
};  
  
const isAType = (x: string): x is A => {  
	return x === 'a';  
};  
  
const plusA = (x: string) => {  
	if (!isTType(x)) {  
		return x;  
	}  
  
	return x + 'a';  
};  
  
plusA('a');


```