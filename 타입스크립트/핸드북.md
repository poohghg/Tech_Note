### Mapped Types
https://www.typescriptlang.org/ko/docs/handbook/2/mapped-types.html

중복을 피하기 위해서 다른 타입을 바탕으로 새로운 타입을 생성할 수 있다
매핑된 타입은 이전에 선언하지 않았던 프로퍼티의 타입을 선언할 수 있는 인덱스 시그니처 문법로 구성

---
### 가변 인자 튜플 타입 (Variadic Tuple Types)
https://www.typescriptlang.org/ko/docs/handbook/release-notes/typescript-4-0.html

---
### 분산적인 조건부 타입
https://www.typescriptlang.org/ko/docs/handbook/2/conditional-types.html

타입스크립트는 유니온타입의 제네릭 인수 또는 extends(조건문)로 평가할때 분산하여 처리한다.  
TypeScript는 never를 조건문에 분배할 때 빈 유니언으로 취급한다 .
- 조건형 유형이 제네릭 유형에 작용할 때, 유니온 유형이 주어지면 분배형이 된다.
- 즉,` 'a' | never` 분배될 때 그냥 `'a'`분배될 때로 단축한다.

---
### 분포 조건 유형
https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#type-inference-in-conditional-types

`T extends U ? X : Y` 일때. 분산 조건 유형은 인스턴스화 중에 자동으로 유니온 유형에 분산된다. 예를 들어, 유형 인수 `A | B | C` for를 사용한 인스턴스화는 `T`로 해결된다. `(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)`.

- `T extends U ? X : Y`참조는 `T`유니언 유형의 개별 구성 요소로 취급되어 처리된다.
- 즉 조건형이 유니언 유형에 분산된 후 T 개별 구성 요소를 참조한다.

``` ts
type Test<T,U> = T extends U ? T : never;

// 분산 조건 유형
type T00 = Test<string | number, string>;  // string
type T01 = Test<string | number, string | boolean>;  // string | number

// impl
// type Test<T, U> = (T extends U ? T : never) | (T extends U ? T : never);

```

> naked type parameter란 제네릭 T와 같은 타입 파라미터를 의미한다,
> - 조건부 타입에서 naked type parameter는 분산 동작을 트리거하는 역할을 한다.
> - 분산을 막기 위해 [] 로 감싸서 non-naked type parameter로 만들 수 있다.


> TypeScript에서 `T extends U ? X : Y` 같은 조건부 타입을 사용할 때, `T`가 'naked' (감싸지지 않은) 제네릭 타입이고 실제 `T`에 유니언(Union) 타입이 들어오면, **TypeScript는 그 조건을 유니언의 각 멤버에게 개별적으로 적용(분산)한 뒤, 그 결과들을 다시 유니언으로 묶는다.**


``` ts
// 유저가 정의한 타입
type ObjectFromEntries<T extends [string, any]> = {
  [K in T[0]]: T extends [K, any] ? T[1] : never
}

// 테스트용 유니언 타입
type MyUnion = ["a", 1] | ["b", "hello"] | ["c", boolean];
```


#### 분산 과정 상세

##### 1단계: 키(Key) 추출

먼저, `[K in T[0]]` 부분은 객체의 키를 정의합니다.

- `T`는 `["a", 1] | ["b", "hello"] | ["c", boolean]` 입니다.
- `T[0]`는 각 튜플의 첫 번째 요소(인덱스 0)를 의미합니다.
- `T[0]` = `["a", 1][0] | ["b", "hello"][0] | ["c", boolean][0]`
- `T[0]` = `"a" | "b" | "c"`
    
따라서 `ObjectFromEntries`는 `"a"`, `"b"`, `"c"`를 키로 갖는 객체를 생성합니다.


``` ts
type Result = {
  a: ...; // "a"일 때의 값 타입
  b: ...; // "b"일 때의 값 타입
  c: ...; // "c"일 때의 값 타입
}
```

---

#### 2단계: 값(Value) 타입 계산 (분산 발생!)

이제 각 키(`K`)에 대한 값 타입을 계산합니다. 값 타입은 `T extends [K, any] ? T[1] : never` 입니다.
여기서 `T`가 naked 제네릭 타입이므로 분산이 일어납니다.
##### K = "a" 일 때

- 값 타입: `T extends ["a", any] ? T[1] : never`
- `T` 자리에 `MyUnion`이 대입되어 분산이 시작됩니다.

``` ts
  // 1. T = ["a", 1] 일 때
  (["a", 1] extends ["a", any] ? ["a", 1][1] : never)
  // 결과: 1 (true이므로 ["a", 1][1] -> 1)

  | // 2. T = ["b", "hello"] 일 때
  (["b", "hello"] extends ["a", any] ? ["b", "hello"][1] : never)
  // 결과: never (false)

  | // 3. T = ["c", boolean] 일 때
  (["c", boolean] extends ["a", any] ? ["c", boolean][1] : never)
  // 결과: never (false)
```

- `"a"` 키의 최종 값 타입: `1 | never | never` => **`1`**
    
#### K = "b" 일 때

- 값 타입: `T extends ["b", any] ? T[1] : never`
- `T`에 대해 다시 분산이 일어납니다.
```ts
  // 1. T = ["a", 1] 일 때
  (["a", 1] extends ["b", any] ? ["a", 1][1] : never)
  // 결과: never (false)

  | // 2. T = ["b", "hello"] 일 때
  (["b", "hello"] extends ["b", any] ? ["b", "hello"][1] : never)
  // 결과: "hello" (true이므로 ["b", "hello"][1] -> "hello")

  | // 3. T = ["c", boolean] 일 때
  (["c", boolean] extends ["b", any] ? ["c", boolean][1] : never)
  // 결과: never (false)
```

- `"b"` 키의 최종 값 타입: `never | "hello" | never` => **`"hello"`**
#### K = "c" 일 때

- 값 타입: `T extends ["c", any] ? T[1] : never`
- `T`에 대해 다시 분산이 일어납니다.

```ts
  // 1. T = ["a", 1] 일 때
  (["a", 1] extends ["c", any] ? ["a", 1][1] : never)
  // 결과: never (false)

  | // 2. T = ["b", "hello"] 일 때
  (["b", "hello"] extends ["c", any] ? ["b", "hello"][1] : never)
  // 결과: never (false)

  | // 3. T = ["c", boolean] 일 때
  (["c", boolean] extends ["c", any] ? ["c", boolean][1] : never)
  // 결과: boolean (true이므로 ["c", boolean][1] -> boolean)
```

- `"c"` 키의 최종 값 타입: `never | never | boolean` => **`boolean`**

#### 3단계: 최종 결과 조합

```ts
type Result = ObjectFromEntries<MyUnion>;
// Result는 다음과 같습니다:
// {
//   a: 1;
//   b: "hello";
//   c: boolean;
// }
```

### 요약

1. `[K in T[0]]`가 유니언 `T`에서 모든 키의 유니언 (`"a" | "b" | "c"`)을 뽑아냅니다.
2. 매핑된 타입이 각 키(`"a"`, `"b"`, `"c"`)를 순회합니다.
3. 각 키 `K`에 대해, 값 타입 `T extends [K, any] ? T[1] : never`가 계산됩니다.
4. 이때 `T`가 유니언이므로, 조건부는 **`T`의 모든 멤버에 대해 분산 적용**됩니다.
5. `K`와 일치하는 첫 번째 요소를 가진 멤버만 `T[1]` (값)을 반환하고, 나머지는 `never`를 반환합니다.
6. 이 결과들이 다시 유니언으로 합쳐져 (예: `1 | never | never` -> `1`), 해당 키의 최종 값 타입이 됩니다.
---
### 공변성 및 반공변성에서의 추론

- 반공변성에서는 동일 유형 변수에 대한 여러 후보가 있으면 Inntersection 타입으로 추론된다.

``` ts
type Bar<T> = T extends { a: (x: infer U) => void; b: (x: infer U) => void }
	? U
	: never;

type T20 = Bar<{ a: (x: string) => void; b: (x: string) => void }>; // string

type T21 = Bar<{ a: (x: string) => void; b: (x: number) => void }>; // string & number
```

---
### 함수 의 여러 호출 시그니처에서 반환 유형 추론

- 여러 호출 시그니처가 있는 유형(오버로도 된 함수의 유형)에서 추론할 때, 추론은 마지막 시그니처(가장 관대한 포괄적 사례)로 수행된다.

``` ts
declare function foo(x: string): number;

declare function foo(x: number): string;

declare function foo(x: string | number): string | number;

type T30 = ReturnType<typeof foo>; // string | number

```




 