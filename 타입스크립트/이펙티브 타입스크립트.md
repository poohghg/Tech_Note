
### 아이템 12. 함수 표현식에 타입 적용하기

타입스크립트에서는 함수 표현식을 사용하는 것이 좋다. 함수의 매개변수 부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문이다.
- 함수의 매개변수에 타입 선언을 하는 것보다 함수 표현식 전체 타입을 정의 하는것이 코드도 간결하고,안정하다.
- 동일한 타입 시그니처 함수의 경우 반복 작성 하지 말고 함수 전체의 타입 선언을 적용 해야 한다.

---
### 아이템 13. 타입과 인터페이스의 차이점 알기

타입스크립트에서는 명명된 타입을 정의하는 방법이 두 가지 있다.
- 타입 선언
- 인터페이스 선언

> 명명된 타입을 정의할 때 인터페이스 대신 클래스를 사용할 수도 있지만, 클래스는 값으로도 쓰일 수 있는 자바스크립트 런타임 개념이다.

- 명명된 타입은 인터페이스,타입 모두 차이가 없다.
- 인덱스 시그니처는 둘 다 사용 가능하다.
- 함수 타입도 모두 정의 가능하다.

```
type TFn = (x: number) => string;  
​  
interface IFn {  
  (x: number): string;  
}
```

- 타입 별칭과 인터페이스 모두 제네릭이 가능하다.
- 타입 확장 방식에서는 차이가 있다.
	- 인터페이스는 타입을 확장 할 수 있지만, 타입은 인터페이스를 확장 할 수 없다.
	- 인터페이스는 유니온 타입 같은 복잡한 타입은 확장하지 못한다. 복잡한 타입의 경우 &를 사용해야한다.
- 타입 별칭이 인터페이스 보다 쓰임새가 많다.
	- 튜플 과 배열 타입의 경우 타입 별칭으로 간결하게 표현 가능하다.
- 반면 인터페이스는 선언 병합이 가능하다.
	- 선언 병합은 새로운 속성을 추가 할 때 사용한다.

```
interface IState {
  a: string;
}

interface IState {
  b: string;
}

const state: IState = {
  a: 'a',
  b: 'b',
};
```

---
### 아이템14. 타입 연산과 제너릭 사용으로 반복 줄이기

같은 코드를 반복하지 말라는 DRY(dont repeat yourself)지키기.

- 반복을 줄이는 가장 간단한 방법은 타입에 이름을 붙이는 것이다.
- 인터페이스간 필드의 부분 집합을 공유한다면, 공통 필드만 골라서 기반 클래스로 분리해 낼 수 있다.
- 특정 인터페이스의 부분집합을 사용하면 전체 앱의 상태를 하나의 인터페이스로 유지할 수 있게 한다.

```
interface IState {  
	a: string;  
	b: string;  
	c: number;  
	d: boolean;  
}  

// Istate의 속성을 사용하는 새로운 인터페스를 만들어서 사용한다.  
type TABStateKey = keyof IState;  

// Pick과 동일
type IABState = {  
	[key in TABStateKey]: IState[key];  
};

```

> 값으로 부터 타입을 만들어 낼 때는 선언의 순서에 주의해야 한다. 타입 정의를 먼저 하고 값이 그 타입에 할당 가능하다고 선언하는 것이 좋다. 그렇게 해야 타입이 명확해지고, 예상하기 어려운 타입 변동을 방지할 수 있다.

- 제네릭 타입은 타입을 위한 함수와 같다.
	- 타입을 반복하는 대신 제네릭 타입을 사용하여 타입들 간에 매핑을 하는게 좋다.
- 제네릭 타입에서 함수 타입과 같이 타입 제한을 위해 extends 키워드를 사용 할 수 있다.
	- extends를 사용하면 제네릭 매개변수가 특정 타입을 확장한다고 선언 할 수 있다.

### 아이템 15. 동적 데이터에 인덱스 시그니처 사용하기

자바스크립트 객체는 문자열 키(string,number,symbol)를 타입의 값에 관계업이 매핑 한다. 타입스크립트에서는 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현할 수 있다.
#### 인덱스 시그니처의 단점

```
type Prototype = { [key: string]: string };  
  
const prototype: Prototype = {  
	a: 'a',  
	b: 'b',  
	c: 'c',  
	d: 'd',  
};
```

- 키의 이름 : 키의 위치만 표시하는 용도, 타입 체커에서는 사용하지 않는다.
- 키의 타입 : string이나 number 또는 symbol의 조합이어야 하지만, 보통은 string을 사용
- 값의 타입 : 어떤 것이든 될 수 있다.

위 와 같은 경우 다음의 단점이 드러난다.
- 잘못된 키를 포함해 모든키를 허용한다.
- 특정 키가 필요하지 않는다. {}도 유효한 Prototype 타입의 타입이다.
- 키마다 다른 타입을 가질 수 없다.
- 키는 무엇이든 가능하기 때문에 자동 완성 기능이 동작 하지 않는다.

인덱스 시그니처는 부정확 함으로 명확한 타입을 정의 해서 사용해야 한다.
- 어떤 타입에 가능한 필드가 제한되어 있는 경우 사용하지 말아야 한다.
	- 선택적 필드 또는 유니온 타입으로 모델링 하는게 더 좋음
		- 유니온 타입이 최선이지만 번거로움이 있다.
	- 가능하다면 인터페이스,Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋다.

##### 사용경우
- 런타임 때까지 객체의 속성을 알 수 없을 경우에만 인덱스 시그니처를 사용
- 동적 데이터를 사용할때 사용
- 데이터의 타입을 정확하게 알지 못하는 경우에 사용
- 안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는 것을 고려한다.
---
 아이템16. number인덱스 시그니처보다는 array,튜플,arrayLike를 사용하기











