![Pasted image 20241106141827.png](../img/Pasted%20image%2020241106141827.png)

### # {} 타입 , Object 타입 , object 타입

#### {} 타입

-  any non-nullish value를 의미
- `{}`는 모든  타입을 의미한다.
	- null, undefined 는 제외
- 사살상 모든 값을 허용

``` ts
let a: {};
a = 42;          // ✔️ 허용됨 (number)
a = "hello";     // ✔️ 허용됨 (string)
a = { key: 1 };  // ✔️ 허용됨 (object)
a = [];          // ✔️ 허용됨 (array)
a = null;        // ❌ 허용되지 않음 (strictNullChecks가 활성화된 경우)
a = undefined;   // ❌ 허용되지 않음 (strictNullChecks가 활성화된 경우)
```

#### Object 타입 

- `Object`는 ECMAScript의 **Object 객체의 래퍼 타입**을 나타낸다.
- 원시 값(문자열, 숫자 등)은 해당 원시 값의 객체 래퍼(예: `String`, `Number`)로 변환되어 `Object` 타입에 할당될 수 있습니다.
- `null`과 `undefined`는 `Object` 타입에 속하지 않는다.

``` ts
let b: Object;

b = 123;         // 숫자 (가능, 숫자 래퍼 객체로 처리)
b = "hello";     // 문자열 (가능, 문자열 래퍼 객체로 처리)
b = [];          // 배열 (가능)
b = {};          // 객체 (가능)
b = () => {};    // 함수 (가능)
b = null;        // 오류
b = undefined;   // 오류
```

#### **차이점**

| 특성                      | `{}`                          | `Object`          |
| ----------------------- | ----------------------------- | ----------------- |
| **포함되는 값**              | 모든 값 (`null`과 `undefined` 제외) | 객체 및 객체 래퍼 타입만 포함 |
| **원시 타입**               | 허용                            | 허용 (객체 래퍼로 처리됨)   |
| **`null`과 `undefined`** | 허용되지 않음                       | 허용되지 않음           |
| **엄격도**                 | 더 넓은 범위                       | 상대적으로 좁음          |
#### object 타입

- 객체 리터럴 타입만 허용하는 타입
- 원시 값은 허용 되지 않는다.


``` ts
let c: object;

c = 123;         // 오류
c = "hello";     // 오류
c = [];          // 가능
c = {};          // 가능
c = () => {};    // 가능
```


--- 
### # void

void는 콜백을 대체할 수 있는 형식으로 간주한다.

- 타입스크립트상에서 void는 undefined의 하위 형식이다. 자바스크립트의 함수는 무언가를 반환한다. 명시적으로 값을 반환하든지 암묵적으로 undefined를 반환하는 식이다.
- 반환 형식으로 사용한 void는 다른 형식으로 치환할 수 있다. 이는 추가 콜백 패턴을 활용할 수 있다.
- 반환 형식을 void로 설정하면 반환 형식이 조금 더 구체적인 다양한 함수를 이용할 수 있다.
- 콜백이 무언가를 반환하더라도 이를 사용 되지 않으면 void로 전달된다.
	- 콜백이 반환값이 있더라도 void의 경우 undefined이다.
- 타입스크립트는 이를 대체성이라 부르며, 의미상 문제가 없다면 무언가를 다른것으로 대체할 수 있는 능력을 가리킨다.
---
### # Branded Types

기존 타입에 프로퍼티나 라벨들을 추가하여 보다 명확하고 구체적인 새로운 데이터 타입을 만드는 방법이다.
Branded Types는 기본 타입과 brand 프로퍼티에 있는 객체 리터럴을 결합하여 추가할 수 있다.

```ts
declare const __brand: unique symbol  
type Brand<B> = { [__brand]: B }  
  
export type Branded<T, B> = T & Brand<B>

//사용
type Email = Branded<string, 'Email'>  

```

- **__brand** 라는 하드코딩된 프로퍼티 대신 계산된 프로퍼티키를 사용할 수 있다.
- **unique symbol**을 사용해 이미 언급된 **key**의 중복 사용을 방지할 수 있다.
- 또한 **Brand** 유틸리티를 자체 파일에 작성하여 해당 프로퍼티의 읽기 접근을 차단할 수 있다.

``` ts
//예시
type UserId = Branded<number, 'UserId'>  
type OrderId = Branded<number, 'OrderId'>  
  
function getUserById(id: UserId) {    
}

function getOrderById(id: OrderId) {    
}  
    
const userId = 123 as UserId

getUserById(userId) // 올바름
getOrderById(userId) // 오류 발생
      

```
#### Branded Types의 장점

- 명확성: 변수의 용도를 명확하게 표현할 수 있다.
- 안정성과 정확성: 코드를 더 쉽게 추론하고 타입 불일치나 호환되지 않는 타입에 관한 에러를 잡아 이슈들을 막는데 도움이 된다.
- 유지 보수성: 모호홤과 혼동을 줄여 다른 사람들이 코드를 더 쉽게 이해할 수 있도록 함으로써 코드베이스를 좀 더 유지보수하기 쉽게 만들어준다.

Branded Types는 사용하면 개발자는 의도를 보다 명확하게 전달하고 오해나 변수들을 잘못 사용하는 것을 피할 수 있다. Branded Types는 다양한 타입의 데이터와 각각의 용도를 명확하게 구분하여 리팩토링을 더 쉽게 만들 수 있다.

#### 결론

Branded Types는 타입스크립트의 강력한 기능으로, 코드의 타입 안정성, 유지보수성, 명확성을 향상시키는 데 도움을 준다. 이러한 타입을 사용하면 데이터의 형태에 대한 더 나은 제어를 제공하고, 보다 표현력 있는 타입을 정의할 수 있으며, 컴파일 시 안전한 타입 검사를 통해 디버깅 시간을 줄이고 런타임 오류를 방지할 수 있다. Branded Types를 적절하게 사용하면 더 효율적이고 확장 가능하며 안전한 타입스크립트 프로젝트를 만들 수 있다.

> 출처 - https://siosio3103.medium.com/typescript-branded-types%EB%A1%9C-%EB%9F%B0%ED%83%80%EC%9E%84-%ED%83%80%EC%9E%85-%EC%95%88%EC%A0%95%EC%84%B1-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0-768222c8df0d
---
### # 문자열 하위 집합의 느슨한 자동 완성 활성화하기

``` ts
// string의 하위 형식이므로 유니온으로 담기는 순간 타입이 string으로 확장
type Test1 = 'T' | 'E' | 'S' | string   

type Test = 'T' | 'E' | 'S' | (string & {})  
  
const t = (test: Test) => {  
	return test  
}

```

- 인터섹션 타입은 타입스크립트가 하위 형식을 줄이지 못하게 하고 리터럴 형식을 보존하도록 설정한다.

---
### # declare const

`declare const`는 타입스크립트에서 특정 값이 이미 존재하며, 해당 값의 타입을 지정하려는 경우 사용됩니다. 주로 전역적으로 정의된 변수나 외부 라이브러리에서 제공되는 값을 타입스크립트에게 알려주기 위해 사용됩니다.

#### 주요 특징

1. **전역 변수 정의**:
    
    - `declare const`를 사용하면 값이 실제로 존재한다고 가정하며, 타입스크립트는 이 값을 컴파일 시점에서만 인식합니다.
    - 런타임에는 실제 값을 정의하지 않으므로, 선언된 변수는 코드에 영향을 미치지 않습니다.
2. **타입 선언 전용**:
    
    - `declare const`는 컴파일러가 타입 검사를 수행할 수 있도록 타입 정보를 제공하는 용도로만 사용됩니다.
    - 값의 초기화는 포함되지 않으며, 컴파일된 JavaScript에는 아무것도 출력되지 않습니다.
### 문법

typescript

코드 복사

`declare const variableName: Type;`

- `variableName`: 선언할 변수의 이름.
- `Type`: 변수의 타입.

---

#### 사용 사례

##### 1. 외부 전역 변수 선언

외부 환경에서 이미 정의된 전역 변수를 타입스크립트에게 알려주는 경우:

##### 2. 외부 라이브러리 지원

라이브러리에서 제공되는 전역 변수를 직접 선언:

##### 3. 타입만 선언하고 값을 따로 설정

값은 다른 코드에서 설정되고, 여기서는 타입만 지정할 때:

#### `declare`와 `const` 비교

- **`declare const`**:
    
    - 값을 정의하지 않고 타입만 지정.
    - 런타임에 변수가 정의되어 있어야만 에러가 발생하지 않음.
- **`const`**:
    
    - 값과 타입을 동시에 정의.
    - 런타임과 컴파일 시점 모두 변수가 존재.
#### 주의 사항

1. `declare const`는 값의 정의를 포함하지 않으므로, 해당 변수가 실제로 존재하지 않으면 런타임 에러가 발생합니다.
2. 값이 없고 타입만 정의되는 상황에서만 사용하세요.

#### 요약

`declare const`는 외부에서 정의된 값에 타입 정보를 추가하여 타입스크립트가 이를 인식할 수 있도록 하는 선언입니다. 이를 통해 런타임에서 존재하는 값에 대해 타입 안정성을 제공할 수 있습니다.