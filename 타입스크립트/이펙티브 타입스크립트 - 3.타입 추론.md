타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 추론은 수동으로 명시해야 하는 타입 구문의 수를 줄여 주기 때문에 , 코드의 전체적인 안정성이 향상된다. 해당 챕터에서는 타입 추론에서 발생 할 수 있는 몇 가지 문제와 그 해법을 안내한다.

### 아이템19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

타입스크립트에서 많은 타입 구문은 사실 불필요 할 수 있다. 모든 코드에 타입을 선언하는 것은 비생산적이고 형편없는 스타일로 여겨 질 수 있다.

비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 한다. 여기에 추가로 명시적 타입 구문을 넣는다면 불필요한 타입 선언으로 인해 코드가 번잡해 질 수 있다.

정보가 부족해서 타입스크립트가 스스로 타입을 판단하기 어려운 상황도 일부 있다.
일반적으로 타입스크립트에서 변수의 타입은 처음 등장할 때 결정된다.
이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는다. 타입 구문을 생략하여 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 하는 것이 좋다.

객체 리터럴의 경우 타입을 명시 하면 좋다. ==잉여 속성 체크==가 동작하여, 선택적 속성이 있는 타입의 오타 같은 오류를 잡는 데 효과적이다. 그리고 변수가 사용 되는 순간이 아닌 할당하는 시점에 오류가 표시 되도록 한다.

함수의 반환에 타입을 명시하는 이점
- 반환 타입을 명시하면, 구현상의 오류가 사용자 코드의 오류로 표기 되지 않는다.
- 반환 타입을 명시하는 것은 함수를 더욱 명확하게 정의하는 것이다.
	- 타입 시그니처를 먼저 작성하면 구현에 맞추어 함수를 정의 할 수 있다.
- 반환 타입을 명시하면 명명된 타입을 사용 할 수 있다.

###### 요약
- 타입스크립트가 타입을 추론 할 수 있다면 타입 구문을 작성하지 않는게 좋다.
- 이상적인  경우 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없다.
- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해 준다.
---
### 아이템20. 다른 타입에는 다른 변수 사용하기

변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다. 타입을 바꿀 수 있는 한 가지 방법은 범위를 좁히는 것인데 새로운 변수값을 포함하도록 확장하는 것이 아니라 타입을 더 작게 제한하는 것이다.

동일한 변수명에 타입이 다르다면, 타입스크립트 코드는 잘 동작할지 몰라도 사람에게 혼란을 줄 수 있다.
목적이 다른 곳에는 별도의 변수명을 사용하는게 좋다.
- 유니온 타입을 선언시에는 사용할때마다 확인 과정(타입 체크)이 필요하다.

###### 다른 타입에 별도의 변수를 사용하는게 바람직한 이유
- 서로 관련이 없는 두 개의 값을 분리 할 수 있다.
- 변수명을 더 구체적으로 지을 수 있다.
- 타입 추론을 향상시키며, 타입 구문이 불필요 해진다.
- 타입이 좀 더 간결해진다.
- const 키워드를 사용하면 코드가 간결해지고, 타입 체커가 타입을 추론하기 좋다.

###### 요약
- 변수의 값은 바뀔 수 있지만 타입은 일반적으로 바뀌지 않는다.
- 혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재상용하지 않다록 해야 한다.
---
### 아이템21.타입 넓히기



