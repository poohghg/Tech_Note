
### 아이템 12. 함수 표현식에 타입 적용하기

타입스크립트에서는 함수 표현식을 사용하는 것이 좋다. 함수의 매개변수 부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문이다.
- 함수의 매개변수에 타입 선언을 하는 것보다 함수 표현식 전체 타입을 정의 하는것이 코드도 간결하고,안정하다.
- 동일한 타입 시그니처 함수의 경우 반복 작성 하지 말고 함수 전체의 타입 선언을 적용 해야 한다.

---
### 아이템 13. 타입과 인터페이스의 차이점 알기
#타입과인터페이스 

interface는 객체의 형태를 확장하는데 용이한 반면, type은 튜플, 인터섹션, 유니온 등을 이용하여 더 복잡한 타입 정의 및 조합을 표현하는데 용이하다.

interface는 선언 병합을 지원하여 여러번 선언 할수 있고, 주로 객체 타입을 확장할때 유리히다. 동일한 이름을 가진 interface를 여러 번 선언하면, 이 속성들이 자동으로 합쳐진다.

반면 type으로 선언한 경우에는 동일한 이름을 중복 선언하면 에러가 발생한다. 대신 type은 튜플과 같은 복잡한 타입 표현이 가능하며, 복잡한 타입 조합을 위해 인터섹션(&)과 유니온(|) 연산자를 지원한다.


타입스크립트에서는 명명된 타입을 정의하는 방법이 두 가지 있다.
- 타입 선언
- 인터페이스 선언

> 명명된 타입을 정의할 때 인터페이스 대신 클래스를 사용할 수도 있지만, 클래스는 값으로도 쓰일 수 있는 자바스크립트 런타임 개념이다.

- 명명된 타입은 인터페이스,타입 모두 차이가 없다.
- 인덱스 시그니처는 둘 다 사용 가능하다.
- 함수 타입도 모두 정의 가능하다.

``` ts
type TFn = (x: number) => string;  
​  
interface IFn {  
  (x: number): string;  
}
```

- 타입 별칭과 인터페이스 모두 제네릭이 가능하다.
- 타입 확장 방식에서는 차이가 있다.
	- 인터페이스는 타입을 확장 할 수 있지만, 타입은 인터페이스를 확장 할 수 없다.
	- 인터페이스는 유니온 타입 같은 복잡한 타입은 확장하지 못한다. 복잡한 타입의 경우 &를 사용해야한다.
- 타입 별칭이 인터페이스 보다 쓰임새가 많다.
	- 튜플 과 배열 타입의 경우 타입 별칭으로 간결하게 표현 가능하다.
- 반면 인터페이스는 선언 병합이 가능하다.
	- 선언 병합은 새로운 속성을 추가 할 때 사용한다.

```ts
interface IState {
  a: string;
}

interface IState {
  b: string;
}

const state: IState = {
  a: 'a',
  b: 'b',
};
```

---
### 아이템14. 타입 연산과 제너릭 사용으로 반복 줄이기

같은 코드를 반복하지 말라는 DRY(dont repeat yourself)지키기.

- 반복을 줄이는 가장 간단한 방법은 타입에 이름을 붙이는 것이다.
- 인터페이스간 필드의 부분 집합을 공유한다면, 공통 필드만 골라서 기반 클래스로 분리해 낼 수 있다.
- 특정 인터페이스의 부분집합을 사용하면 전체 앱의 상태를 하나의 인터페이스로 유지할 수 있게 한다.

```
interface IState {  
	a: string;  
	b: string;  
	c: number;  
	d: boolean;  
}  

// Istate의 속성을 사용하는 새로운 인터페스를 만들어서 사용한다.  
type TABStateKey = keyof IState;  

// Pick과 동일
type IABState = {  
	[key in TABStateKey]: IState[key];  
};

```

> 값으로 부터 타입을 만들어 낼 때는 선언의 순서에 주의해야 한다. 타입 정의를 먼저 하고 값이 그 타입에 할당 가능하다고 선언하는 것이 좋다. 그렇게 해야 타입이 명확해지고, 예상하기 어려운 타입 변동을 방지할 수 있다.

- 제네릭 타입은 타입을 위한 함수와 같다.
	- 타입을 반복하는 대신 제네릭 타입을 사용하여 타입들 간에 매핑을 하는게 좋다.
- 제네릭 타입에서 함수 타입과 같이 타입 제한을 위해 extends 키워드를 사용 할 수 있다.
	- extends를 사용하면 제네릭 매개변수가 특정 타입을 확장한다고 선언 할 수 있다.

### 아이템 15. 동적 데이터에 인덱스 시그니처 사용하기

자바스크립트 객체는 문자열 키(string,number,symbol)를 타입의 값에 관계없이 매핑 한다. 타입스크립트에서는 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현할 수 있다.
- 숫자는 객체의 키가 될 수 있지만 런타임에 toString메서드로 문자열로 변환된다.
- 사실상 숫자를 키로 사용 할 수 없다.
#### 인덱스 시그니처의 단점

```
type Prototype = { [key: string]: string };  
  
const prototype: Prototype = {  
	a: 'a',  
	b: 'b',  
	c: 'c',  
	d: 'd',  
};
```

- 키의 이름 : 키의 위치만 표시하는 용도, 타입 체커에서는 사용하지 않는다.
- 키의 타입 : string이나 number 또는 symbol의 조합이어야 하지만, 보통은 string을 사용
- 값의 타입 : 어떤 것이든 될 수 있다.

위 와 같은 경우 다음의 단점이 드러난다.
- 잘못된 키를 포함해 모든키를 허용한다.
- 특정 키가 필요하지 않는다. {}도 유효한 Prototype 타입의 타입이다.
- 키마다 다른 타입을 가질 수 없다.
- 키는 무엇이든 가능하기 때문에 자동 완성 기능이 동작 하지 않는다.

인덱스 시그니처는 부정확 함으로 명확한 타입을 정의 해서 사용해야 한다.
- 어떤 타입에 가능한 필드가 제한되어 있는 경우 사용하지 말아야 한다.
	- 선택적 필드 또는 유니온 타입으로 모델링 하는게 더 좋음
		- 유니온 타입이 최선이지만 번거로움이 있다.
	- 가능하다면 인터페이스,Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋다.

##### 사용경우
- 런타임 때까지 객체의 속성을 알 수 없을 경우에만 인덱스 시그니처를 사용
- 동적 데이터를 사용할때 사용
- 데이터의 타입을 정확하게 알지 못하는 경우에 사용
- 안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는 것을 고려한다.
---
### 아이템 16. number인덱스 시그니처보다는 array,튜플,arrayLike를 사용하기

- 자바스크립트에선 객체,배열의 인덱스 요소를 문자열로 인식하고 접근하다.
	- 런타임시 발생
- 타입스크립트는 배열에 인덱스를 넘버 타입으로 디자인 하였다.
	- 이터러블 에서 사용가능한 for of, forEach에서 index는 number타입이다.
###### 요약
- 배열은 객체이므로 키는 숫자가 아니라 문자열이다. 인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 타입스크립트 코드이다.
- 인덱스 시그니처에 number를 사용하기보다 Array나 튜플, ArrayLike타입을 사용하는 것이 좋다.
---
### 아이템 17. 변경 관련된 오류 방지를 위해 readonly 사용하기

###### readonly array
- 배열의 요소를 읽을 수 있지만, 쓸 수는 없다.
- length를 읽을 수 있지만, 바꿀 수는 없다.
- 배열을 변경하는 메서드를 호출할 수 없다.
###### readonly 매개변수
- 타입스크립트는 매개변수가 함수 내에서 변경이 일어나는지 체크
- 호출하는 쪽에서 함수가 매개변수를 변경하지 않는다는 보장을 받게 된다.
- 호출하는 쪽에서 함수에 readonly 배열을 매개변수로 넣을 수도 있다.

만얀 함수가 매개변수를 변경하지 않는다면, readonly로 선언되어야 한다.
- 더 넓은 타입으로 호출이 가능하다.
- 의도치 않은 변경은 방지 된다.

> readonly는 얕은 복사로 값을 보호한다.
   readonly string[][][]은 readonly 배열의 변경 가능한 배열이 아니라 ==변경 가능한 배열의 readonly 배열==이다.

``` ts
function parseTaggedText(lines: string[]): string[][] {  
	const para: string[][] = [];  
	const currPara: string[] = [];  
	  
	const addPara = () => {  
		if (currPara.length) {  
			para.push(currPara); // 오류발생지점 currPara의 레퍼런스 값을 넣는중  
			currPara.length = 0; // 오류발생지점 currPara의 참조 힙 메모리를 0으로 할당  
		}  
	};  
  
	for (const line of lines) {  
		if (!line) {  
			addPara();  
		} else {  
			currPara.push(line);  
		}  
	}  
	
	addPara();  
	return para;  
}  
  
// output : [[],[],[]]  
  
function covertParseTaggedText(lines: string[]) {  
	const para: (readonly string[])[] = [];  
	let currPara: readonly string[] = [];  
  
	const addPara = () => {  
		if (currPara.length) {  
			para.concat([...currPara]);  
			currPara = [];  
		}  
	};  
  
	for (const line of lines) {  
		if (!line) {  
			addPara();  
		} else {  
			currPara = currPara.concat([line]);  
		}  
	}  
	addPara();  
	return [...para];  
}
```
###### 요약
- 만약 함수가 매개변수를 수정하지 않는다면 readonly로 선언하는것이 좋다. readonly 매개변수는 인터페이스를 명확하게 하며, 매개변수가 변경 되는 것을 방지한다.
- readonly를 사용하면 변경하면서 발생하는 오류를 방지할 수 있고, 변경이 발생하는 코드도 쉽게 찾을 수 있다.
- const 와 readonly의 차이를 이해햐아 한다.
- readonly는 얕게 동작한다는 것을 명심해야 한다.
---
### 아이템 18.매핑된 타입을 사용하여 값을 동기화하기

매핑 된 타입은 한 객체가 또 다른 객체와 정확히 같은 속성을 가지게 할 때 이상적이다.
매핑 된 타입을 사용해 타입스크립트가 코드에 제약을 강제하도록 할 수 있다.
- 코드의 안정성을 높히기 위해 매핑된 타입을 사용하여 객체,함수,클래스 등을 생성 할 수 있다.

> 실패에 닫힌 방법(보수적 접근법)은 오류 발생 시에 적즉적으로 대처하는 방향을 말한다. 말 그대로 방어적,보수적 접근법이다. 반대로 실패에 열린 방법은 오류 발생 시에 소극적으로 대처하는 방향이다. 만얀 보안과 관련된 곳이라면 실패에 닫힌 방법을 써야 할 것이고, 기능에 무리가 없고 사용성이 주용한 곳이라면 실패에 열린 방법을 써야 할 것이다.

###### 요약
- 매핑된 타입을 사용해서 관련된 값과 타입을 동기화하도록 한다.
- 인터페이스에 새로운 속성을 추가할 때, 선택을 강제하도록 매핑된 타입을 고려해야한다.















