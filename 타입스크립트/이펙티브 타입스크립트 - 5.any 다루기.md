전통적으로 프로그래밍 언어들의 타입 시스템은 완전히 정적 이거나 완전히 동적으로 확실히 구분되어 있었다.
그러나 ==타입스크립트의 타입 시스템은 선택적이고,점진적이기 때문에 정적 이면서도 동적인 특성을 동시에 가진다. 따라서 타입스크립트는 프로그램의 일부분에만 타입 시스템을 적용 할 수 있다.==
- 프로그램의 일부분에만 타입 시스템을 적용할 수 있다는 특성 덕분에 점진적인 마이그레이션이 가능하다.
- 마이그레이션 할 때 코드의 일부분에 타입 체크를 비활성화시켜주는 any타입이 중요한 역할을 한다.
### 아이템38. any타입은 가능한 한 좁은 범위에서만 사용하기

```TS
interface Bar {  
	a: string;  
}  
  
interface Foo {  
	b: string;  
}  
  
const processBar = (b: Bar) => {};  
  
const expressionReturningFoo = (): Foo => {  
	return {  
		b: 'hello',  
	};  
};  
  
const f1 = () => {  
	// 사용 하지 말아야 함  
	// 문맥 전체를 오염시킴  
	const foo: any = expressionReturningFoo();  
	processBar(foo);  
	return foo; // any 타입의 값이 반환  
};  
const f2 = () => {  
	const foo = expressionReturningFoo();
	// 해당 위치에서만 any로 변환  
	processBar(foo as any);  
	return foo; // Foo 타입의 값이 반환  
};

```

위 와 같은 비슷한 관점에서, 타입스크립트가 함수의 반환 타입을 추론할 수 있는 경우에도 함수의 반환 타입을 명시하는 것이 좋다. 함수의 반환 타입을 명시 하면 any타입이 함수 바깥으로 영향을 미치는 것을 방지 할 수 있다.

객체 생성시에도 마찬가지로 아주 작은 범위에 any타입을 단언하면 문맥의 흐름의 일부분에서만 any를 사용 하는 효과를 가질 수 있다.

###### 요약
- 의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 한다.
- 함수의 반환 타입이 any인 경우 타입 안정성이 나빠진다. 따라서 any 타입을 반환하면 안된다.
---
### 아이템39. any를 구체적으로 변형해서 사용하기

any는 자바스크립트에서 표현할 수 있는 모든 값을 아우르는 매우 큰 범위의 타입이다. 일반적인 상황에서는 any보다 더 구체적으로 표현할 수 있는 타입이 존재 할 가능성이 높기 때문에 더 구체적인 타입을 찾아 안전성을 높이도록 해야 한다. 

> any 대신 unknown 타입 등을 사용하는 것은 좋은 방식이다.
> 또한 객체 속성을 알 수 없을때 object 타입 사용시 객체의 키를 열거할 수는 있지만 속성에 접근 할 수 없다는 점에서 인덱스 시그니처 타입([[key]:string)을 사용하는게 더 좋다.

###### 요약
- any를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야 한다.
- any보다 더 정확하게 모델링 할 수 있도록 하는것이 좋다.
	- any []
	- {[[id:string]:any}
	- () => any

### 아이템 40. 함수 안으로 타입 단언문 감추기

함수를 작성하다 보면, 외부로 드러난 타입 정의는 간단하지만 내부 로직이 복잡해서 안전한 타입으로 구현하기 어려운 경우가 많다. 함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이지만, 불필요한 예외 상항까지 고려해 가며 타입 정보를 힘들게 구성할 필요는 없다. 함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝나는게 좋다. 프로젝트 전반에 위험한 타입 단언문이 드러나 있는 것보다, 제대로 타입이 정의된 함수 안으로 타입 단언문을 감추는 것이 더 좋은 설계이다.

###### 요약
- 타입 선언문은 일반적으로 타입을 위헙하게 만들지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 한다. 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 한다.
---
###  아이템 41.any의 진화를 이해하기

타입스크립트에서 일반적으로 변수의 타입은 변수를 선언할 때 결정된다. 그 후에 정제될 수 있지만, 새로운 값이 추가되도록 확장할 수는 없다. 그러나 any타입과 관련해서 예외인 경우가 존재 한다.

```TS
const test1 = (a: string[]) => {};  
const test2 = (a: (string | number)[]) => {};  
  
const result = []; // any[]  
  
result.push('a'); // string[]  
  
test1(result);  
  
result.push(1); // (string | number)[]  
  
test2(result);

```

result 타입은 any[] 로 선언 되었지만 string 타입의 값을 넣는 순간부터 타입은 string[]로 진화한다.
타입의 진화는 타입 좁히기와 다르다. 배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장 되며 진화된다.

- 조건문에서는 분기에 따라 타입이 변할 수도 있다.
- 변수의 초깃값이 null인 경우도 any의 진화가 일어난다.

any 타입의 진화는 noImplicitAny가 설정된 상태에서 변수의 타입이 암시적 any인 경우에만 일어난다. 명시적으로 any를 선언하면 타입이 그대로 유지된다.

any 타입의 진화는 암시적 any타입에 어떤 값을 할당할 때만 발생한다. 그리고 어떤 변수가 암시적 any 상태일 때 값을 읽으려고 하면 오류가 발생한다.

any가 진화하는 방식은 일반적인 변수가 추론되는 원리와 동일하다. 타입을 안전하게 지키기 위해서는 암시적 any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 더 좋은 설계이다.

###### 요약
- 일반적인 타입들은 정제되기만 하는 반면, 암시적 any와 any[] 타입은 진화 할 수 있다. 이러한 동작이 발생하는 코드를 인지해야 한다.
- any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 안전한 타입을 유지하는 방법이다.
---
### 아이템42.모르는 타입의 값에는 any대신 unknown을 사용하기

unknown 타입을 이해하기 위해서는 할당 가능성의 관점에서 any를 생각해 볼 필요가 있다. any가 강력하면서도 위험한 이유는 다음 두 가지 특징으로 부터 비롯된다.

- 어떠한 타입이든 any타입에 할당 가능하다.
- any 타입은 어떠한 타입으로도 할당 가능하다.

타입을 값의 집합으로 생각하는 관점에서, 한 집합은 다른 모든 집합의 부분 집합 이면서 동시에 상위집합이 될 수 없기 때문에, 분명히 any는 타입 시스템과 상충되는 면을 가지고 있다. 이러한 점이 any의 강력함의 원천 이면서 동시에 문제를 일으키는 원인이 된다. 타입 체커는 집합 기반이기 때문에 any를 사용하면 타입 체커가 무용지물이 된다는 것을 주의해야 한다.

```ts
// ✅ Use `never` for values that will never occur// 
const a: never = 2;  

let a: never;  
  
a = 2 as never;  
  
const a1: number = a; // number  
  
// ✅ Use `unknown` for values that could be anything

let b: unknown = 1;  
  
const b1: number = b as number; // number

```


unknown은 any대신 쓸 수 있는 타입 시스템에 부합하는 타입이다.
- unknown 타입에 어떠한 타입이든 할당 가능
- unknown 타입은 오직 unknown 과 any 타입에만 할당이 가능하다.
- unknown 타입인 상태로 값을 사용 할 수 없다, 적절한 타입으로 변환해야 한다.

반면 never 타입은 unknown타입과 반대이다.
- never타입에 어떠한 값도 할당 할 수 없다.
- never타입은 어떠한 타입으로도 할당 가능하다.

{} 타입은 null과 undefined를 제외한 모든 값을 포함한다.

object 타입은 모든 비기본형(non-primitive) 타입으로 이루어져있다.
- 객체, 배열이 포함되어 있다.

###### 요약
- unknown은 any 대신 사용할 수 있는 안전한 타입이다. 어떠한 값이 있지만 그타입을 알지 못하는 경우라면 unknown을 사용하면 된다.
- 사용자가 타입 단언문이나 타입 체크를 사용하도록 강제하려면 unknown을 사용하면 된다.
---
### 아이템43. 몽키 패치보다는 안전한 타입을 사용하기

자바스크립트의 가장 유명한 특징 중 하나는, 객체와 클래스에 임의의 속성을 추가할 수 있을 만큼 유연 하다는 것이다. 객체 속성을 추가할 수 있는 기능은 종종 웹 페이지에서 window 나 document에 값을 할당하여 전역 변수를 만드는 데 사용 된다.

타입 체커는 window 나 document의 내장 속성에 대해서는 알고 있지만, 임의로 추가한 속성에 대해서는 알지 못한다.

- interface의 선언전 병합(보강)을 사용 하여 해결
	- 더 안전한 타입이다. 타입 체커가 오타나 잘못된 타입의 할당을 오류로 표기함.
	- 속성의 자동완성 사용이 가능.
	- 몽키 패치가 어떤 부분에 적용되었는지 정확한 기록이 남는다.
- 모듈의 관점에서, 동작하게 하려면 global 선언을 추가한다.

```ts
declare global {  
	interface Document {  
		documentMode: string;  
	}  
}  
  
Document.prototype.documentMode = '11';  
  
document.documentMode;

```

보강을 사용할 때 주의해야 할 점은 모듈 영역과 관련 있다. 보강은 전역적으로 적용되기 때문에, 코드의 다른 부분이나 라이브러리로 부터 분리 할 수 없다.

###### 요약
- 전역 변수나 DOM에 데이터를 저장하지 말고, 데이터를 분리하여 사용해야 한다.
- 내장 타입에 데이터를 저장해야 하는 경우, 안전한 타입 접근법 중 하나를(보강, 사용자 정의 인터페이스로 단언) 사용해야 한다.
---
### 아이템44. 타입 커버리지를 추적하여 타입 안정성 유지하기

###### 요약
- noImplicitAny가 설정되어 있어도, 명시적 any 또는 서트파티 타입 선언을 통해 any타입은 코드 내에 여전히 존재 할 수 있다.
