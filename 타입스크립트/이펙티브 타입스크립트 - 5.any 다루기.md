전통적으로 프로그래밍 언어들의 타입 시스템은 완전히 정적 이거나 완전히 동적으로 확실히 구분되어 있었다.
그러나 ==타입스크립트의 타입 시스템은 선택적이고,점진적이기 때문에 정적 이면서도 동적인 특성을 동시에 가진다. 따라서 타입스크립트는 프로그램의 일부분에만 타입 시스템을 적용 할 수 있다.==
- 프로그램의 일부분에만 타입 시스템을 적용할 수 있다는 특성 덕분에 점진적인 마이그레이션이 가능하다.
- 마이그레이션 할 때 코드의 일부분에 타입 체크를 비활성화시켜주는 any타입이 중요한 역할을 한다.

### 아이템38. any타입은 가능한 한 좁은 범위에서만 사용하기

```
interface Bar {  
	a: string;  
}  
  
interface Foo {  
	b: string;  
}  
  
const processBar = (b: Bar) => {};  
  
const expressionReturningFoo = (): Foo => {  
	return {  
		b: 'hello',  
	};  
};  
  
const f1 = () => {  
	// 사용 하지 말아야 함  
	// 문맥 전체를 오염시킴  
	const foo: any = expressionReturningFoo();  
	processBar(foo);  
	return foo; // any 타입의 값이 반환  
};  
const f2 = () => {  
	const foo = expressionReturningFoo();
	// 해당 위치에서만 any로 변환  
	processBar(foo as any);  
	return foo; // Foo 타입의 값이 반환  
};

```

위 와 같은 비슷한 관점에서, 타입스크립트가 함수의 반환 타입을 추론할 수 있는 경우에도 함수의 반환 타입을 명시하는 것이 좋다. 함수의 반환 타입을 명시 하면 any타입이 함수 바깥으로 영향을 미치는 것을 방지 할 수 있다.

객체 생성시에도 마찬가지로 아주 작은 범위에 any타입을 단언하면 문맥의 흐름의 일부분에서만 any를 사용 하는 효과를 가질 수 있다.

###### 요약
- 의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 한다.
- 함수의 반환 타입이 any인 경우 타입 안정성이 나빠진다. 따라서 any 타입을 반환하면 안된다.
---
### 아이템39. any를 구체적으로 변형해서 사용하기

any는 자바스크립트에서 표현할 수 있는 모든 값을 아우르는 매우 큰 범위의 타입이다. 일반적인 상황에서는 any보다 더 구체적으로 표현할 수 있는 타입이 존재 할 가능성이 높기 때문에 더 구체적인 타입을 찾아 안전성을 높이도록 해야 한다. 

> any 대신 unknown 타입 등을 사용하는 것은 좋은 방식이다.
> 또한 객체 속성을 알 수 없을때 object 타입 사용시 객체의 키를 열거할 수는 있지만 속성에 접근 할 수 없다는 점에서 인덱스 시그니처 타입([key]]:string)을 사용하는게 더 좋다.


###### 요약
- any를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야 한다.
- any보다 더 정확하게 모델링 할 수 있도록 하는것이 좋다.
	- any []
	- {[[id:string]:any}
	- () => any