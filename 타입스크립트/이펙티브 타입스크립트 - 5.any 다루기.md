전통적으로 프로그래밍 언어들의 타입 시스템은 완전히 정적 이거나 완전히 동적으로 확실히 구분되어 있었다.
그러나 ==타입스크립트의 타입 시스템은 선택적이고,점진적이기 때문에 정적 이면서도 동적인 특성을 동시에 가진다. 따라서 타입스크립트는 프로그램의 일부분에만 타입 시스템을 적용 할 수 있다.==
- 프로그램의 일부분에만 타입 시스템을 적용할 수 있다는 특성 덕분에 점진적인 마이그레이션이 가능하다.
- 마이그레이션 할 때 코드의 일부분에 타입 체크를 비활성화시켜주는 any타입이 중요한 역할을 한다.

### 아이템38. any타입은 가능한 한 좁은 범위에서만 사용하기

```
interface Bar {  
	a: string;  
}  
  
interface Foo {  
	b: string;  
}  
  
const processBar = (b: Bar) => {};  
  
const expressionReturningFoo = (): Foo => {  
	return {  
		b: 'hello',  
	};  
};  
  
const f1 = () => {  
	// 사용 하지 말아야 함  
	// 문맥 전체를 오염시킴  
	const foo: any = expressionReturningFoo();  
	processBar(foo);  
	return foo; // any 타입의 값이 반환  
};  
const f2 = () => {  
	const foo = expressionReturningFoo();
	// 해당 위치에서만 any로 변환  
	processBar(foo as any);  
	return foo; // Foo 타입의 값이 반환  
};

```

위 와 같은 비슷한 관점에서, 타입스크립트가 함수의 반환 타입을 추론할 수 있는 경우에도 함수의 반환 타입을 명시하는 것이 좋다. 함수의 반환 타입을 명시 하면 any타입이 함수 바깥으로 영향을 미치는 것을 방지 할 수 있다.

객체 생성시에도 마찬가지로 아주 작은 범위에 any타입을 단언하면 문맥의 흐름의 일부분에서만 any를 사용 하는 효과를 가질 수 있다.

###### 요약
- 의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 한다.
- 함수의 반환 타입이 any인 경우 타입 안정성이 나빠진다. 따라서 any 타입을 반환하면 안된다.
---
### 아이템39. any를 구체적으로 변형해서 사용하기

any는 자바스크립트에서 표현할 수 있는 모든 값을 아우르는 매우 큰 범위의 타입이다. 일반적인 상황에서는 any보다 더 구체적으로 표현할 수 있는 타입이 존재 할 가능성이 높기 때문에 더 구체적인 타입을 찾아 안전성을 높이도록 해야 한다. 

> any 대신 unknown 타입 등을 사용하는 것은 좋은 방식이다.
> 또한 객체 속성을 알 수 없을때 object 타입 사용시 객체의 키를 열거할 수는 있지만 속성에 접근 할 수 없다는 점에서 인덱스 시그니처 타입([[key]:string)을 사용하는게 더 좋다.

###### 요약
- any를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야 한다.
- any보다 더 정확하게 모델링 할 수 있도록 하는것이 좋다.
	- any []
	- {[[id:string]:any}
	- () => any

### 아이템 40. 함수 안으로 타입 단언문 감추기

함수를 작성하다 보면, 외부로 드러난 타입 정의는 간단하지만 내부 로직이 복잡해서 안전한 타입으로 구현하기 어려운 경우가 많다. 함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이지만, 불필요한 예외 상항까지 고려해 가며 타입 정보를 힘들게 구성할 필요는 없다. 함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝나는게 좋다. 프로젝트 전반에 위험한 타입 단언문이 드러나 있는 것보다, 제대로 타입이 정의된 함수 안으로 타입 단언문을 감추는 것이 더 좋은 설계이다.

###### 요약
- 타입 선언문은 일반적으로 타입을 위헙하게 만들지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 한다. 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 한다.
---
###  아이템 41.any의 진화를 이해하기

타입스크립트에서 일반적으로 변수의 타입은 변수를 선언할 때 결정된다. 그 후에 정제될 수 있지만, 새로운 값이 추가되도록 확장할 수는 없다. 그러나 any타입과 관련해서 예외인 경우가 존재 한다.

```
const test1 = (a: string[]) => {};  
const test2 = (a: (string | number)[]) => {};  
  
const result = []; // any[]  
  
result.push('a'); // string[]  
  
test1(result);  
  
result.push(1); // (string | number)[]  
  
test2(result);

```

result 타입은 any[] 로 선언 되었지만 string 타입의 값을 넣는 순간부터 타입은 string[]로 진화한다.
타입의 진화는 타입 좁히기와 다르다. 배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장 되며 진화된다.

- 조건문에서는 분기에 따라 타입이 변할 수도 있다.
- 변수의 초깃값이 null인 경우도 any의 진화가 일어난다.

any 타입의 진화는 noImplicitAny가 설정된 상태에서 변수의 타입이 암시적 any인 경우에만 일어난다. 명시적으로 any를 선언하면 타입이 그대로 유지된다.

any 타입의 진화는 암시적 any타입에 어떤 값을 할당할 때만 발생한다. 그리고 어떤 변수가 암시적 any 상태일 때 값을 읽으려고 하면 오류가 발생한다.

any가 진화하는 방식은 일반적인 변수가 추론되는 원리와 동일하다. 타입을 안전하게 지키기 위해서는 암시적 any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 더 좋은 설계이다.

###### 요약
- 일반적인 타입들은 정제되기만 하는 반면, 암시적 any와 any[] 타입은 진화 할 수 있다. 이러한 동작이 발생하는 코드를 인지해야 한다.
- any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 안전한 타입을 유지하는 방법이다.