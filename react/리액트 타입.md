###  리액트 타입 정리: ComponentType vs ReactElement 

| 타입                     | 의미                        | 언제 쓰는지                      |
| ---------------------- | ------------------------- | --------------------------- |
| **`ComponentType<P>`** | **컴포넌트 정의** (함수형 or 클래스형) | HOC, 컴포넌트 주입, 동적 컴포넌트       |
| **`ReactElement<P>`**  | **렌더링된 결과물(JSX)**         | JSX의 반환 타입, 실제 DOM에 들어가는 객체 |

#### 개념 요약 표

| 타입                                                     | 의미                         | 대표 사용처                                           | 핵심 포인트                                               |
| ------------------------------------------------------ | -------------------------- | ------------------------------------------------ | ---------------------------------------------------- |
| ComponentType<P>                                       | 컴포넌트(함수형 또는 클래스형)를 나타내는 타입 | HOC의 인자/반환, 컴포넌트 주입(DI), 동적 컴포넌트                 | 사용자 정의 컴포넌트만. ‘div’ 같은 태그는 포함 안 됨                    |
| ElementType                                            | JSX에서 사용할 수 있는 “요소 타입”     | 동적으로 태그 또는 컴포넌트 선택                               | 'div' 같은 intrinsic 요소 + 사용자 컴포넌트 모두 포함               |
| ReactElement<P, T>                                     | 렌더링된 결과물(가상 DOM 노드)        | JSX 반환 타입(실제로는 JSX.Element), children 제한이 필요한 경우 | 구체적인 엘리먼트 한 개를 표현                                    |
| JSX.Element                                            | JSX가 반환하는 표준 타입            | 컴포넌트의 반환 타입 주석                                   | 실무에선 반환 타입으로 JSX.Element를 가장 흔히 사용                   |
| ReactNode                                              | 렌더링 가능한 모든 값의 합집합          | children 타입                                      | string, number, ReactElement, Fragment, Portal, 배열 등 |
| ReactPortal                                            | Portal 결과물                 | Portal 관련 API                                    | ReactNode에 포함되지만 별도 식별 가능                            |
| PropsWithChildren<P>                                   | P에 children 추가             | children 받는 컴포넌트의 Props 정의                       | children 옵셔널 포함                                      |
| PropsWithoutRef<P> / PropsWithRef<P>                   | ref 포함/제거                  | forwardRef, 외부 래핑 시                              | Ref가 섞일 때 안전한 Props 유틸                               |
| ComponentProps<T>                                      | 컴포넌트/태그의 Props 추론          | 재사용 가능한 래퍼, 컴포넌트 주입, 스타일 래핑                      | typeof Button 또는 'a' 같은 문자열도 가능                      |
| ComponentPropsWithoutRef<T> / ComponentPropsWithRef<T> | ref 유무까지 고려한 Props 추론      | forwardRef 조합                                    | DOM 컴포넌트/함수형 컴포넌트 차이 대응                              |
| ComponentRef<T>                                        | 특정 컴포넌트의 ref 대상 타입         | useRef, forwardRef의 타입                           | DOM 요소나 컴포넌트 인스턴스 타입 추론                              |
| ForwardRefExoticComponent<P>                           | forwardRef로 만든 컴포넌트 타입     | forwardRef 결과 타입                                 | ref prop을 Exotic하게 다룸                                |
| MemoExoticComponent<C>                                 | React.memo 결과 타입           | 메모이제이션된 컴포넌트                                     | .type 등으로 원형 접근 가능                                   |
| LazyExoticComponent<C>                                 | React.lazy 결과 타입           | 코드 스플리팅                                          | Suspense와 함께 사용                                      |
| ExoticComponent<P>                                     | Exotic 컴포넌트의 공통 기반         | 내부 유틸/고급 패턴                                      | 메모/레이지/프로바이더 등                                       |

자주 쓰는 구분 포인트

- ComponentType vs ElementType
    - `ComponentType<P>`: 사용자 정의 컴포넌트만 허용. 태그 문자열('div')는 안 됨.
- ElementType: 태그 문자열과 사용자 컴포넌트 모두 허용. “동적 태그/컴포넌트 선택”에 최적.
- ReactElement vs JSX.Element vs ReactNode
    - JSX.Element: 컴포넌트가 JSX를 반환할 때의 표준 반환 타입.
    - ReactElement: 특정 엘리먼트 한 개를 표현하는 타입(제네릭으로 props/타입협약 가능).
    - ReactNode: 렌더링 가능한 모든 것(children에 가장 적합).

실전 예제

1. HOC: 컴포넌트를 인자로 받고 같은 Props를 가진 새 컴포넌트를 반환

``` tsx
import React, { ComponentType } from 'react';

function withLoading<P>(Wrapped: ComponentType<P>) {
  return function WithLoading(props: P & { loading?: boolean }) {
    if (props.loading) return <div>Loading...</div>;
    const { loading, ...rest } = props as any;
    return <Wrapped {...(rest as P)} />;
  };
}
```

- 동적 컴포넌트 렌더링

``` tsx
import React, { ComponentType } from "react";

interface AlertProps { message: string }
const InfoAlert = ({ message }: AlertProps) => <div style={{ color: "blue" }}>{message}</div>;
const WarningAlert = ({ message }: AlertProps) => <div style={{ color: "orange" }}>{message}</div>;
const ErrorAlert = ({ message }: AlertProps) => <div style={{ color: "red" }}>{message}</div>;

// alertType에 따라 동적으로 컴포넌트를 선택
const alertsMap: Record<string, ComponentType<AlertProps>> = {
  info: InfoAlert,
  warning: WarningAlert,
  error: ErrorAlert,
};

interface DynamicAlertProps {
  type: "info" | "warning" | "error";
  message: string;
}

const DynamicAlert = ({ type, message }: DynamicAlertProps) => {
  const AlertComponent = alertsMap[type]; // 동적 선택
  return <AlertComponent message={message} />;
};

// 사용
const App = () => (
  <>
    <DynamicAlert type="info" message="Info!" />
    <DynamicAlert type="warning" message="Watch out!" />
    <DynamicAlert type="error" message="Something went wrong!" />
  </>
);

```

2. 동적 컴포넌트/태그 선택: ElementType 사용

``` tsx
import React, { ElementType } from 'react';

type PolymorphicProps<E extends ElementType> = {
  as?: E;
  children?: React.ReactNode;
} & Omit<React.ComponentProps<E>, 'as' | 'children'>;

function Box<E extends ElementType = 'div'>({ as, children, ...rest }: PolymorphicProps<E>) {
  const Tag = as ?? 'div';
  return <Tag {...rest}>{children}</Tag>;
}

// 사용
<Box as="a" href="/docs">링크</Box>
<Box as={MyButton} variant="primary">버튼</Box>
```

3. 컴포넌트 주입(Dependency Injection): ComponentType과 ComponentProps

``` tsx
import React, { ComponentType, ComponentProps } from 'react';

type InjectProps<C extends ComponentType<any>> = {
  Component: C;
  componentProps: ComponentProps<C>;
};

function Injector<C extends ComponentType<any>>({ Component, componentProps }: InjectProps<C>) {
  return <Component {...componentProps} />;
}

// 사용
function PrimaryButton(props: { onClick: () => void; children: React.ReactNode }) {
  return <button className="primary" {...props} />;
}

<Injector Component={PrimaryButton} componentProps={{ onClick: () => {}, children: '확인' }} />
```

4. children 타입은 ReactNode가 정석


``` tsx
type CardProps = React.PropsWithChildren<{
  title: string;
}>;

function Card({ title, children }: CardProps) {
  return (
    <section>
      <h2>{title}</h2>
      {children}
    </section>
  );
}
```

5. JSX 반환 타입 표기: JSX.Element (가장 흔함)


``` tsx
function Hello(): JSX.Element {
  return <div>Hello</div>;
}
```

6. 특정 엘리먼트 한 개를 인자로 받을 때: ReactElement


``` tsx
import { ReactElement } from 'react';

function OnlyOneChild({ child }: { child: ReactElement }) {
  // child는 반드시 하나의 유효한 React 엘리먼트
  return <div className="only-one">{child}</div>;
}
```

7. DOM/컴포넌트 Props 추론: ComponentProps/ComponentPropsWithoutRef/WithRef


``` tsx
type AnchorProps = React.ComponentProps<'a'>; // HTMLAnchorElement에 해당하는 props
type ButtonPropsNoRef = React.ComponentPropsWithoutRef<'button'>;

function LinkLike(props: AnchorProps) { /* ... */ return <a {...props} /> }
```

8. ref 타입 안전하게: forwardRef + ComponentRef


``` tsx
import React, { forwardRef } from 'react';

type InputProps = React.ComponentPropsWithoutRef<'input'>;

const TextInput = forwardRef<HTMLInputElement, InputProps>(function TextInput(props, ref) {
  return <input ref={ref} {...props} />;
});

// 사용
const ref = React.createRef<React.ComponentRef<typeof TextInput>>(); // HTMLInputElement
<TextInput ref={ref} />
```

9. memo / lazy의 타입


``` tsx
const Memoized = React.memo(MyComponent); // MemoExoticComponent<typeof MyComponent>
const LazyComp = React.lazy(() => import('./MyComponent')); // LazyExoticComponent<...>
```

10. Portal 타입


``` tsx
import { createPortal } from 'react-dom';
import type { ReactPortal } from 'react';

function renderToBody(node: React.ReactNode): ReactPortal {
  return createPortal(node, document.body);
}
```

언제 어떤 타입을 쓰나 요약

- 컴포넌트 그 자체를 다룰 때: `ComponentType<P>` (HOC, 컴포넌트 주입)
- 태그/컴포넌트를 모두 유연하게 받을 때: ElementType
- JSX 반환 타입을 지정할 때: JSX.Element
- children처럼 “렌더링 가능한 모든 것”을 받을 때: ReactNode
- “엘리먼트 한 개”만 받을 때: ReactElement
- DOM/컴포넌트의 Props를 재사용하고 싶을 때: ComponentProps/ComponentPropsWithoutRef/WithRef
- ref를 안전하게 전달/타이핑할 때: forwardRef + ComponentRef/PropsWithRef
- 성능 최적화/코드 스플리팅 결과 타입: MemoExoticComponent, LazyExoticComponent

자주 하는 오해/주의

- `FC<Props>`는 기본적으로 children을 포함시켜 주지만, 최근에는 명시적으로 PropsWithChildren를 쓰는 것이 의도가 더 명확합니다. 또한 FC는 defaultProps 관련 제약 등으로 선호도가 낮아졌습니다.
- ComponentType vs ElementType를 혼동하지 않기: 태그 문자열을 받으려면 ElementType을 사용하세요.
- children 타입을 ReactElement로 좁혀버리면 string/number/Fragment 등 유효한 JSX가 막힙니다. 일반적으로 ReactNode가 정답입니다.
- 반환 타입은 대부분 JSX.Element로 충분합니다. ReactElement를 반환 타입으로 강제할 필요는 거의 없습니다.

### 컴포넌트 타입 계층

``` 
any
 └─ ReactNode
      ├─ ReactChild
      │    ├─ ReactElement
      │    └─ string | number
      ├─ ReactFragment
      ├─ ReactPortal
      └─ boolean | null | undefined

```

### #**`ReactNode`**

- 가장 범용적인 타입.
- **렌더링 가능한 모든 것**을 의미.
- 포함하는 것:
    - JSX (`<div />`, `<MyComp />`)
    - 문자열/숫자 (`"hello"`, `42`)
    - 배열(`ReactNode[]`)
    - `null`, `undefined`, `false` (렌더링되지 않음)
- 예시:

``` tsx
const node: React.ReactNode = (
  <>
    Hello
    <span>World</span>
    {false}
    {null}
    {["Array", <strong>of</strong>, "nodes"]}
  </>
);

```

---

### **`ReactChild`**

- `ReactNode`의 하위 타입.
- 단일 렌더링 가능한 요소:
    - 문자열/숫자
    - `ReactElement```
### **`ReactElement<P>`**

- JSX/컴포넌트 호출 결과물.
- 제네릭 `P`는 **props 타입**.
    

``` tsx

const elem: React.ReactElement<{ name: string }> = <MyComp name="John" />;

```

- 특징:
    - `type` (컴포넌트 함수/클래스)
    - `props` (컴포넌트 props)
    - `key` 등
---

### **`ReactFragment`**

- 배열/조합 렌더링용 타입 (`<>...</>`).
    
- JSX에서 `<></>`가 반환하는 타입.
    

`const frag: React.ReactFragment = (   <>     <div>1</div>     <div>2</div>   </> );`

---

### **`ReactPortal`**

- ReactDOM.createPortal로 생성되는 포털.
    
- 예: 모달을 다른 DOM 루트에 렌더링할 때 사용.
    

`const portal: React.ReactPortal = ReactDOM.createPortal(   <div>Modal</div>,   document.body );`

---

### **boolean | null | undefined**

- 렌더링하지 않을 때 허용.
    

`const maybe: React.ReactNode = condition ? <div>Show</div> : null;`

---

## 3️⃣ 요약

|타입|의미|포함 예시|
|---|---|---|
|`ReactNode`|모든 렌더링 가능한 것|string, number, JSX, fragment, portal, null, boolean, array|
|`ReactChild`|단일 렌더링 가능한 요소|string, number, JSX|
|`ReactElement<P>`|컴포넌트/JSX 결과|`<MyComp name="x" />`|
|`ReactFragment`|배열/조합|`<>...</>`|
|`ReactPortal`|포털 렌더링|`createPortal(<div />, root)`|

---

💡 핵심 팁:

- **`children` 타입**에는 보통 `ReactNode`를 사용합니다.
    
- **HOC 반환 타입**이나 “컴포넌트 주입”에는 `ComponentType<P>`를 사용합니다.
    
- **JSX 결과를 저장/조작**할 때는 `ReactElement<P>`를 사용합니다.