개념 요약 표

|타입|의미|대표 사용처|핵심 포인트|
|---|---|---|---|
|ComponentType<P>|컴포넌트(함수형 또는 클래스형)를 나타내는 타입|HOC의 인자/반환, 컴포넌트 주입(DI), 동적 컴포넌트|사용자 정의 컴포넌트만. ‘div’ 같은 태그는 포함 안 됨|
|ElementType|JSX에서 사용할 수 있는 “요소 타입”|동적으로 태그 또는 컴포넌트 선택|'div' 같은 intrinsic 요소 + 사용자 컴포넌트 모두 포함|
|ReactElement<P, T>|렌더링된 결과물(가상 DOM 노드)|JSX 반환 타입(실제로는 JSX.Element), children 제한이 필요한 경우|구체적인 엘리먼트 한 개를 표현|
|JSX.Element|JSX가 반환하는 표준 타입|컴포넌트의 반환 타입 주석|실무에선 반환 타입으로 JSX.Element를 가장 흔히 사용|
|ReactNode|렌더링 가능한 모든 값의 합집합|children 타입|string, number, ReactElement, Fragment, Portal, 배열 등|
|ReactPortal|Portal 결과물|Portal 관련 API|ReactNode에 포함되지만 별도 식별 가능|
|PropsWithChildren<P>|P에 children 추가|children 받는 컴포넌트의 Props 정의|children 옵셔널 포함|
|PropsWithoutRef<P> / PropsWithRef<P>|ref 포함/제거|forwardRef, 외부 래핑 시|Ref가 섞일 때 안전한 Props 유틸|
|ComponentProps<T>|컴포넌트/태그의 Props 추론|재사용 가능한 래퍼, 컴포넌트 주입, 스타일 래핑|typeof Button 또는 'a' 같은 문자열도 가능|
|ComponentPropsWithoutRef<T> / ComponentPropsWithRef<T>|ref 유무까지 고려한 Props 추론|forwardRef 조합|DOM 컴포넌트/함수형 컴포넌트 차이 대응|
|ComponentRef<T>|특정 컴포넌트의 ref 대상 타입|useRef, forwardRef의 타입|DOM 요소나 컴포넌트 인스턴스 타입 추론|
|ForwardRefExoticComponent<P>|forwardRef로 만든 컴포넌트 타입|forwardRef 결과 타입|ref prop을 Exotic하게 다룸|
|MemoExoticComponent<C>|React.memo 결과 타입|메모이제이션된 컴포넌트|.type 등으로 원형 접근 가능|
|LazyExoticComponent<C>|React.lazy 결과 타입|코드 스플리팅|Suspense와 함께 사용|
|ExoticComponent<P>|Exotic 컴포넌트의 공통 기반|내부 유틸/고급 패턴|메모/레이지/프로바이더 등|

자주 쓰는 구분 포인트

- ComponentType vs ElementType
    - `ComponentType<P>`: 사용자 정의 컴포넌트만 허용. 태그 문자열('div')는 안 됨.
- ElementType: 태그 문자열과 사용자 컴포넌트 모두 허용. “동적 태그/컴포넌트 선택”에 최적.
- ReactElement vs JSX.Element vs ReactNode
    - JSX.Element: 컴포넌트가 JSX를 반환할 때의 표준 반환 타입.
    - ReactElement: 특정 엘리먼트 한 개를 표현하는 타입(제네릭으로 props/타입협약 가능).
    - ReactNode: 렌더링 가능한 모든 것(children에 가장 적합).

실전 예제

1. HOC: 컴포넌트를 인자로 받고 같은 Props를 가진 새 컴포넌트를 반환

``` tsx
import React, { ComponentType } from 'react';

function withLoading<P>(Wrapped: ComponentType<P>) {
  return function WithLoading(props: P & { loading?: boolean }) {
    if (props.loading) return <div>Loading...</div>;
    const { loading, ...rest } = props as any;
    return <Wrapped {...(rest as P)} />;
  };
}
```

- 동적 컴포넌트 렌더링

``` tsx
import React, { ComponentType } from "react";

interface AlertProps { message: string }
const InfoAlert = ({ message }: AlertProps) => <div style={{ color: "blue" }}>{message}</div>;
const WarningAlert = ({ message }: AlertProps) => <div style={{ color: "orange" }}>{message}</div>;
const ErrorAlert = ({ message }: AlertProps) => <div style={{ color: "red" }}>{message}</div>;

// alertType에 따라 동적으로 컴포넌트를 선택
const alertsMap: Record<string, ComponentType<AlertProps>> = {
  info: InfoAlert,
  warning: WarningAlert,
  error: ErrorAlert,
};

interface DynamicAlertProps {
  type: "info" | "warning" | "error";
  message: string;
}

const DynamicAlert = ({ type, message }: DynamicAlertProps) => {
  const AlertComponent = alertsMap[type]; // 동적 선택
  return <AlertComponent message={message} />;
};

// 사용
const App = () => (
  <>
    <DynamicAlert type="info" message="Info!" />
    <DynamicAlert type="warning" message="Watch out!" />
    <DynamicAlert type="error" message="Something went wrong!" />
  </>
);

```

2. 동적 컴포넌트/태그 선택: ElementType 사용

``` tsx
import React, { ElementType } from 'react';

type PolymorphicProps<E extends ElementType> = {
  as?: E;
  children?: React.ReactNode;
} & Omit<React.ComponentProps<E>, 'as' | 'children'>;

function Box<E extends ElementType = 'div'>({ as, children, ...rest }: PolymorphicProps<E>) {
  const Tag = as ?? 'div';
  return <Tag {...rest}>{children}</Tag>;
}

// 사용
<Box as="a" href="/docs">링크</Box>
<Box as={MyButton} variant="primary">버튼</Box>
```

3. 컴포넌트 주입(Dependency Injection): ComponentType과 ComponentProps


``` tsx
import React, { ComponentType, ComponentProps } from 'react';

type InjectProps<C extends ComponentType<any>> = {
  Component: C;
  componentProps: ComponentProps<C>;
};

function Injector<C extends ComponentType<any>>({ Component, componentProps }: InjectProps<C>) {
  return <Component {...componentProps} />;
}

// 사용
function PrimaryButton(props: { onClick: () => void; children: React.ReactNode }) {
  return <button className="primary" {...props} />;
}

<Injector Component={PrimaryButton} componentProps={{ onClick: () => {}, children: '확인' }} />
```

4. children 타입은 ReactNode가 정석


``` tsx
type CardProps = React.PropsWithChildren<{
  title: string;
}>;

function Card({ title, children }: CardProps) {
  return (
    <section>
      <h2>{title}</h2>
      {children}
    </section>
  );
}
```

5. JSX 반환 타입 표기: JSX.Element (가장 흔함)


``` tsx
function Hello(): JSX.Element {
  return <div>Hello</div>;
}
```

6. 특정 엘리먼트 한 개를 인자로 받을 때: ReactElement


``` tsx
import { ReactElement } from 'react';

function OnlyOneChild({ child }: { child: ReactElement }) {
  // child는 반드시 하나의 유효한 React 엘리먼트
  return <div className="only-one">{child}</div>;
}
```

7. DOM/컴포넌트 Props 추론: ComponentProps/ComponentPropsWithoutRef/WithRef


``` tsx
type AnchorProps = React.ComponentProps<'a'>; // HTMLAnchorElement에 해당하는 props
type ButtonPropsNoRef = React.ComponentPropsWithoutRef<'button'>;

function LinkLike(props: AnchorProps) { /* ... */ return <a {...props} /> }
```

8. ref 타입 안전하게: forwardRef + ComponentRef


``` tsx
import React, { forwardRef } from 'react';

type InputProps = React.ComponentPropsWithoutRef<'input'>;

const TextInput = forwardRef<HTMLInputElement, InputProps>(function TextInput(props, ref) {
  return <input ref={ref} {...props} />;
});

// 사용
const ref = React.createRef<React.ComponentRef<typeof TextInput>>(); // HTMLInputElement
<TextInput ref={ref} />
```

9. memo / lazy의 타입


``` tsx
const Memoized = React.memo(MyComponent); // MemoExoticComponent<typeof MyComponent>
const LazyComp = React.lazy(() => import('./MyComponent')); // LazyExoticComponent<...>
```

10. Portal 타입


``` tsx
import { createPortal } from 'react-dom';
import type { ReactPortal } from 'react';

function renderToBody(node: React.ReactNode): ReactPortal {
  return createPortal(node, document.body);
}
```

언제 어떤 타입을 쓰나 요약

- 컴포넌트 그 자체를 다룰 때: ComponentType<P> (HOC, 컴포넌트 주입)
- 태그/컴포넌트를 모두 유연하게 받을 때: ElementType
- JSX 반환 타입을 지정할 때: JSX.Element
- children처럼 “렌더링 가능한 모든 것”을 받을 때: ReactNode
- “엘리먼트 한 개”만 받을 때: ReactElement
- DOM/컴포넌트의 Props를 재사용하고 싶을 때: ComponentProps/ComponentPropsWithoutRef/WithRef
- ref를 안전하게 전달/타이핑할 때: forwardRef + ComponentRef/PropsWithRef
- 성능 최적화/코드 스플리팅 결과 타입: MemoExoticComponent, LazyExoticComponent

자주 하는 오해/주의

- FC<Props>는 기본적으로 children을 포함시켜 주지만, 최근에는 명시적으로 PropsWithChildren를 쓰는 것이 의도가 더 명확합니다. 또한 FC는 defaultProps 관련 제약 등으로 선호도가 낮아졌습니다.
- ComponentType vs ElementType를 혼동하지 않기: 태그 문자열을 받으려면 ElementType을 사용하세요.
- children 타입을 ReactElement로 좁혀버리면 string/number/Fragment 등 유효한 JSX가 막힙니다. 일반적으로 ReactNode가 정답입니다.
- 반환 타입은 대부분 JSX.Element로 충분합니다. ReactElement를 반환 타입으로 강제할 필요는 거의 없습니다.