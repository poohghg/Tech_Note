```
import { useEffect, useRef } from 'react';

// 타입스크립트의 내장 EventTarget 타입 활용
type EventTargetLike = EventTarget | Window | Document;

// 대상 타입에 따른 이벤트 맵 가져오기 (HTMLElement, Window, Document 등)
type TargetEventMap<T extends EventTargetLike> =
    T extends Window ? WindowEventMap :
    T extends Document ? DocumentEventMap :
    T extends HTMLElement ? HTMLElementEventMap :
    // 다른 특정 요소 타입 (예: SVGElement)이 필요하면 여기에 추가
    Record<string, Event>; // 일반 EventTarget을 위한 기본값

// --- Hook 오버로딩 정의 ---

// 1. 대상이 지정되지 않은 경우 (기본값: window)
function useAddEventListener<K extends keyof WindowEventMap>(
    eventName: K,
    handler: (event: WindowEventMap[K]) => void,
    options?: boolean | AddEventListenerOptions
): void;

// 2. 대상이 지정된 경우 (Element 또는 Ref)
function useAddEventListener<
    K extends keyof TargetEventMap<T>, // 이벤트 이름 (대상 타입 T에 유효해야 함)
    T extends EventTargetLike = Window // 대상 요소의 타입 (기본값 Window)
>(
    element: T | React.RefObject<T> | null | undefined, // 대상 요소 또는 Ref
    eventName: K,
    handler: (event: TargetEventMap<T>[K]) => void, // 타입 추론된 핸들러
    options?: boolean | AddEventListenerOptions
): void;

// --- Hook 구현 ---
function useAddEventListener<
    K extends keyof TargetEventMap<T>,
    T extends EventTargetLike = Window
>(
    // 오버로딩된 파라미터들
    targetOrEventName: T | React.RefObject<T> | null | undefined | K,
    eventNameOrHandler: K | ((event: TargetEventMap<T>[K]) => void),
    handlerOrOptions?: ((event: TargetEventMap<T>[K]) => void) | boolean | AddEventListenerOptions,
    options?: boolean | AddEventListenerOptions
): void {
    // 실제 파라미터 값들
    let target: T | React.RefObject<T> | null | undefined | Window = window; // 기본 대상은 window
    let eventName: K;
    let handler: (event: TargetEventMap<T>[K]) => void;
    let eventOptions: boolean | AddEventListenerOptions | undefined;

    // 전달된 인자를 기반으로 실제 값 할당 (오버로딩 시뮬레이션)
    if (typeof targetOrEventName === 'string') {
        // 오버로드 1: useAddEventListener(eventName, handler, options?)
        eventName = targetOrEventName as K;
        handler = eventNameOrHandler as (event: TargetEventMap<T>[K]) => void;
        eventOptions = handlerOrOptions as boolean | AddEventListenerOptions | undefined;
        // target은 기본값인 window 유지
    } else {
        // 오버로드 2: useAddEventListener(element, eventName, handler, options?)
        target = targetOrEventName as T | React.RefObject<T> | null | undefined;
        eventName = eventNameOrHandler as K;
        handler = handlerOrOptions as (event: TargetEventMap<T>[K]) => void;
        eventOptions = options;
    }

    // 핸들러 함수를 ref에 저장하여 최신 상태 유지 (의존성 배열 문제 방지)
    const savedHandler = useRef(handler);

    // 핸들러 prop이 변경될 때마다 ref 업데이트
    useEffect(() => {
        savedHandler.current = handler;
    }, [handler]);

    useEffect(() => {
        // ref 객체이거나 실제 요소인지 확인하여 실제 DOM 요소 가져오기
        const targetElement = target && 'current' in target ? target.current : target;

        // 대상 요소가 유효하고 addEventListener 메서드를 가지고 있는지 확인
        if (!targetElement || !targetElement.addEventListener) {
            // 대상이 없거나 유효하지 않으면 아무 작업도 하지 않음
            // 개발 중 경고를 표시할 수도 있음
            // console.warn(`useAddEventListener: Target element not found or invalid for event "${eventName}".`);
            return;
        }

        // ref에 저장된 최신 핸들러를 호출하는 이벤트 리스너 함수
        const listener = (event: Event) => {
            // 타입스크립트 제네릭을 통해 event 타입이 추론되지만,
            // Event 리스너의 기본 타입은 Event이므로 실제 핸들러 호출 시 타입 단언 사용
            savedHandler.current(event as TargetEventMap<T>[K]);
        };

        // 이벤트 리스너 추가
        // addEventListener의 eventName은 string 타입이므로 타입 단언 사용
        targetElement.addEventListener(eventName as string, listener, eventOptions);

        // 클린업 함수: 컴포넌트 언마운트 또는 의존성 변경 시 리스너 제거
        return () => {
            targetElement.removeEventListener(eventName as string, listener, eventOptions);
        };
    }, [eventName, target, eventOptions]); // eventName, target, options가 변경될 때마다 effect 재실행
}

// 훅 함수 자체를 export 해야 합니다.
// export default useAddEventListener(); // <--- 잘못된 사용! 훅을 호출한 결과를 export하는 것
export default useAddEventListener; // <--- 올바른 사용! 훅 함수 자체를 export
```


1. 게임이 종료되면 다음의 정보가 결과창에 표시됩니다.
    - 이번 게임의 플레이 시간 1
    - 현재까지 Wordle을 승리한 횟수 1
    - 현재까지의 Wordle 승률 1
    - 현재까지의 모든 Wordle에서 추측을 시도한 횟수의 분포도 1