## 캡슐화(Encapsulation)란?

서로 연관 있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는것을 말한다.
즉 외부로부터 모듈,클래스에 정의된 속성과 기능들을 보호하고, ==필요한 부분만 노출==될 수 있도록 하여 각 객체의 고유의 독립성과 책임영역을 안전하게 지키고자 하는 목적이 있다.

![Pasted image 20241012132749.png](../img/Pasted%20image%2020241012132749.png)

- 서로 관련 있는 데이터와 이를 처리 할 수 있는 기능들을 한곳에 모아 관리하는 것
- 내부 구현 사항을 숨기고 외부에서 필요한 사항 들만 공개
	- 모듈 ,클래스,함수단위 와 같은 형태로 캡슐화가 가능하다.
	- 데이터를 사용하는 기능과 목적에 맞게 캡슐화 한다.
	- 데이터를 변경하고, 사용하는 코드를 감시할 수 있는 유일한 통로를 만드는것

### 목적

- **데이터 보호(data protection)** – 외부로부터 클래스에 정의된 속성과 기능들을 보호
- **데이터 은닉(data hiding)** – 내부의 동작을 감추고 외부에는 필요한 부분만 노출

### 원칙

- 함수 - 함수 하나당, 한가지의 일을 수행하두록 설계
- 모듈/클래스 - 한가지의 책임(하나의 도메인)을 가지도록 설계
#### 불변성(Immutable)이란?

> 한 번 생성된 데이터(값)는 변경되지 않는다는 것을 의미한다. 즉 불변성은 데이터가 생성된 이후 변경할 수 없는 상태를 의미한다.
> 
> 즉, 어떤 값을 변경하려 할 때 기존값을 직접 변경하는 것이 아니라, 새로운 값을 복사해서 수정한 다음 새로운 값을 반환하는 방식을 의미한다.
 
보통 불변성의 의미는 **상태를 변경**하지 않는 것 이라는 간단한 정의로 설명 될 수도 있다.
- 함수 외부 변수의 값을 변경하면 안된다.
- 함수의 인자를 변경하면 안된다.
- 변할 수 없는 변경 될 수 없는 성질이다. 즉 상태를 변경하지 않는 것. 

불변성에서 말하는 상태의 변경이란 프로그램의 변수를 변경하거나 재할달 하지 않는 것 이상의 의미를 가진다.
정확히 말하면 **메모리에 저장된 값**을 변경하는 모든 행위를 의미하며, 여기에 변수의 재할당과 같은 행위도 포함되는 것이다.

#### 불변성을 지키는 이유

1. 예측  가능한 코드 작성
	- 값이 바뀌는 일이 없기 때문에, 디버깅이 쉽다.
	- 데이트 흐름 추적이 용이하다.
2.  참조  변경 감지가 쉬움
	- 객체의 참조가 변경되면, 이전 객체와 새로운 객체를 쉽게 비교할 수 있다.

#### 메모리 구조

- 스택 메모리: 정적 메모리 할당. 원시 타입 값, 변수, 함수의 실행 정보등이 저장된다. 데이터 크기가 고정되어 있고, 빠르고 효율적으로 접근할 수 있다.
	- 스택 메모리는 함수의 호출과 반환에 따라 자동으로 할당되고 해제된다.
	- 스택 메모리는 LIFO(Last In First Out) 구조로 동작한다.
	- 스택 메모리는 함수의 지역 변수와 매개변수, 리턴 주소 등을 저장하는 데 사용된다.
	- 
- 힙 메모리: 동적 메모리 할당. 참조 타입 값(배열,객체)이 저장된다. 데이터 크기가 정해져 있지 않고, 프로그램 실행 중에 크기가 변할 수 있다. 스택 보다 접근 속도가 느리다.


#### 원시 타입과 참조 타입

원시 타입과 참조 타입은 메모리 참조방식이 다르다. 원시 타입이 메모리에 할당될 때는 값 자체를 저장하고 참조 타입이 메모리에 할당될 때는 **힙 메모리에 영역에 저장된 값을 가르키는 메모리 주소**를 저장한다. 

##### 값의 의한 호출 방식(원시 타입)

값의 의한 호출 방식은 함수의 인자로 어떤 변수를 넘길때 해당 변수가 가지고 있는 값을 그대로 복사하여 함수에게 넘겨주는 방식을 의미한다. 함수에 넘기는 변수가 가리키는 값을 넘기는 것이 아니라 그 값을 복사하여 새로운 메모리 공간에 저장하고 넘겨준다는 것을 의미한다.
즉 **값의 의한 호출 방식은 메모리에 이미 담겨있는 값을 변경하지 않아 불변성**을 지킨다.

- 변수의 값을 변경하면 기존 메모리 영역에 값이 변경되는 것이 아니라 새로운 메모리에 할당하여 그 주소를 바라보게 변경한다.

![Pasted image 20250402171941.png](../img/Pasted%20image%2020250402171941.png)

![Pasted image 20241028163849.png](../img/Pasted%20image%2020241028163849.png)

##### 참조에 의한 호출(레퍼런스 타입)

![Pasted image 20250402171914.png](../img/Pasted%20image%2020250402171914.png)

참조의 의한 호출은 레퍼런스 타입인 객체타입을 함수의 인자로 전달할때 발생한다. 해당 호출 방식은 변수가 가르키고 있는 메모리 공간의 주소를 넘기는 방식이다. 이때 만약 함수가 해당 변수를 변경한다면 원본 변수에 저장된 데이터도 변화하게 된다.(메모리 공간에 접근할 수 있는 변수명만 다를뿐, 실제로는 같은 메모리 공간에 저장되어 있다.)

즉 참조에 의한 호출의 경우 별다른 처리가 없다면 불변성이 깨질 수 있다.

![Pasted image 20241028164635.png](../img/Pasted%20image%2020241028164635.png)


> 이런 원리는 웹 프론트엔드의 UI 라이브러리인 `리액트(React)`에서 상태의 변화를 감지하는 데에도 사용되고 있는데, 리액트는 개발자가 `setState`와 같은 메소드를 사용하여 상태를 변경했을 때 `Object.is` 메소드를 사용하여 이전 상태와 다음 상태를 비교하고 두 객체가 같지 않다고 평가되면 상태가 변이되었다고 판단하고 컴포넌트를 다시 렌더한다.
> 
> 출처 
>  https://evan-moon.github.io/2020/01/05/what-is-immutable/


#### 1. 레코드 캡슐화하기
- 레코드란 key-value로 이루어진 자료형이다.
- 레코드를 클래스로 변경하기
- 레코드를 캡슐화하는 목적은 변수 자체는 물론 그 내용을 조작하는 방식도 통제하기 위해서다.
#### 2. 컬렉션 캡슐화하기
- 컬렉션이란 배열
- 가변 데이터를 캡슐화하면 데이터 구조가 언제 어떻게 수정되는지 파악이 쉬워진다.
	- 필요한 시점에 데이터 구조를 변경하기 쉬워진다.
- 불필요한 복제본을 만드는게, 예상치 못한 수정을 발생시키는것보다 낫다.
	- 컬렉션 관리를 하는 클래스라면 항상 복제본을 제공하여 캡슐호된 데이터의 변경을 막는게 좋다.
#### 3. 기본형을 객체로 바꾸기
- 기본형을 객체로 변경해서 기본형과 관련된 특정한 함수를 외부에서 활용 할 수 있도록 캡슐화 하는것이다.
#### 4. 임시 변수를 질의 함수로 바꾸기
- 코드의 결괏값을 참조할 목적으로 임수 변수를 사용한다.
	- 값을 계산하는 코드가 반복하는 걸 줄일 수 있다.
	- 값의 의미를 설명할 수 있다.
	- 임시 변수가 중복으로 사용된다면 재사용성을 고려해 아예 함수로 추출하는게 좋다.
- 특정한 함수,코드 블럭에서 사용하고 있는 임시 변수를 질의 함수로 변경함 으로써 외부 접근이 가능해짐으로 재사용성이 좋아진다.
- 질의 함수로 변경하면 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있어 코드 중복이 줄어든다.
#### 5.클래스 추출하기
- 클래스는 명확하게 추상화하고 소수의 주어진 역할만 처리하는게 좋다.
- 클래스가 하나의 도메인,책임을 가지는게 아니라면 또 다른 클래스로 추출하는게 좋다.
	- 메서드와 데이터가 너무 많은 클래스는 이해하기 쉽지 않다. ->  적절한 분리가 필요하다.
- 절차
	- 클래스의 역할을 분리할 방법을 정한다.
	- 분리될 역할을 담당할 클래스를 새로 만든다.
	- 원래 클래스의 생성자에서 새로운 클래스의 인스턴스를 생성하여 필드에 저장한다.
	- 분리된 역할에 필요한 필드들을 새 클래스로 옮긴다.
	- 양쪽 클래스의 인터페이스를 살펴보면서 불피요한 메서드를 제거하고, 이름도 새로운 환경에 맞게 변경한다.
#### 6.클래스 인라인하기
- 같은 도메인 로직을 지나치게 세분화 하면 코드 관리가 더 복잡해지고,어려워진다. 같은 도메인,역할을 한다면 로직을 통합 하는게 더 좋다. 
- 즉 같은 도메인 코드는 응집도를 높히는게 좋다.
#### 7.위임 숨기기
- 모듈화 설계의 핵심은 캡슐화 이다 .캡슐화는 모듈들이 시스템의 다른 부분에 대해 알아야 할 내용을 줄여준다.
	- 캡슐화가 잘 되어 있다면 무언가를 변경해야 할 때 고려해야 할 모듈 수가 적어저서 코드를 변경하기가 쉬워진다.
- 내부 로직을 지나치게 외부에 노출하는것은 좋지않다.
#### 8.중개자 제거하기
- 클라이언트가 위임 객체의 새로운 기능을 사용하고 싶을 때마다 서버에 위임 메서드를 추가해야한다.
	- 단순히 전달하만 하는 위임 메서드들이 많아진다.
- 위임,중개자는 비슷한 의미를 가진다 = 컴포지션
- 컴포지션은 클래스 A에서 클래스 B를 위임하여 확장 할 수 있다.
- 클래스 인라인하기 와 비슷한 맥락이다. A,B라는 클래스를 분기 했을때 B라는 클래스에서 별다른 도메익 로직 처리가 없다면 클래스 A의 상태로 합칠 수 있다.
#### 9.알고리즘 교체하기

-  더 좋은 알고리즘으로 교체 가능하다.




