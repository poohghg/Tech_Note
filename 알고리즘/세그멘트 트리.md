> 세그멘트 트리는 구간에 대한 정보를 효율적으로 관리하고 질의할 수 있는 자료구조이다. 주로 배열의 구간 합, 구간 최소값/최대값 등을 빠르게 계산하는 데 사용됩니다. 세그멘트 트리는 이진 트리 형태로 구성되며, 각 노드는 배열의 특정 구간에 대한 정보를 저장한다.  
> 
> 세그멘트 트리는 “변하는 배열”에서 “구간 정보를 빠르게 유지”하기 위한 필수 자료구조다.


- 구간 합: arr[l..r]의 합을 빠르게 계산할 수 있습니다.
- 구간 최소값/최대값: arr[l..r]에서 최소값 또는 최대값을 빠르게 찾을 수 있습니다.
- 구간 갱신: 배열의 특정 구간에 대한 값을 빠르게 갱신할 수 있습니다.

### 핵심 아이디어

> 배열의 구간 단위로 분할해서 각 구간의 결과를 트리 형태로 저장한다.

```
배열: [1, 3, 5, 7, 9, 11]

                    [0..5]
                 sum = 36
               /             \
         [0..2]               [3..5]
        sum=9                  sum=27
      /        \            /         \
  [0..1]      [2..2]    [3..4]       [5..5]
   4             5        16            11

```

### 왜 필요한가? (Prefix Sum과 비교)

####  누적합(Prefix Sum)의 한계

| 연산           | 시간     |
| ------------ | ------ |
| 구간 합 쿼리      | O(1)   |
| 값 변경(update) | O(N) ❌ |

`arr[3] = 10; // 이러면 prefix 배열 다시 계산해야 함`

#### 세그멘트 트리

| 연산    | 시간           |
| ----- | ------------ |
| 구간 쿼리 | **O(log N)** |
| 값 변경  | **O(log N)** |

### 대표 패턴

| 문제 유형                       | 이유       |
| --------------------------- | -------- |
| Range Sum Query + Update    | 누적합 불가   |
| Range Min / Max Query       | 빠른 구간 계산 |
| Binary Search + Range Check | 체크 비용 감소 |
| Sweep Line + 구간 관리          | 실시간 갱신   |
### 세그멘트 트리 구성 요소

1. **node**: 특정 구간 `[l, r]`의 정보저장
2. **merge 함수**: 왼쪽 + 오른쪽 합치기
3. **query 함수**: 구간 합 계산
4. **update 함수**
    
> 중요한 포인트:  
>  **merge 연산은 결합법칙이 성립해야 함**
> 
> (sum, min, max, gcd, xor 가능 / 평균 ❌)


``` ts
export class SegmentTree {  
  private readonly size: number;  
  private readonly tree: number[];  
  
  constructor(arr: number[]) {  
    this.size = arr.length;  
    this.tree = new Array(this.size * 4).fill(0);  
    this.build(arr, 1, 0, this.size - 1);  
  }  
  
  query(l: number, r: number) {  
    retrun this._query(1, 0, this.size - 1, l, r);  
  }  
  
  update(index: number, value: number) {}  
  
  private build(arr: number[], node: number, start: number, end: number) {  
    if (start === end) {  
      this.tree[node] = arr[start];  
      return;  
    }  
    const mid = Math.floor((start + end) / 2);  
    const left = node * 2;  
    const right = node * 2 + 1;  
  
    this.build(arr, left, start, mid);  
    this.build(arr, right, mid + 1, end);  
    this.tree[node] = this.tree[left] + this.tree[right];  
  }  
  
  private _query(  
    node: number, // [start,end] 구간의 합  
    s: number, // 현재 노드 구간  
    e: number, // 현재 노드 구간  
    l: number, // 쿼리 범위 l    r: number, // 쿼리 범위 r  ): number {  
    if (r < s || e < l) {  
      return 0;  
    }  
    if (l <= s && e <= r) {  
      return this.tree[node];  
    }  
    const mid = Math.floor((s + e) / 2);  
    const left = node * 2;  
    const right = node * 2 + 1;  
  
    return (  
      this._query(left, s, mid, l, r) + this._query(right, mid + 1, e, l, r)  
    );  
  }  
  
  private _update(  
    node: number,  
    start: number,  
    end: number,  
    index: number,  
    value: number,  
  ) {  
    if (start === end) {  
      this.tree[node] = value;  
      return;  
    }  
    const mid = Math.floor((start + end) / 2);  
    const left = node * 2;  
    const right = node * 2 + 1;  
  
    if (index <= mid) {  
      this._update(left, start, mid, index, value);  
    } else {  
      this._update(right, mid + 1, end, index, value);  
    }  
    // 해당 구간을 업데이트한다.  
    this.tree[node] = this.tree[left] + this.tree[right];  
  }  
}
```