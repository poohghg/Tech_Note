- 통상적으로 메모리를 더 사용하여 시간 복잡도를 개선할때 많이 사용된다.
- 구체적으로, 시간 복잡도가 비효율적인 알고리즘이 있을 때 부분 문제의 반복이 발생하는 경우 적용하면 효과적이다.
- 다이나믹 프로그래밍 문제를 해결하기 위해 점화식을 찾는 것이 핵심적인 과정이다.

### DP의 사용 조건

- DP는 일반적으로 아래의 두 조건을 만족할때 사용한다.
	1. 최적 부분 구조(Optimal substructure): 큰 문제를 유사한 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제를 해결한다.
		- 큰 문제는 동일한 구조의 작은 문제의 조합으로 해결 가능하다.
	2. 반복(중복)되는 부분 문제(Ovelapping subproblem): 동일한 작은 문제를 반복적으로 해결해야 한다.
		- 이미 해결한 문제를 또 해결해야 한다.
		- 이때, 메모이제이션(캐싱)을 사용하여 중복 계산을 줄인다.
### 점화식

- 피보나치 수열: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...]
- 점화식: 인접한 항으로 현재 값을 결정하는 관계식을 의미한다.
	- 일반적으로 최적 부분 구조를 만족한다는 특징이 있다.
- 피보나치 수열의 점화식:  F(N) = F(N-1) + F(N-2), 단 F(1) = 1, F(2) = 1

#### 구성 요소

1. 초기항
	- 점화식의 시작점이다.
	- 피보나치 수열의 경우 F(1) = 1, F(2) = 1로 초기항이 정해져 있다.
2. 인접한 항과의 관계
	- 점화식은 재귀 함수로 표현할 수 있다.
		- 점화식을 초기항은 종료 조건과 같은 역할을 수행한다.
		- 점화식의 내용은 f(x)의 반환 값에 들어간다.
	- 재귀 함수는 종료 조건이 있어야 하는데, 이것이 점화식의 초기항과 같은 역할을 수행한다.

```ts

const fibo = (n: number): number => {
  if (n <= 2) return 1;
  return fibo(n - 1) + fibo(n - 2);
};

```

![[Pasted image 20250328184023.png]]

- 피보나치 수열의 점화식을 재귀 함수로 구현하면 중복되는 부분 문제가 발생한다.
- DP는 이문제를 중복되는 부분 문제를 해결하는데 사용된다.
	- 메모이제이션을 사용하여 중복되는 부분 문제를 해결한다.
	- 메모이제이션: 한번 계산한 결과를 메모리에 저장하여 중복 계산을 줄인다.
	- 탑다운 방식: 작은 문제를 모아서 큰 문제를 해결한다.
		- 일반적으로 재귀 함수를 이용하여 구현한다.
- 일반적인 코드의 형태는 다음과 같다

```ts

const dp = () => {

 1. 종료 조건
 2. 이미 해결한 문제라면, 정답을 그대로 반환
 3. 점화식에 따라 정답 계산

}
```

### 문제 해결 과정

1. 문제 이해하기
2. 점화식 찾아내기 -> 일반적으로 가장 핵심적인 부분이다.
3. 구현 방식 결정하기
	- 탑다운 방식: 재귀 함수로 큰 항을 구하기 위해 작은 항을 호출하는 방식이다.
	- 바텀업 방식: 반복문을 이용해 초기항 부터 계산한다.
4. 점화식을 실제 코드로 구현하기

![[Pasted image 20250329181330.png]]

```ts

창고 방문하기문제
인접합 창고를 방문할 수 없다.
최소 한 칸 이상 떨어진 창고를 방문해야 한다.

const dp = (n:number) =>{
  const dp = Array.from({length:n},()=>0);
  
  dp[0] = arr[0];
  dp[1] = Math.max(arr[0],arr[1]);
  
  for(let i = 2; i < n; i++){
    dp[i] = Math.max(dp[i-1],dp[i-2]+arr[i]);
  }
  
  return dp[n-1];
}

```

- DP 문제를 해결할 때는 점화식을 세우는 것이 가장 중요하다.
- 이걸 위해서는 각 항을 어떻게 정의할 수 있는지가 중요하다.
- f(x) = x번째항 = x까지 보았을 때 최적의 해(문제에서 요구하는 바) 
- f(x)을 구하기 위해서 인접한 항들을 이용할 수 있는가?