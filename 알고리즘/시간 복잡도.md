시간 복잡도란 알고리즘의 성능을 타나내는 지표로, 입력 크기에 대한 연산 횟수의 상한을 의미한다. 시간 복잡도는 낮으면 낮을수록 좋다.
### 시간 복잡도

- 시간 복잡도는 알고리즘의 성능을 타나태는 척도이다.
- 시간 복잡도: ==특정한 크기의 입력에 대하여 알고리즘의 수행 시간==을 분석한다.
	- 입력의 크기가 커질수록 수행 시간이 어떻게 증가하는지를 나타낸다.
	- 수치적으로 얼마나 큰가?
- 동일한 기능을 수행하는 알고리즘이 있다면, 일반적으로 복잡도가 낮을수록 우수하다.
- 가장 빠르게 증가하는 항만을 고려하는 표기법이다.
- 함수의 상한을 타나낸다.
- 예를 들어 연산 횟수가 n + n²인 경우 O(n²)이라고 표기한다.
- n이 증가함에 따라서, n²를 제외한 다른 항의 영향력은 작아진다.
- Big-O 표기법에서는 차수가 가장 큰 항에서 계수를 제외하여 표기한다.

![Pasted image 20250331123611.png](../img/Pasted%20image%2020250331123611.png)

#### 일반적인 시간복잡도 별 `n`의 한계 (실행시간 1~2초 이내 기준)

| 시간복잡도        | 대략적인 한계 `n`      | 설명                    |
| ------------ | ---------------- | --------------------- |
| `O(1)`       | 제한 없음            | 상수 연산이므로 입력 크기에 영향 없음 |
| `O(log n)`   | 10⁸ ~ 10⁹ (약 십억) | 매우 빠름 (ex: 이진탐색)      |
| `O(n)`       | 10⁷ (약 첫만 )      | 단순 반복문                |
| `O(n log n)` | 약 10⁶ (약 백만 )    | 정렬, 우선순위 큐 등          |
| `O(n²)`      | 약 10⁴ (약 만개)     | 이중 반복문, 브루트포스         |
| `O(n³)`      | 약 500~1000       | 3중 루프                 |
| `O(2ⁿ)`      | 약 20~25          | 재귀 백트래킹               |
| `O(n!)`      | 약 10~11          | 순열 완전탐색               |
- o(n)은 약 10^7 은 최대 몇만 ? 
	- 10^7 = 1000 000
	- 약 천만
- o(log n)은 약 10^9 는 최대 몇억 ?
	  - 10^9 = 1,000,000,000
	  - 약 십억
  - 10 000 00 
	  - 약 10억
- o(n²)은 약 10^4 는 최대 몇천 ?
  - 10^4 = 10,000
  - 약 만

### 빅오(BIG 0)소개

#### 빅오란?

알고리즘의 성능을 분석하기 위해 빅오 표기법을 사용

- 여러가지 코드를 일반적으로 비교하여 성능평가 하는 방법이다.
- 숫자로 코드의 성능을 평가하는 척도이다.
- 빅오로 측정되는 알고리즘의 시간과 공간 복잡도는 하드웨어에 영향을 받지 않는다.
    - 실제 실행될 연산의 갯수를 따진다??

만약 시간을 척도로 코드의 성능을 비교하였을때 문제점?

- 여러 기계에서 상이한 결과값을 가진다.
- 같은 기계에서 상이한 결과값을 가진다.
- 속도 측정이 불가능한 경우가 있다.

시간척도가 불명확하기에, 단지 컴퓨터가 연산하는데 필요한 연산의 수를 계산하여 표기한다.
Big O :==입력된 내용이 늘어 날수록 알고리즘에 실행 시간이 어떻게 변하는지 설명하는 공식적인 방식==이다.
시간복잡도: 알고리즘의 수행시간을 평가한다.

- 입력의 크기와 실행시간의 관계를 말한다.
- 선형/제곱/상수/전체적으로 완전히 다른경우
- 일반적으로 가장높은 실행시간으로 측정한다.(최악의 실행시간이다)
- 앞의 상수를 버리고 전체적인 로직의 복잡도를 생각하다!! 이는 전체적인 추세를 설명하는 것이다.
    - 산수는 그냥 상수시간이다.
    - 변수에 할당하는 크기는 상관없다.
    - 배열에 인덱스를 접근하는것은 첫번째든 만번째든 상관없다.
    - 루프에서 n이 커질수록 실행시간이 커진다.
- O(1)상수시간 :n의 값이 커져도 실행시간은 변하지 않는다.
    - n의 크기와 상관없이 일정의 연산만 진해한다.
    - Ex) 일반적인 연산자.
``` js
function o1(n) {   // n의 크기와 상관업이 3번의 연산만 진행된다.   // -> 3   
	return (n * (n + 1)) / 2; 
}
```

- O(logN)로그시간: n의값이 커질수록 실행시간이 logN에 비례해서 증가한다.            
    - 일반적으로 무언가를 절반씩 줄여나가는 경우이다.
    - 이진트리에서 사용.
- n이 64일때 6번의 연산만 진행된다.
	- 2^6 = 64
```js
function logN(n) {   // i값이 반복할때마다 2배씩 증가한다.   // log8 = 3   
	let sum = 0;   
	for (let i = 0; i <= n; i * 2) {     
		const element = array[i];   
	} 
}
```   
- O(n)선형시간 :n이 커질수록 실행시간은 선형적으로 늘어난다.
    - Ex) 5n이든 2n이든 크게 차이는없다.

``` js
function on(n) {   // 실행시간은 n의 크기만큼 늘어난다.   // 2n + 1 -> 실제 2n이든 5n이든 전체적인 큰시간차이는 없다.   
	let answer = 0;   
	
	for (let i = 1; i <= n; i++) {     
		answer += i;   
	}   
	
	for (let i = 1; i <= n; i++) {     
		answer += i;   
	}   
	return answer; 
}
```


- O(n2)2차시간:n의 제곱만큼 실행시간이 늘어난다.
    
    - O(n)연사자안에 O(n)연산자가 있으면. 제곱
        
    - Ex) 중첩 for문
        
        
        `function on2(n) {   // 실행시간은 n의 제곱만큼 늘어난다.   // n이 커질수록 제곱만큼 실행시간이 늘어남   // 중첩 for문만큼 제곱이다.   for (let i = 1; i <= n; i++) {     for (let j = 1; j <= n; j++) {       console.log(i, j);     }   } }`
        
- O(2n)지수시간:n의값이 커질수록 실행시간이 2n에 비래해서 증가한다.
    
    - 주로 피보나치 수열과같이 두번씩 재귀호출하는 경우이다.
        
        
        `function o2n(n) {   if (n <= 1) return n;   return o2n(n - 1) + o2n(n - 2); }`
        

![img](https://blog.kakaocdn.net/dn/bthyOS/btruqFF5KI4/nkQQeGMBwOXPSXPE225GRK/img.jpg)

그림 출처 ( [http://www.bigocheatsheet.com/](http://www.bigocheatsheet.com/) )

#### 공간복잡도

사실상 보조공간이다.

- 자바스크립트의 공간복잡도
    - 대부분의 불변타입의 뱐수는 상수공간이다.
    - 스트링의 경우 O(n)의 스페이스를 차지한다.
        - 이는 문자열 길이만큼 공간을 차지한다.
        - 문자열은 유사배열객체이기 때문이다.
        - [https://www.zerocho.com/category/JavaScript/post/5af6f9e707d77a001bb579d2](https://www.zerocho.com/category/JavaScript/post/5af6f9e707d77a001bb579d2) 참고
    - 레페런스 타입의 객체또한 O(n)의 스페이스를 차지한다
        - 일반적으로 길이 또는 속성의 수만큼 공간을 차지한다.