#### 정렬

정렬 알고리즘은 컬렉션의 항목을 재배열하는 과정을 의미한다.

- https://www.toptal.com/developers/sorting-algorithms
- 정렬은 프로그램에서 흔히 사용된다.
- 정렬을 수행할수 있는 다양한 알고리즘이 존재하고, 각각의 장단점이 있다.

자바스크립트에서 sort메서드의 로직 수행방식

- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort

``` ts
  arr.sort([compareFunction])
```

- `compareFunction`이 제공되지 않으면 요소를 문자열로 변환하고 유니 코드 코드 포인트 순서로 문자열을 비교하여 정렬됩니다. 
  - a,b를 인자로 받았을때
  - -(음수)를 반환하면 a,b
  - +(양수)를 반환하면 b,a 

#### 버블정렬

서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환한다.이름의 유래로는 정렬 과정에서 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어졌다고 한다.
- 단순이 인접한 두 원소를 확인하여, 정렬이 안 되어 있다면 위치를 서로 변경한다.
- 시간 복잡도가 O(n²)로 비효율적인 정렬 알고리즘이다.
- 각 단계에서 인접한 두 개의 원소를 비교하여, 필요시 위치를 변경한다.
- 한 번의 단계가 수행되면, 가장 큰 원소가 맨 뒤로 이동한다.

장점
- 구현이 매우 간단하고,소스코드가 직관적이다
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간이 필요하지 않는다.
- 인접정렬이다.

단점
- 시간복잡도가 좋지않다.모두 O(n²)으로, 굉장히 비효율적이다.
- 정렬 되어 있지 않은 원소가 정렬 됐을때의 자리로 가기 위해서, 교환 연산(swap)이 많이 일어나게 됩니다.

일반적으로
- 흔히 사용되지 않음 x, 성능도 별로임
- 한번에 하나씩 이동한다.
- 루프를 돌면서 각 항목을 다음 항목과 비교후 교환한다.
  - 시간복잡도는 O(n²)
  - 한 항목을 전체 항목과 비교하여 정렬한다.
  - ![img](https://cdn-images-1.medium.com/max/1600/1*ZQmdM7My9QIhvxj98hrweg.gif)

#### 선택정렬

버블정렬과 비슷하지만, 큰 값을 배열 끝에 위치시키는 대신 작은 값을 한 번에 하나씩(한 루프) 위치에 배열한다.최솟값을 찾아 마지막에 바꾸어 맨앞에 둔다.
- 선택정렬은 매 단계에서 가장 작은 원소를 선택해서 앞으로 보내는 정렬 방식이다.
	- 매 단계에서 가장 작은 것을 선택하는 데 약 N번의 연산이 필요하다(선형 탐색)
- 앞으로 보내진 원소는 더 이상 위치가 변경되지 않는다.
- 시간 복잡도 O(n²)로 비효율적인 정렬 알고리즘이다.

> Selection Sort와 Insertion Sort를 헷갈려하시는 분들이 종종 있는데, Selection Sort는 배열에서 **해당 자리를 선택하고 그 자리에 오는 값을 찾는 것**이라고 생각하시면 편합니다.

- 주어진 배열에서 최솟값을 찾는다.
- 첫 번째 부터 n까지 순회후 어떤 값이 들어갈지 선택하여 정렬한다.
- 한 루프가 끝날때 선택된 값의 자리가 확정된다.
- 시간복잡도는 O(n²)
- ![img](https://cdn-images-1.medium.com/max/1600/1*to7gYwi5_bkZhx-1kSB0Lg.gif)

#### 삽입정렬

한번에 하나의 값의 취해서 올바른 위치에 삽입하는 정렬이다. 현재위치보다 낮은 index값을 순회하며 값을 올바른 위치에 삽입한다.
- 각 숫자를 적절한 위치에 삽입한다.
- 각 단계에서 현재 원소가 삽입될 위치를 찾는다.
- 적절한 위치에 도달할 때가지 반복적으로 왼쪽으로 이동한다.
	- 왼쪽으로 이동하며 한칸씩 자리를 이동 시킨다.
	- 각 단계마다 왼쪽의 원소들을 정렬이 되어있다고 가정한다.
- 선택한 값을 앞의 값들과 비교하여 순서를 하나씩 밀어내며 자리를 찾는다.
- 시간복잡도는 O(n²)
- ![img](https://cdn-images-1.medium.com/max/1600/1*IK3Q4NBRLthllMINV3OxpQ.gif)

#### 합병정렬

분할 반복 기법을 사용하는 알고리즘이다. 정렬 할 배열을 게속 반으로 나누어 정렬 한 후 합치는 방법이다.
큰 배열을 나누고, 더 작은 하위 배열로 정렬한다.요소를 쪼갠 후, 다시 합병시키면서 정렬해나가는 방식으로, 쪼개는 방식은 퀵정렬과 유사하다.

> 퀵정렬 : 우선 피벗을 통해 정렬(partition) → 영역을 쪼갬(quickSort)
> 합병 정렬 : 영역을 쪼갤 수 있을 만큼 쪼갬(mergeSort) → 정렬(merge)

- 시간복잡도는 O(nlog n)
	- 배열을 로그만큼 나눈후 log n번 합병한다.
- 가장 많이 쓰이는 정렬 알고리즘이다.
	- 일반적으로 빠르다.
- 정렬된 배열이 0개나 1개 요소가 있는 배열이 될 때 까지 분할한다.
- 분할을 현재 배열의 길이의 반으로 재귀적 호출로 나누어 합병한다.
- ![img](https://cdn-images-1.medium.com/max/1600/1*Uvs7CK1oew0pVckcuxr_qA.gif)

##### 분할정복
1. 분할 : 큰 문제를 작은 부분 문제로 분할한다.
	1. 정렬한 배열을 같은 크기의 부분 배열 2개로 분할한다.
2. 정복: 작은 부분 문제를 각각 해결한다.
	1. 부분 배열을 정렬한다. -> 정렬된 하나의 배열을 만든다.
	2. 각 부분 배열은 이미 정렬된 상태로 본다
	3. 총 원소가 N개 일때 O(n)의 시간복잡도가 요구된다. 
3. 조합: 해결한 부분 문제의 답을 이용하여 다시 큰 문제를 해결한다.
	1. 정렬된 부분 배열을 하나의 배열로 다시 병합한다.

![Pasted image 20241127164933.png](../img/Pasted%20image%2020241127164933.png)

- 일반적으로 재귀 함수를 이용하여 구현
- 큰 문제를 작은 문제로 분할하는 방식이 동일한 경우가 많기 때문이다.
- 더 이상 쪼갤 수 없는 크기가 될 때까지 게속하여 분할한다.

단점
- 일반적으로 재귀 함수를 사용한다는 점에서 함수 호출 횟수가 많이 발생한다.
- 이는 오버헤드로 이어진다.
#### 퀵정렬

합병정렬과 비슷하다. 재귀를 통해 배열의 길이가 1보다 작을때 반환한다.

임의의 기준(피봇포인트)을 세워 정렬한다.

피봇을 설정하여 피봇 기준 좌측과 우측으로 피봇보다 작은값은 왼쪽으로 큰값은 오른쪽으로 재배치를 하고 게속하여 분할하여 정렬하는 알고리즘.]

- 만약 어는정도 정렬이 되어있다면 피봇을 랜덤이나 중간값을 선태하여 정렬할 피봇의 값을 설정해야한다.
- 시간복잡도는 O(nlog n)아자먼 최악의경우 시간복잡도는 O(n²)이다.

- ![img](https://cdn-images-1.medium.com/max/1600/1*wwCw5TzLd79k2WQ6YVsQVw.gif)


#### 기수정렬

비교 알고리즘이 아닌 정렬 알고리즘(숫자로 변환하여 진행 -> 진수에 따라 버킷의 크기를 구함)이다.
요소사이의 비교를 하지 않고, 대신 숫자 크기의 대한 정보를 자릿수로 인코딩하여 버켓에 저장하며,자릿수의 크기를 구하여 비교한다.
즉 비교연산을 하지 않으며 정렬 속도가 빠르지만,데이터 전체 크기에 기수 테이블의 크기만한 메모리가 필요하다.

- 원소 사이의 비교를 하지 않고, 각 원소의 자릿수를 기준으로 정렬한다.
- 숫자 크기에 대한 정보를 자릿수로 인코딩하여 버켓에 저장한다.
- 데이터를 특정 범위를 기준으로 여러 개의 버킷으로 나눈다.
- 각 버킷 내부의 데이터를 정렬한다.
- 정렬된 버킷을 합친다.
- 시간복잡도는 O(nk)이다
- k는 최대자릿수이다.


---
#### 참조

https://devbin.kr/2020/algorithm-sort-algorithm-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/#i-4

https://jinhyy.tistory.com/9