> 참조
> 
> 토스 Frontend Fundamentals 내용을 읽고 단순히 정리한 내용입니다.
> Frontend Fundamentals 레퍼런스는 프론트엔드 개발자가 좋은 코드를 생산하는 기준을 제시한다.
> https://frontend-fundamentals.com

> 좋은 프론트엔드 코드는 변경하기 쉬운 코드이다. 새로운 요구사항을 구현하고자 할때, 기존 코드를 수정하고 배포하기 수월한 코드가 좋은코드이다. 

> 프론트엔드 개발자는 현재 직면한 상황을 바탕으로, 깊이 있게 고민하면서, 장기적으로 코드가 수정하기 쉽게 하기 위해서 어떤 가치를 우선해야 하는지 고민해야 한다.
> - 실무에서 클린 코드의 의의는 유지보수 시간의 단축이다.
> - 유지보수 시간의 단축은 코드파악, 디버깅, 코드리뷰 등을 용이하게 한다.

##### 일반적으로 좋지 않은 코드

1. 흐름 파악이 어렵다
	- 코드가 어떤 동작을 하는지 이해하기 힘들다.
2. 도메인 맥략 표현이 안된다
	- 코드가 어떤 도메인에 속하는지 알 수 없다.
3. 동료에게 물어봐야 알 수 있는 코드
## 좋은 코드의 기준

### # 가독성

#가독성

 **가독성(Readability)**  은 코드가 읽기 쉬운 정도를 말한다. 코드가 변경하기 쉬우려면 먼저 코드가 어떤 동작을 하는지 이해할수 있어야 한다.
#### 맥락 줄이기

##### 1.같이 실행되지 않는 코드 분리하기

동시에 실행되지 않는 코드가 하나의 함수 또는 컴포넌트에 있으면, 동작을 한눈에 파악하기 힘들다. 구현 부분에 많은 많은 분기가 들어가면 어떤 역할을 하는지 이해하기 어려워진다.
- 컴포넌트가 여러가지 역할을 하면 동시에 실행되지 않는 코드가 교차되어 나타나서 코드를 이해할때 부담을 준다

##### 2.구현 상세 추상화하기

사람이 코드를 읽을 때 동시에 고려할 수 있는 총 맥락의 숫자는 제한되어있다. 내 코드를 읽는 사람들이 코드를 쉽게 읽을 수 있도록 하기 위해서 불필요한 맥락을 추상화할 수 있다.
- 코드가 한 번에 가지고 있는 맥락이 적어야 가독성이 좋다.
- 컴포넌트가 가지고 있는 맥락이 다양하면 컴포넌트의 역할을 파악하기 힘들다.

``` tsx
function LoginStartPage() {
  useCheckLogin({
    onChecked: (status) => {
      if (status === "LOGGED_IN") {
        location.href = "/home";
      }
    }
  });

  /* ... 로그인 관련 로직 ... */

  return <>{/* ... 로그인 관련 컴포넌트 ... */}</>;
}

```

- 위 코드는 로그인 되어있을시 홈으로 보내는 로직이다.
- `useCheckLogin`, `onChecked`, `status`, `"LOGGED_IN"`과 같은 변수나 값을 모두 읽어야 해당 코드의 역할을 알 수 있다.
- 이는 가독성 측면에서 좋지 않다. 위 코드를 추상화하여 코드를 읽는 사람이 한 번에 알아야 하는 맥락 생성 할 수 있다.

코드에서 구현 상세를 지나치게 드러내는 경우, 이 코드가 어떤 역할을 하는지 정확하게 파악하기 힘들다. 한번에 여러개의 맥락의 한 번에 고려해 가면서 읽는것보다, 보다 작은 단위로 추상화하는 것이 필요하다.

##### 3.로직 종류에 따라 합쳐진 함수 쪼개기

쿼리 파라미터, API 호출, 상태 같은 로직의 종류에 따라서 함수나 컴포넌트, Hook을 만드는 것을 지양하자.
한번에 다루는 맥락의 종류가 많아지면 이해하기 힘들고, 수정하기 어려운 코드가 된다.

#### 이름 붙이기

##### 1.복잡한 조건에 이름 붙이기

복잡한 조건식이 특별한 이름 없이 사용 되면, 조건이 뜻하는 바를 한눈에 파악하기 어렵다.

조건에 이름을 붙이는 것이 좋을때
- **복잡한 로직을 다룰 때**: 조건문이나 함수에서 복잡한 로직이 여러 줄에 걸처 처리되면, 이름을 붙여 함수의 역할을 명확히 드러내는 것이 좋다. 이렇게 하면 코드 가독성이 높아지고, 유지보수나 코드 리뷰가 더 쉬워진다.
- **재사용성이 필요할 때**: 동일한 로직이 여러 곳에서 반복적으로 사용할 가능성이 있으면, 변수나 함수를 선언해 재사용할 수 있다. 이를 통해 코드 중복을 줄이고 유지보수가 더 쉬워진다.
- **단위 테스트가 필요할때**: 함수를 분리하면 독립적으로 단위 테스트를 작성할 수 있다. 단위 테스트는 함수가 올바르게 동작하는지 쉽게 확인할 수 있다.
##### 2.매직 넘버에 이름 붙이기

**매직 넘버**(Magic Number)란 정확한 뜻을 밝히지 않고 소스 코드 안에 직접 숫자 값을 넣는 것을 말한다.

```tsx
async function onLikeClick() { 
	await postLike(url); 
	await delay(300); 
	await refetchPostLike(); 
}

// 맥락을 파악하기 위해 상수로 표현 할 수 있다.
const ANIMATION_DELAY_MS = 300;
```

> 이 코드는 `delay` 함수에 전달된 `300`이라고 하는 값이 어떤 맥락으로 쓰였는지 알 수 없다. 원래 코드를 작성한 개발자가 아니라면, 어떤 목적으로 300ms동안 기다리는지 알 수 없다.
> 
> 하나의 코드를 여러 명의 개발자가 함께 수정하다 보면 의도를 정확히 알 수 없어서 코드가 원하지 않는 방향으로 수정될 수도 있다.

##### 3. 시점 이동 줄이기

코드를 읽을 때 코드의 위 아래를 왔다 갔다 하면서 읽거나, 여러 파일이나 함수, 변수를 넘나 들면서 읽는 것을 시점이동이라고 한다. 시점이 여러 번 이동 할수록 코드를 파악하는데 시간이 더 걸리고, 맥락을 파악하는 데 어려움이 있을 수 있다.

코드를 위에서 아래로, 하나의 함수나 파일에서 읽을 수 있도록 코드를 작성하면, 읽는 사람이 동작을 빠르게 파악할 수 있다.
- 애매하다 공통으로 사용되는 경우 추상화가 좋은거 같다
- 해당 파일에서만 사용하면 해당파일에서 발견하기 쉽게 colocate하는게 좋은거 같다.

---
###  # 예측 가능성

#예측가능성

**에측 가능성(Predictability)** 은 함께 협업하는 동료들이 함수나 컴포넌트의 동작을 얼마나 예측할 수 있는지를 말한다. 예측 가능성이 높은 코드는 일관적인 규칙을 따르고, 함수나 컴포넌트의 이름과 파라미터, 반환 값만 보고도 어떤 동작을 하는지 알 수 있다.

#### 이름 겹치지 않게 관리하기

같은 이름을 가지는 함수나 변수는 동일한 동작을 한다. 작은 동작 차이가 코드의 예측 가능성을 낮추고, 코드를 읽는 사람에 혼란을 준다.

이름으로 인한 오해로 인해 기대 동작과 실제 동작의 차이가 생기고, 버그가 발생하거나, 디버깅 과정을 복잡하고 혼란스럽게 할 수 있다.

#### 같은 종류의 함수는 반환 타입 통일하기

API 호출과 관련된 Hook들처럼 같은 종류의 함수나 Hook이 서로 다른 반환 타입을 가지면 코드의 일관성이 떨어져서, 코드를 읽는데 헷갈리수 있다.

- 같은 종류의 동작을 하는 코드가 일관적인 규칙을 따르는게 좋다.
- 유효성 검사 함수의 반환 값이 다르다면, 함수를 쓸 때마다 반환 타입을 확인해야한다.
	- 통일된 포멧을 활용해서 반환하는게 예측 가능한 코드이다.

#### 숨은 로직 드러내기

함수나 컴포넌트의 이름, 파라미터, 반환 값에 드러나지 않는 숨은 로직이 있다면, 함께 협업하는 동료들이 동작을 예측하는 데 어려움을 겪을수 있다.

``` ts
async function fetchBalance(): Promise<number> {
  const balance = await http.get<number>("...");

  logging.log("balance_fetched");

  return balance;
}

```
- 위 함수의 이름, 파라미터, 반환 으로 내부에서 로깅을 하는지 확인 할 수 없다.
- 로깅 로직을 분리해서 함수가 하나의 역할만 할 수 있게 변경하는게 좋다.

---
### 응집도

#응집도 

![Pasted image 20250407012241.png](../img/Pasted%20image%2020250407012241.png)

![Pasted image 20250407012315.png](../img/Pasted%20image%2020250407012315.png)

- 뭉치면 쾌적한 코드 조각
	- 당장 몰라도 되는 디테일
	- 세부 구현 사항들
- 뭉치면 단단한 코드 조각
	- 코드 파악에 필수적인 핵심 정보
	- 핵심 데이터, 코드의 의도

**응집도(Cohesion)** 란, 수정되어야 할 코드가 항상 같이 수정 되는지를 말한다. 응집도가 높은 코드는 코드의 한 부분을 수정해도 의도치 않게 다른 부분에서 오류가 발생하지 않는다. 함께 수정되어야 할 부분이 반드시 함께 수정되도록 구조적으로 뒷받침되기 때문이다.

가독성과 응집도는 서로 상충할 수 있다.
일반적으로 응집도를 높이기 위해서는 변수나 함수를 추상화하는 등 가독성을 떨어뜨리는 결정을 한다. 함께 수정되지 않으면 오류가 발생할 수 있는 경우에는, 응집도를 우선해서 코드를 공통화, 추상화 하는게 좋다. 위험성이 높지 않은 경우에는, 가독성을 우선하여 코드 중복을 허용하는게 좋다.

#### 함께 수정되는 파일을 같은 디렉토리에 두기

프로젝트를 진행하다 보면 Hook, 컴포넌트, 유틸리티 함수 등을 여러 파일로 나눠 관리 하게된다. 이런 파일들을 쉽게 만들고, 찾고, 삭제할 수 있도록 올바른 디렉토리 구조를 갖는게 중요하다.

함께 수정되는 소스 파일을 하나의 디렉토리에 배치하면 코드의 의존 관계를 명확하게 드러낼 수 있다. 참조하면 안되는 파일을 함부로 참조하는 것을 막고, 연관된 파일들을 한번에 삭제 할 수 있다.
- 함께 수정되는 코드 파일을 하나의 디렉토리 아래에 둔다면, 코드 사이의 의존 관계를 파악하기 쉬워진다.


### 결합도

#결합도

**결합도(Coupling)** 란, 코드를 수정했을 때의 영향범위를 말한다. 코드를 수정했을때 영향범위가 적어서, 변경에 따른 예측할 수 있는 코드가 수정하기 쉬운 코드이다.
