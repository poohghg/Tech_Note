> 참조
> 
> 토스 Frontend Fundamentals 내용을 읽고 단순히 정리한 내용입니다.
> Frontend Fundamentals 레퍼런스는 프론트엔드 개발자가 좋은 코드를 생산하는 기준을 제시한다.
> https://frontend-fundamentals.com

  
프론트엔드 개발자는 현재 직면한 상황을 바탕으로, 깊이 있게 고민하면서, 장기적으로 코드가 수정하기 쉽게 하기 위해서 어떤 가치를 우선해야 하는지 고민해야 한다.
## 좋은 코드의 기준

### 가독성

#가독성

 **가독성(Readability)**  은 코드가 읽기 쉬운 정도를 말한다. 코드가 변경하기 쉬우려면 먼저 코드가 어떤 동작을 하는지 이해할수 있어야 한다.
#### 맥락 줄이기

##### 1.같이 실행되지 않는 코드 분리하기

동시에 실행되지 않는 코드가 하나의 함수 또는 컴포넌트에 있으면, 동작을 한눈에 파악하기 힘들다. 구현 부분에 많은 많은 분기가 들어가면 어떤 역할을 하는지 이해하기 어려워진다.
- 컴포넌트가 여러가지 역할을 하면 동시에 실행되지 않는 코드가 교차되어 나타나서 코드를 이해할때 부담을 준다

##### 2.구현 상세 추상화하기

사람이 코드를 읽을 때 동시에 고려할 수 있는 총 맥락의 숫자는 제한되어있다. 내 코드를 읽는 사람들이 코드를 쉽게 읽을 수 있도록 하기 위해서 불필요한 맥락을 추상화할 수 있다.
- 코드가 한 번에 가지고 있는 맥락이 적어야 가독성이 좋다.
- 컴포넌트가 가지고 있는 맥락이 다양하면 컴포넌트의 역할을 파악하기 힘들다.

``` tsx
function LoginStartPage() {
  useCheckLogin({
    onChecked: (status) => {
      if (status === "LOGGED_IN") {
        location.href = "/home";
      }
    }
  });

  /* ... 로그인 관련 로직 ... */

  return <>{/* ... 로그인 관련 컴포넌트 ... */}</>;
}

```

- 위 코드는 로그인 되어있을시 홈으로 보내는 로직이다.
- `useCheckLogin`, `onChecked`, `status`, `"LOGGED_IN"`과 같은 변수나 값을 모두 읽어야 해당 코드의 역할을 알 수 있다.
- 이는 가독성 측면에서 좋지 않다. 위 코드를 추상화하여 코드를 읽는 사람이 한 번에 알아야 하는 맥락 생성 할 수 있다.

코드에서 구현 상세를 지나치게 드러내는 경우, 이 코드가 어떤 역할을 하는지 정확하게 파악하기 힘들다. 한번에 여러개의 맥락의 한 번에 고려해 가면서 읽는것보다, 보다 작은 단위로 추상화하는 것이 필요하다.

##### 3.로직 종류에 따라 합쳐진 함수 쪼개기

쿼리 파라미터, API 호출, 상태 같은 로직의 종류에 따라서 함수나 컴포넌트, Hook을 만드는 것을 지양하자.
한번에 다루는 맥락의 종류가 많아지면 이해하기 힘들고, 수정하기 어려운 코드가 된다.

#### 이름 붙이기

##### 1.복잡한 조건에 이름 붙이기

복잡한 조건식이 특별한 이름 없이 사용 되면, 조건이 뜻하는 바를 한눈에 파악하기 어렵다.

조건에 이름을 붙이는 것이 좋을때
- **복잡한 로직을 다룰 때**: 조건문이나 함수에서 복잡한 로직이 여러 줄에 걸처 처리되면, 이름을 붙여 함수의 역할을 명확히 드러내는 것이 좋다. 이렇게 하면 코드 가독성이 높아지고, 유지보수나 코드 리뷰가 더 쉬워진다.
- **재사용성이 필요할 때**: 동일한 로직이 여러 곳에서 반복적으로 사용할 가능성이 있으면, 변수나 함수를 선언해 재사용할 수 있다. 이를 통해 코드 중복을 줄이고 유지보수가 더 쉬워진다.
- **단위 테스트가 필요할때**: 함수를 분리하면 독립적으로 단위 테스트를 작성할 수 있다. 단위 테스트는 함수가 올바르게 동작하는지 쉽게 확인할 수 있다.
##### 2.매직 넘버에 이름 붙이기

**매직 넘버**(Magic Number)란 정확한 뜻을 밝히지 않고 소스 코드 안에 직접 숫자 값을 넣는 것을 말한다.

```tsx
async function onLikeClick() { 
	await postLike(url); 
	await delay(300); 
	await refetchPostLike(); 
}

// 맥락을 파악하기 위해 상수로 표현 할 수 있다.
const ANIMATION_DELAY_MS = 300;
```

> 이 코드는 `delay` 함수에 전달된 `300`이라고 하는 값이 어떤 맥락으로 쓰였는지 알 수 없다. 원래 코드를 작성한 개발자가 아니라면, 어떤 목적으로 300ms동안 기다리는지 알 수 없다.
> 
> 하나의 코드를 여러 명의 개발자가 함께 수정하다 보면 의도를 정확히 알 수 없어서 코드가 원하지 않는 방향으로 수정될 수도 있다.

##### 3. 시점 이동 줄이기

코드를 읽을 때 코드의 위 아래를 왔다 갔다 하면서 읽거나, 여러 파일이나 함수, 변수를 넘나 들면서 읽는 것을 시점이동이라고 한다. 시점이 여러 번 이동 할수록 코드를 파악하는데 시간이 더 걸리고, 맥락을 파악하는 데 어려움이 있을 수 있다.

코드를 위에서 아래로, 하나의 함수나 파일에서 읽을 수 있도록 코드를 작성하면, 읽는 사람이 동작을 빠르게 파악할 수 있다.
- 애매하다 공통으로 사용되는 경우 추상화가 좋은거 같다
- 해당 파일에서만 사용하면 해당파일에서 발견하기 쉽게 colocate하는게 좋은거 같다.

### 예측 가능성

#예측가능성

**에측 가능성(Predictability)** 은 함께 협업하는 동료들이 함수나 컴포넌트의 동작을 얼마나 예측할 수 있는지를 말한다. 예측 가능성이 높은 코드는 일관적인 규칙을 따르고, 함수나 컴포넌트의 이름과 파라미터, 반환 값만 보고도 어떤 동작을 하는지 알 수 있다.

### 응집도

#응집도

**응집도(Cohesion)** 란, 수정되어야 할 코드가 항상 같이 수정 되는지를 말한다. 응집도가 높은 코드는 코드의 한 부분을 수정해도 의도치 않게 다른 부분에서 오류가 발생하지 않는다. 함께 수정되어야 할 부분이 반드시 함께 수정되도록 구조적으로 뒷받침되기 때문이다.

가독성과 응집도는 서로 상충할 수 있다.
일반적으로 응집도를 높이기 위해서는 변수나 함수를 추상화하는 등 가독성을 떨어뜨리는 결정을 한다. 함께 수정되지 않으면 오류가 발생할 수 있는 경우에는, 응집도를 우선해서 코드를 공통화, 추상화 하는게 좋다. 위험성이 높지 않은 경우에는, 가독성을 우선하여 코드 중복을 허용하는게 좋다.


### 결합도

#결합도

**결합도(Coupling)** 란, 코드를 수정했을 때의 영향범위를 말한다. 코드를 수정했을때 영향범위가 적어서, 변경에 따른 예측할 수 있는 코드가 수정하기 쉬운 코드이다.
