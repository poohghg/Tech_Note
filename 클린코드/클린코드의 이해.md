간결함과 명확함을 혼동 하면 안된다. 짧은 코드가 곧 가장 명확한 코드를 의미하는것이 아니며, 오히려 그 반대인 경우도 흔하다. 코드를 짧게 만드는것은 분명 좋은 목표이지만, 절대 가독성을 희생하지말고 명확성을 드러내야 한다.
### 클린 코드가 무엇인지 이해하기

- 클린 코드란?

  - **클린 코드는 읽는 사람이 이해하기 쉬우며, 유지보수와 확장이 용이한 코드**를 말해요. 이는 **변경에 쉽게 대응할 수 있는 코드**라고 볼 수 있어요.

  - 클린 코드를 작성하는 것은 **배우기 어렵고 고생을 해야해요.**

  - 나쁜 코드가 쌓일수록 팀의 생산성은 떨어지고 회사가 망할수도 있어요. 그래서 클린 코드를 작성할 수 있는 역량이 중요해요.

  - 르블랑의 법칙

    - **“나중은 결코 오지 않는다.”**

    - 우리는 때때로 “나중에 코드를 리팩토링 해야지, 나중에 테스트 코드를 작성해야지.”와 같은 다짐을 하지만 실제로는 기술 부채로 남는 경우가 많아요. 따라서 **애초에 좋은 코드를 작성하는 게 중요해요.**

    - 물론 실무에서는 비즈니스 요구사항을 만족하기 위해 어느 정도 코드 퀄리티를 포기해야 하는 상황이 있지만 **최소한의 기준**을 지키려고 해야해요.

      ```jsx
      // 금지
      const [a, setA] = useState();
      ```

- 클린 코드의 특징

  1. 작은 함수
     - 함수는 짧고, 하나의 역할만 수행해야해요.
     - Single Responsibility Principle(단일 책임 원칙, SRP)을 따라요.
     - 잠깐! SRP에 대한 오해 확인하기
       - SRP는 우리가 일반적으로 알고 있는 “함수는 하나의 일만 해야 한다.”라는 내용은 아니에요.
       - *“A module should be responsible to one actor.” - Clean Architecture*
       - 모듈은 단 하나의 액터에만 책임을 가져야 한다.
       - 예를 들어 하나의 클래스가 3가지의 메소드를 가지고 있다고 하더라도, 이 기능들이 함께 변경된다면 이를 3개의 클래스로 나누는 것이 아니라 하나의 클래스에 두는 것을 의미해요.
  2. 의미 있는 이름
     - 변수명, 함수명, 클래스명은 그 자체로 의도를 드러내야 해요.
     - **예:** `hasCreditCard`는 그 역할이 명확하지만, `hasCCard`는 의도를 드러내지 못해요.
     - 한글 변수?
       - 복잡한 도메인을 표현하기 위해서 **한글로 변수명**을 짓기도 해요.
       - https://tosspayments-dev.oopy.io/chapters/frontend/posts/hangul-coding-convention
  3. 중복 코드 없음
     - 코드에서 중복은 유지보수를 어렵게 하고, 클린 코드의 가장 큰 적으로 간주된다.
     - **DRY**(Don't Repeat Yourself) 원칙을 따른다.
  4. 불필요한 복잡성 제거
     - 지나치게 복잡한 알고리즘이나 설계는 피하고, 문제를 해결하는 가장 간단한 방식을 채택해야 한다.
     - “Simplicity is the ultimate sophistication.”(단순함은 궁극의 정교함이다)
     - 클린 코드는 짧은 코드가 아니다.
       - 코드가 길어지더라도 의도를 명확하게 드러내는 코드가 클린 코드라고 애기할 수 있어요.
       - 또한, 성능보다 가독성이 좋은 코드를 클린 코드에서는 추구하고 있어요.
       - https://www.youtube.com/watch?v=edWbHp_k_9Y&t=1106s
  5. 테스트 코드
     - 클린 코드는 테스트 하기 쉬우며 테스트 코드를 통해서 소프트웨어가 개발자의 의도대로 동작함을 보장할 수 있어요.
     - 테스트 코드는 마치 "스펙 문서"처럼 작동해야 해요.
  6. 일관성
     - 코드 스타일, 구조, 명명 규칙 등이 일관되게 유지되어야 해요.
     - 같은 프로젝트 내에서 다른 규칙이 혼재되면 코드를 이해하는 데 있어 비용이 커질 수 있어요.

### 설계와 추상화에 대해 이야기하기

- 먼저 설계란 무엇일까요?

  - 설계는 단순하게는 모듈, 컴포넌트와 같은 **코드를 어디에 위치 시킬지**에 대한 고민이라고 볼 수 있어요.
  - 설계는 변화를 잘 다루기 위한 좋은 구조를 만들어 나가는 과정이에요. 모든 상황에 적절한 아키텍처란 존재하지 않아요. 제품이 성장함에 따라서 소프트웨어의 아키텍처도 함께 성장해야 해요.

- 추상화란 무엇일까요?

  - 추상화란 공통되는 특성과 속성만 남기고 다른 것을 제거하는 과정이라고 볼 수 있어요.
  - 아래 그림은 황소의 특성을 추상화 하는 과정이에요. 추상화를 통해서 뿔, 다리, 꼬리, 몸통과 같은 형태만 남아있게 되어요.

  ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5820ed01-1671-4038-93a4-e5611130072b/2c394e02-a7f5-4681-b149-44aa58fb7660/image.png)

- 그러면 개발에 있어서 추상화는 왜 중요할까요?

  - 추상화를 통해서 **복잡한 개념을 단순하게 표현할 수 있기 때문이에요. → 선언적인 코드**
  - 예를 들면 **http 통신**에 대한 이야기를 해볼 수 있을 것 같아요. 우리가 프론트엔드 개발을 할 때 http 통신을 쉽게 할 수 있는 이유는 **fetch, axios, ky**와 같은 http 통신을 하기 위해 필요한 동작들을 잘 추상화 해놓은 모듈이 존재하기 때문이에요. 이와 같은 모듈을 이용해서 우리는 url, method, body, header등의 값만 정의하면 바로 http 통신을 할 수 있어요.
  - 그런데 이와 같은 모듈이 존재하지 않는다면 어떻게 될까요? 우리는 아래와 같은 동작을 처리해야 해요.
    - How에 해당하는 동작
      - 문자열 직렬화
      - HTTP 프로토콜의 복잡한 동작
      - TCP 연결
      - 네트워크 연결 여부 확인
      - 기타 등등
  - 이를 직접 처리해야 한다면 얼마나 많은 비용이 들까요? 우리는 추상화를 통해서 불필요한 동작에 대해 신경쓰지 않고 개발을 할 수 있으며 복잡한 개념을 단순하게 표현할 수 있어요.

### 변경에 유연한 코드 작성해보기

- 변경에 유연한 코드를 작성하려면 주어진 요구사항이 변경된다고 가정해보면 좋아요. 예를 들어서 가상의 로또 앱을 만든다고 생각해보면 좋을 것 같아요. 로또 앱에는 아래와 같은 요구사항이 있어요.

  - 로또 앱은 웹으로 서비스를 할 예정이다.
  - 로또 1장의 가격은 1,000원이다.
  - 로또 번호는 1부터 45까지의 숫자 중 6개의 번호를 선택한다.
  - 번호를 직접 선택할 수도 있고, 무작위로 번호를 선택할 수도 있다.
  - 로또의 상금은 1등 20억, 2등 15억, 3등 10억, 4등 5억, 5등 3억, 6등 1억이다.

- 요구 사항을 확인 했을 때 구현이 크게 어렵지는 않을 것 같아요. 그런데 여기서 요구 사항의 변경이 생긴다면 어떻게 될까요?

  - 로또 앱은 모바일 앱과 데스크톱 앱으로도 서비스를 출시 할 예정이다.
  - 로또 1장의 가격은 2,000원으로 변경되었고, 5장 이상 구매하면 10% 할인, 10장 이상 구매하면 20% 할인 정책을 시행한다.
  - 로또 번호는 10부터 90까지의 숫자 중 10개의 번호를 선택하는 것으로 변경되었다. 이에 따라 로또의 순위를 정하는 규칙도 변경된다.

- 이런 상황에서 기존의 앱이 어떻게 작성되어 있어야 우리는 요구사항에 빠르게 대응할 수 있을까요?

  - 계층간의 적절한 분리와 추상화

    - UI와 Business Logic의 분리는 가장 기본적으로 이루어져야 해요.

    - 상금 정책, 번호 선택 규칙, 당첨금 규칙 등의 책임을 담당하는 적절한 인터페이스를 구성해요.

    - 적절한 추상화 계층을 구성해요.

      - **클린 아키텍처**

        - App이나 Desktop에도 대응하기 위해서는 코드를 어떻게 작성해야 할까요?
        - 클린 아키텍처에서 UI와 같은 Presentation Layer는 가장 바깥쪽에 위치하고 있어요. 이는 Web, App, Desktop과 같이 어떻게 보여져야 할지를 결정하는 부분은 언제든지 갈아낄 수 있도록 구성해야 한다는 것을 의미해요. 실제로 **도메인 로직을 잘 발라냈다면** 도메인 로직 코드는 Web, App, Desktop 어디에 연동이 되더라도 변경이 될 필요가 없어요. 즉, 잘 작성된 코드는 사업의 확장에도 빠르게 대응할 수 있어요.

        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5820ed01-1671-4038-93a4-e5611130072b/ffdb0584-2f9e-4ca6-8242-b3a733f724e0/image.png)

  - 도메인 로직을 “잘” 관리하기

    - 명확하고 이해하기 쉽게 작성하기
    - 매직 넘버를 상수로 관리하기
    - 테스트 코드 작성하기

### 판단의 기준이 되는 코드 스멜 이해하기

- 코드 스멜이란 무엇일까요?
  - 코드 스멜이란 코드에서 겉으로 드러나는 문제점이나 잠재적인 결함을 의미해요. 코드에 문제가 있을 때 악취가 난다고 표현하기도 하는데 이는 버그는 아니지만 유지 보수하기 어렵거나 확장하기 어려운 코드인 경우가 많아요. 따라서 이런 경우에는 **리팩토링을 통해서 코드를 개선해야 하는 신호**로 여겨져요.
- 코드의 악취 판단하기
  - 코드의 악취를 판단하기 위해서 **가장 중요한 것은 경험이라고 생각해요**. 코드는 정량적으로 판단하기 보다는 정성적으로 판단하기 때문에 이전에 내가 개발해온 소프트웨어들을 통해서 코드를 판단하는 눈을 기르게 되는 편이에요.
  - 그러나 많은 책들에서 얘기하는 것처럼 많은 경험을 가진 개발자가 아닌 이상은 코드를 봤을 때 문제가 되는 부분을 찾기는 어려움이 있어요. 그래서 대표적인 예시들을 통해서 우리는 코드의 문제점을 한번 체크해볼 수 있어요.
    - 중복 코드
    - 너무 긴 메소드
    - 거대한 클래스
    - 만능 객체(God Object)
    - 사용하지 않는 코드
    - 산탄총 수술
      - 특정 기능을 수정해야 할 때 너무 여러 곳의 코드를 수정해야 한다.
  - 또한 도구를 이용해서도 코드의 악취를 판단하는 데 있어서 도움을 받을 수 있어요.
    - ChatGPT로 코드 리뷰
    - SonarQube
    - ESLint

### 그때는 맞고 지금은 틀리다

- 소프트웨어의 지속적인 성장
  - 소프트웨어는 비즈니스의 성장에 따라서 동일하게 성장하고 복잡해져요. 복잡도가 늘어나는 것에 따라서 소프트웨어의 아키텍처는 달라져야하고 변화가 필요해요. 그리고 우리가 알고 있는 대부분의 서비스들은 똑같이 이와 같은 과정을 거쳐오고 있어요.
  - 서비스를 이용하는 사용자의 수가 얼마 없고 기능이 단순할 때는 어떤 소프트웨어라도 잘 동작하지만 사용자가 많아지는 순간부터는 서버가 터지고 병목이 생기고 속도가 느려지고 하는 문제가 생기기 시작하고 사용자 데이터를 어떻게 쌓아갈지에 대한 고민을 하기 시작해야해요.
  - 현재 제품이 어떤 상황에 있냐에 따라서, 혹은 스타트업은 시리즈가 어떻게 되냐에 따라서 소프트웨어의 코드나 개발 팀의 규모가 달라져야 한다고 생각해주시면 될 것 같아요.
- 상황에 맞는 코드
  - 따라서 코드도 상황에 맞게 작성할 수 있어야 해요. 또한 항상 클린 코드를 작성해야 하는 것도 아니에요. 상황에 맞는 코드라는 것은 무슨 의미일까요? 여러가지 제품의 특성에 맞게 한번 알아보려고 해요.
  - 유지 보수가 필요 없는 제품
    - SI 제품이나 짧은 기간동안만 서비스를 할 제품이라고 하면 코드 퀄리티를 엄청 신경 쓸 필요가 없어요. 이런 제품이라면 굳이 리팩토링을 할 필요도 없다고 볼 수 있구요. 따라서 이 경우에는 코드 퀄리티에 많은 신경을 쓰기보다 **요구사항을 만족하는 제품을 빠른 시간안에 개발하는 게 중요하다고 볼 수 있어요.**
  - PMF(Product Market Fit)를 찾지 못한 제품
    - 이 경우에도 위 제품의 특성과 비슷하다고 생각해요. 아직 시장에서의 핏을 찾지 못한 제품의 경우에는 최대한 빠르게 시장에 출시하고 사용자들의 반응을 보는게 우선이에요. 아무리 코드를 잘 짠다고 해도 사용자의 선택을 받지 못하면 전혀 의미없는 제품이 되기 때문이에요. 이 경우에도 **빠른 실행과 실험이 중요할 것 같아요.**
  - 사용자가 많은 제품, 금융 앱과 같은 높은 품질이 필요한 제품
    - 이런 제품의 경우에는 **클린 코드를 작성하는 게 중요해요.** 사용자가 많고 높은 품질이 요구되며 계속해서 유지 보수를 해야하는 제품이기 때문이에요. 적절한 코드 퀄리티를 유지하고 테스트 코드를 작성하며 견고한 제품을 만들어 나갈 필요가 있어요.
- 기술 부채
  - 기술 부채(Technical Debt)는 소프트웨어 개발 과정에서 장기적인 품질과 유연성을 희생하면서 단기적인 목표를 달성하기 위해 발생하는 비용과 위험을 비유적으로 표현한 용어에요. 우리가 집을 구매할 때 대출을 통해서 구매하는 게 적절한 선택인 것처럼 소프트웨어를 개발하는 데 있어서도 적절한 기술 부채는오히려 비즈니스에 도움을 줄 수 있어요.
  - 그러나 적절한 기술 부채를 유지하는 게 중요한데요. 기술 부채가 일정 기준 이상으로 커지게되면 새로운 기능을 개발하고 버그를 수정하는 데 있어서 너무 많은 시간이 걸리게 되고 심지어는 새로 개발을 해야 할 수도 있어요.
  - 회사의 상황에 맞게, 들일 수 있는 리소스에 맞게, 제품의 상황에 맞게 **적절한 기술 부채를 유지하는 게 중요해요.** 비즈니스 목표를 달성하기 위해 어느 정도의 코드 퀄리티를 포기하고 개발할 수도 있어야 하는데요. 대신에 적정 수준의 퀄리티는 유지하고 이를 위해 적절한 리팩토링을 시도하는 것도 필요해요. 개인적으로는 **빠르게 개발을 하면서도 퀄리티를 맞추기 위해서** **평소에 개발 역량을 꾸준히 쌓아나가는 게 중요하다고 생각하고 있어요.**

### YAGNI, KISS, DRY

- YAGNI (야그니)

  - “You Aren't Gonna Need It”의 약자로, 소프트웨어 개발의 중요한 원칙 중 하나에요. 이 원칙은 **현재 필요하지 않은 기능이나 코드를 미리 작성하지 말라**는 원칙인데요. YAGNI는 애자일 개발 철학과 밀접하게 관련되어 있어요.
  - YAGNI 원칙의 핵심
    - 현재 필요한 기능만 개발하라
    - 코드베이스를 간결하게 유지한다
  - 당장 필요하지 않은 기능들을 미리 개발하게 되면 나중에 요구사항이 변경될 때 문제가 될 수 있어요. 또한 동료들에게도 코드를 이해하는 데 있어서 혼란을 줄 수 있구요. 따라서 **현재 필요한 기능만 개발하는 것이 중요해요.**

- KISS

  - “Keep It Simple, Stupid”의 약자로, 소프트웨어 개발과 설계에서 **단순함을 최우선으로 유지하라**는 철학을 나타내고 있어요. 이 원칙은 복잡성을 줄이고, 단순한 설계가 더 효율적이고 유지보수가 용이하다는 점을 강조해요. “단순함은 궁극의 정교함이다.”라는 레오나르도 다빈치의 말처럼 우리는 코드를 작성할 때 단순하면서도 명확하게 코드를 작성할 수 있도록 주의를 기울여야 해요.

  - 예시 코드

    ```jsx
    // as-is
    function calculateTotal(items) {
        let total = 0;
        for (let i = 0; i < items.length; i++) {
            if (items[i].price && items[i].quantity) {
                total += items[i].price * items[i].quantity;
            }
        }
        return total;
    }
    
    // to-be
    function calculateTotal(items) {
        return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    }
    ```

  - 문제를 해결하기 위한 방법으로 **가장 단순하면서 효과적인 방식을 채택하는 것**이 중요해요. 우리가 해결해야 할 문제는 **꼭 코드로만 해결할 필요가 없는 것**들도 있는데요. 어떤 방식으로 문제를 해결하는 게 가장 효율적일지에 대한 고민이 먼저 필요하고 만약 코드로 해결해야 한다면 명확하고 간결하게 선언적으로 코드를 작성하는 습관을 들이면 좋을 것 같아요.

- DRY

  - “Don't Repeat Yourself”의 약자로, 반복되는 코드를 피하고 중복을 최소화하라는 소프트웨어 개발의 중요한 철학이에요. 이 원칙은 코드의 재사용성을 높이고 유지보수성을 향상시키는 것을 이야기 하고 있어요.
  - DRY 원칙의 핵심
    - 중복을 제거하라
    - 재사용 가능한 구조 설계
    - 변경 용이성
  - DRY 원칙이 중요한 이유는 SSOT(Single Source Of Truth) 개념과 같이 생각해볼 수 있을 것 같아요. 같은 기능을 담당하는 코드가 여러곳에 위치하게 되면 유지보수(A1, A2, A3)를 하는 데 있어서 정말 큰 어려움을 겪을 수 있어요. 특정 기능을 수정해야 할 때 해당 기능과 관련된 코드가 **파편화 되어 있기 때문에 제대로 코드를 수정하기가 어려워요.**
  - 따라서 **중복되는 코드에 있어서는 추상화를 통해서 하나의 코드로 표현해주는 게 필요해요**. 다만 **가짜 중복과 진짜 중복**에 대해서 판단할 필요가 있는데요. 중복되는 코드라고 하더라도 실제로 정말 중복일 수도 있고 우연한 중복일 수 있기 때문에 **섣부른 추상화**를 하기 보다는 **같은 코드가 2~3번 이상 반복될 때 추상화를 해야하는 신호라고 보면 괜찮아요.**
  - https://www.youtube.com/watch?v=wuVy7rwkCfc
