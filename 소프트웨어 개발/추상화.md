> 소프트웨어 개발에서 추상화는 복잡한 세부 구현을 숨기고 사용자에게 필수적인 기능이나 인터페이스만 노출하는 원리이다. 이를 통해 코드를 더 단순하고, 쉽고, 재사용 가능하며, 유지보수 하기 쉽게 만든다.

### 기본 개념

> 추상화는 시스템의 특정부분이 어떻게(How) 작동하는지에 대한 복잡한 내용을 숨기고, 그 부분이 무엇(what)을 하는지만 노출 한다. 

- 목적: 복잡성 관리, 관심사 분리, 재사용성  및 유지보수성 향상
- 비유: 자동차를 운전하는 행위는 추상화의 좋은 예입니다. 운전자는 핸들, 가속 페달, 브레이크라는 단순한 **인터페이스**만 사용하며, 엔진의 복잡한 연소 과정, 연료 분사 시스템 등 **내부 구현 세부 사항**은 알 필요가 없다.

|추상화 대상 (컴포넌트)|숨겨진 복잡한 세부 사항|노출된 인터페이스 (Props)|이점|
|---|---|---|---|
|**`<Button>` 컴포넌트**|버튼의 스타일(CSS), `onClick` 이벤트 핸들링 방식, 접근성(Accessibility) 관련 HTML 속성 등|`onClick`, `children`(버튼 텍스트), `variant`(primary, secondary 등)|다른 개발자가 버튼을 사용할 때, 복잡한 스타일 코드를 몰라도 **무엇을 할지**(`variant`, `onClick`)만 전달하여 일관된 버튼을 생성 가능.|
|**`<Dropdown>` 컴포넌트**|드롭다운 메뉴를 열고 닫는 내부 상태(State) 관리 로직, 키보드 접근성 처리, 메뉴 목록 렌더링 방식|`options`(목록 데이터), `onSelect`(선택 시 실행될 함수), `placeholder`|개발자는 목록 데이터와 선택 처리 함수만 넘겨주고, 드롭다운이 **어떻게** 작동하는지는 신경 쓸 필요가 없음.|

> 추상화는 복잡한 시스템에서 핵심적인 부분만을 추출하여 단순화하는 과정이다. 이를 통해 개발자는 복잡한 세부 사항을 숨기고, 중요한 개념에 집중할 수 있다. 추상화는 객체 지향 프로그래밍에서 중요한 역할을 하며, 인터페이스와 추상 클래스를 통해 구현된다.
> 

- 사용자는 단순한 인턴페이스를 보고 사용
- 복잡한 내부 구현은 캡슐화
- 추상화는 **복잡성을 줄이고** 코드의 **유연성과 재사용성**을 높여줌.


> 추상화에서 생각해야할 부분?
> 추상화는 SOLID 원칙의 핵심 요소이다. 추상화를 통해 모듈은 추상화에 의존하고, 추상화는 모듈에 의존하지 않도록 설계되어야 한다. 이는 모듈의 확장성과 변경 용이성을 높이는 데 중요한 역할을 한다.
> 
> **변하는 것과 변하지 않는 것**을 분리 
> 변하는 것과 변하지 않는 것을 분리하는 것은 소프트웨어 설계의 핵심 원칙 중 하나이다. 변하지 않는 부분은 안전성을 제공하고, 변하는 부분은 유연성을 제공한다. 이를 통해 소프트웨어는 변경에 강하고, 유지보수가 용이한 구조를 갖출 수 있다.
> 
> 특정 기능에 종속되지 않고 **여러 곳에서 재사용 가능**하도록 설계 (인자로 받기))
> 
> 1. 의도적으로 드러내기: 코드의 의도를 명확하게 드러내는 것이 중요하다. 함수나 클래스의 이름, 변수명 등을 통해 코드가 무엇을 하는지 쉽게 이해할 수 있도록 해야 한다.(필수적인 맥락을 인자로 받기)
> 2. 변경 가능성이 높은 부분을 추상화: 변경 가능성이 높은 부분을 추상화하여, 변경이 필요할 때 해당 부분만 수정하면 되도록 한다. 이를 통해 코드의 유지보수성을 높일 수 있다.
> 3. 재사용성을 해치 않는 선에서 추상화: 추상화는 재사용성을 높이는 데 도움이 되지만, 지나친 추상화는 오히려 코드를 복잡하게 만들 수 있다. 따라서 재사용성을 해치지 않는 선에서 적절한 수준의 추상화를 유지하는 것이 중요하다.




### 이점

1. 단순성 및 이해 용이성: 복잡한 로직이 숨겨져 코드를 읽고 이해하기 쉬워진다.
2. 재사용성: 잘 추상화된 컴포넌트는 여러 위치에서 쉽게 재사용되어 개발 시간을 단축하고 일관성을 유지한다.
3. 유지보수성: 내부 구현이 변경되어도 추상화된 인터페이스(Props 또는 Hook의 반환 값)만 유지된다면, 해당 기능을 사용하는 외부 코드를 수정할 필요가 거의 없다.
4. 관심사 분리: 컴포넌트는 UI 표시에만 집중하고, Hook은 비지니스 로직에 집중하는 등 각 모듈의 역할이 명확해져 코드가 깔끔해진다.
