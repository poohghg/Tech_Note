# FSD(기능 분할 설계 )

## FSD 이전의 FDA의 원칙

FSD는 `Feature Sliced Design`의 줄임말입니다. FSD의 모체는 FDA이며 `Feature Driven Architecture`의 줄임말입니다. 

#### 좋은 코드의 조건

##### Discoverability (발견 가능성)

프로젝트 규모가 커질 수록 기능과 연관된 코드를 탐색하는데 많은 비용이 발생한다. 의존 관계에 놓여있는 코드를 탐색하기 위해 복잡한 구조의 폴더와 코드를 순차적으로 탐색해야 하기 때문이다.

##### Work parallelisation (공통 작업)

큰 규모의 프로젝트에서는 개개인이 기능과 연관된 코드를 탐색하는 것도 어렵지만,여러 명이 서로 다른 기능에 동시에 작업하는 것은 더욱 어렵다. 이는 내 수정 사항이 다른 코드에 어떠한 영향을 미칠지 모르기 때문이다.

- 테스트 코드로도 한계가 있다.

##### Controlling shared absractions (공유 추상화 제어)

공통적으로 사용해야 하는 코드들이 있는데 이런 코드들은 찾기 쉬운 위치에 직관적인 이름으로 작성되어 있어야 접근성이 높다.

### FDA에서의 주요 특징

##### Decentralization - 모놀리스(Monolith)

모놀리스 폴더 구조란 각 코드를 저장하는 폴더의 배치를 앱에서 맡은 의미적인 기능 즉 도메인이 아닌 components, utils 이렇게 기술적인 기능으로만 일차원적으로 배치해놓는것을 의미한다. 이는 각 코드의 역할별로 폴더에 저장을 하면서 한 폴더 내부에서 어떤 파일이 앱의 어떤한 도메인과 연관되어 있는지 파악하기 힘들다.

![image-20240513120701064](/Users/khg/Library/Application Support/typora-user-images/image-20240513120701064.png)


![image-20240513120735327](/Users/khg/Library/Application Support/typora-user-images/image-20240513120735327.png)

- 결합도과 높고 응집도는 낮은 코드 관리가 된다.

##### 피처 단위로 코드 나누기(캡슐화)

피처 단위(도메인)로 코드를 관리 하는 방법이다. 피처 내부에는 타입들이 존재하고, 피처 타입의 코드들은 각 피처 내부에서만 사용되므로 코드를 수정할 때 영향을 미칠 범위가 분명해진다.

> 피처 단위의 타입이란?
>
> 해당 도메인에서 사용되는 폴더타입이다.
>
> ex) constatns,types,utils,hooks등 이다.



![image-20240513121137843](/Users/khg/Library/Application Support/typora-user-images/image-20240513121137843.png)

Index.js를 통해서만 각 컴포넌트들이 외부로 노출되므로 코드를 사용하는 다른 사람에게 private 모듈과 public 모듈을 분리하여 전달할 수 있다.

##### Explicit Sharing (명시적 공유)

공통 코드가 변결될 때 버그가 발생하는 것은 테스트코드를 통해 100%해결 할 수 없다. 공통 모듈의 경우 작성자가 모든 유스케이스를 100%예측 할 수 없기 때문이다.

- 이를 방지 하기 위해 타입스크립트와 같은 정적 타이밍 도구를 사용하는 것을 추천한다.

또는 shared 코드에 들어갈 코드의 기준을 높이는 것이다.

- 재사용 중인 모듈이 있어야한다.
- 특정 도메인에 결합된 로직이 아니어야 한다.
- 변경 가능성이 적어야 한다.
- 이는 특정 도메인에 얽매이지 않는 타 앱에서도 사용 가능할 정도의 코드를 작성하는것이다.

아래 방식의 고려 되어야 한다.

- 많은 테스트 코드를 작성
- 함수를 순수함수로 작성
- 코드 리뷰를 강화

##### co-location

피처 내부에서 쓰이는 도메인 코드가 여러 곳으로 분류되어있으면 코드를 탐색하기가 어렵기 때문에 최대한 한 폴더 내부에 위치 시킨다.

![image-20240513134850530](/Users/khg/Library/Application Support/typora-user-images/image-20240513134850530.png)

##### de-coupling isolation

- 피처 코드 내부에서 사용하는 코드들은 다른 피처 모듈을 의존하면 안된다.
- Page 코드가 다른 page를 의존하면 안된다,
- Shared 코드가 다른 타입을 의존하면 안된다.

제일 중요한 원칙이며 FDS에서 그대로 계승되었다.

### FDA정리

> A set of principles that helps you to define the boundaries
> 코드의 역할과 책임을 나누는 원리

## FSD

FSD는 프론트엔드 애플리케이션을 스캐폴딩하기 위한 아키텍처 방법론이다. 코드 구성에 대한 규칙과 컨벤션을 모아 둔것이다. 이 방법론의 주요 목적은 끊임없이 변화하는 비지니스 요구 사항에 직면하여 프로젝트를 보다 이해하기 쉽고 구조화 하는 것이다.

- 기능을 중심으로 구조화하고 각 레이어와 의존성에 대한 표준 과 규칙을 설정하는것을 목표로 한다.
- 각 기능별 응집도는 높이고, 결합도는 낮추려는 목적을 가진다.

![이미지](https://ui-log.github.io/assets/CLEANandAgileFlutterProjectswiththeCLEANFeature-SlicedScalableModel_5.25aade99.png)

### 고려사항

- 프론트엔드 아키텍처에만 유용하다,
- 사용자 지향 애플리케이션에서만 유용하다. UI키트 또는 라이브러리 생성을 하려한다면  [Material UI](https://github.com/mui/material-ui) 를 참조
- 단일 페이지와 같은 매우 간단한 웹의 경우 FSD의 이점이 필요하지 않지만, FSD는 기본적으로 코드 구성 및 코드 관리에 대해 배울 수 있다.

### 구성 요소

![테마-계획](https://feature-sliced.design/assets/images/visual_schema-e826067f573946613dcdc76e3f585082.jpg)

FSD에서는 다음으로 구성되어 있다.
레이어, 슬라이스, 세그먼트 다음 세 단계로 구성되어 있다.

### 레이어

레이어는 최상위 디렉토리이자 애플리케이션 분해의 첫 번째 단계이다.
레이어는 초기 7단계로 구성되었지만, 현재는 6단계로 구성되어 있으며, 일부 레이어의 경우 선택사항이다.

![레이어 디렉토리](https://emewjin.github.io/static/cfb1fc05a675bc4a131b8317b073ec2d/34ea4/image2.png)

각 레이어는 고유한 책임 영역이 있으며 이는 비지니스 지향적이다.
레어이 내 모듈은 엄격하게 하위 레어이의 모듈과 상호 작용 가능하다.

특징

- 상위 레벨에 있는 레이어는 하위 레벨을 의존성으로 가질 수 있지만 그 반대는 성립될 수 없다.
- 하위 레이어로 갈 수록 추상화가 심화되며 상위 레이어로 갈 수록 비지니스 로직이 심화된다.
- 앱에서 각 레이어가 맡고 있는 역할을 분명하게 나눔으로 인해 의존성 그래프가 영향을 미치는 범위를 일부분으로 한정한다.

  ![image-20240513142840963](/Users/khg/Library/Application Support/typora-user-images/image-20240513142840963.png)



각 레이어의 특징

1. app: 애플리케이션 로직이 초기화되는 곳이다.

   - 앱의 설정을 맡는 레이어로 여러 모듈에서 재사용하지 않으나, 앱에 고루 영향을 미치는 모듈들을 저장하는 곳이다.

   - 프로바이더, 라우터, 전역 스타일, 전역 타입 선언 등이 여기에서 정의된다.

   - 애플리케이션의 진입점 역할을 한다.

   - 해당 레이어는 슬라이스,세그멘트 구조로 설계되지 않아도 된다.

     

2. processes: 이 레이어는 여러 단계로 이루어진 등록과 같이 여러 페이지에 걸쳐 있는 프로세스를 처리합니다. 이 레이어는 더 이상 사용되지 않는다. 선택적 레이어이다.

   

3. pages: 이 레이어에는 애플리케이션의 페이지가 포함된다.

   - 앱에서 각 라우터에 해당하는 페이지들을 작성하는 곳이다.
   - Pages 슬라이스의 공개 API는 app라우터에서만 사용된다. 
     - 사용처는 app내 라우터 일뿐 해당 레이어에 정의된 컴포넌트, 기능은 재사용 될 수 없다.
   - 관리 방식
     - UI를 각 섹션별로 관리한다.
     - 해당 page(슬라이스)에서 공통으로 사용되는 기능은 세그멘트 내 폴더 에서 관리된다.
     - 해당 컴포넌트(UI)에서만 사용되는 기능,타입,상수 는 해당 파일에서 정의를 우선한다.
       - 해당 컴포넌트(UI)내 기능이 많을 시 세그멘트 구조를 사용한다.

   

4. widgets: 페이지에 사용되는 독립적인 UI 컴포넌트이다.

   - 위젯은 하위의 레이어들을 이용해 특정 피쳐에서 사용할 수 있는 UI블럭이다.

   - 특정 의존성과 강하게 결합되어 있기에 여러 페이지에서 재사용 하지 못할 수 있다.

   - 앱 내부에서 맡고있는 도메인이 정확하게 구분되어 있다.

   - 일반적으로 페이지의 내부에서 사용되는 컴포넌트 또는 피처레이어 보단 강하게 결합된 형태이다.

   - 예제  [falkchat](https://github.com/falkomerr/falkchat)

     

5. features: 이 레이어는 비즈니스 가치를 전달하는 사용자 시나리오와 기능을 정의한다.. 예를 들어 좋아요, 리뷰 작성, 제품 평가 등이 있습니다. 선택적 레이어이다.

   - 특정 도메인의 기능을 담당한다.

   

6. entities: 이 레이어는 비즈니스 엔티티를 나타냅니다. 선택적 레이어다. 

   - 특정 도메인과 연관된 API의 호출 함수가 정의 되어 있다.

   - 특정 도메인의 모델을 정의 한다.

   - 리액트 쿼리 사용시 쿼리 설정 및 쿼리를 선언 한다.

     

7. shared: 이 레이어에는 특정 비즈니스 로직에 종속되지 않은 재사용 가능한 컴포넌트와 유틸리티가 포함되어 있습니다. 여기에는 UI 키트, axios 설정, 애플리케이션 설정, 비즈니스 로직에 묶이지 않은 헬퍼 등이 포함됩니다.

   - 해당 레이어는 슬라이스,세그멘트 구조로 설계되지 않아도 된다.
   - 해당 레이어 코드는 특정앱에 종속적이지 않는다.(타 앱에서 사용가능)
     - 공용 앱 타입의 경우 해당 레이어에서 정의한다.
     - 특정 도메인 로직의 경우 entities 또는 features 레이어에 정의한다. 
   
   
   

### 슬라이스

애플리케이션 분해의 두 번째 수준인 슬라이스는 하위 디렉토리가 있다. 슬라이스는 특정 비지니스 엔티티에 대한 것이다. 주요 목적은 코드를 값별로 그룹화하는 것이다.

밀접하게 관련된 조각들을 구조적으로 디렉토리 내에 그룹지을 수 있지만 다른 슬라이스를 참조하면 안된다.

- 슬라이스 내부에서는 pubilc api 정의가 있어야한다.
- 슬라이스 내부에서는 여러 그룹의 세그먼트를 가질 수 있다.
- 슬라이스는 세분화 될 수 있다.
  - ex) profile -> follow-profile


### 세그멘트

세그멘트는 FSD의 마지막 계층에 있는 요소로 한 도메인 안에서 기술적인 결과를 달성하기 위해 작성된다.세그먼트의 이름은 ui, model, lib, api등이 될 수 있으며 예시는 아래와 같다.

세그멘트들은 주로 타입으로 구성된다.

- ui: UI 컴포넌트
  - 계층 구조 - 기존 뎁스 사용 무관

- model: 비즈니스 로직, data aggregation 함수들
  - 주로 해당 슬라이스 내에서 사용되는 공용 상태를 정의한다.
  - 타입정의
    - 해당 슬라이스의 공용 타입 또는 상위 레이어에서 사용하는 타입 정의
    - 세그멘트 내 각 기능별 파일 내 타입은 해당 파일에서 정의 
  - 특정 기능을 담당하는 클래스
  - ex) type.ts, class.ts
- lib: infra structural code
  - 슬라이스 내에서 사용되는 보조 기능.
  - utils
  - hooks
  - helper
  - 해당 세그멘트 내 다양한 타입이 있을 시 폴더 구조로 변경
- api: backend api를 호출하기 위한 코드들
- consts - 필요한 상수.
- state - 전역 상태 정의 

Index.ts

### 공개 API

공개 API는 index.js 또는 index.ts 파일이며, 이 파일을 통해 슬라이스 또는 세그먼트에서 필요한 기능만 외부로 추출하고 불필요한 기능은 격리할 수 있다. 인덱스 파일은 진입점 역할을 한다.

- next에서 공개 API는 각각 번들러의 목적에 따라 사용 불가능 한 경우가 있어. 사용을 지양한다.
- next에서는 기본적으로 서버,클라이언트 번들로 번들링 되고 번들링 되는 모듈이 블랙박스로 import 되어 있고 서버,클리어인트 모두에서 사용한다면 에러가 발생한다.

> 모듈 사용 및 통합의 편의성은 다음과 같은 *여러 목표* 달성을 통해 달성됩니다 .
>
> 1. 개별 모듈의 내부 구조가 **변경되지 않도록** 애플리케이션을 보호해야 합니다.
>
> 2. 모듈의 내부 구조 처리는 다른 모듈 **에 영향을 주어서는 안 됩니다.**
>
> 3. 모듈 동작의 중요한 변화를 
>
>    쉽게 감지 할 수 있어야 합니다.
>
>    > **모듈 동작의 중요한 변경** - 모듈의 사용자 엔터티에 대한 기대를 깨뜨리는 변경입니다.
>
> 이러한 목표는 모듈 기능에 대한 단일 액세스 지점이고 모듈과 외부 세계의 상호 작용에 대한 "계약"을 정의하는 공용 인터페이스(Public API)를 도입하여 달성할 수 있습니다.

### 참조

- [공식 문서](https://feature-sliced.design/docs/get-started/overview)
- https://velog.io/@jay/fsd
- [기능 분할 설계 번역글](https://emewjin.github.io/feature-sliced-design/)
- [깃허브 next14 예제코드](https://github.com/falkomerr/falkchat) 
- https://velog.io/@yeonoey/FSD-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90
- https://ui-log.github.io/docs/Tech/2024-03-28-CLEANandAgileFlutterProjectswiththeCLEANFeature-SlicedScalableModel/





