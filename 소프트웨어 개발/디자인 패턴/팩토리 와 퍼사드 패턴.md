## 1. Factory Pattern (팩토리 패턴)

### 팩토리 패턴이란?

객체를 생성하는 코드를 직접 작성(new 키워드 사용)하지 않고, **객체 생성을 전담하는 공장(Factory) 클래스**에 맡기는 패턴입니다. 클라이언트는 어떤 구체적인 클래스가 생성되는지 알 필요 없이, 공장에 요청만 하면 됩니다.

### 언제 사용하는가?

- **객체 생성 로직이 복잡할 때:** 생성 시 조건에 따라 다른 객체를 만들어야 하는 경우.
- **의존성을 줄이고 싶을 때:** 클라이언트 코드가 구체적인 클래스명에 의존하지 않게 하여 변경에 유연하게 대처하고 싶을 때.
- **확장성이 필요할 때:** 새로운 제품군이 추가되어도 기존 클라이언트 코드를 수정하고 싶지 않을 때.

### 비슷한 패턴

- **Abstract Factory(추상 팩토리):** 연관된 여러 객체들을 한꺼번에 생성하는 '공장들의 공장'입니다.
- **Builder(빌더):** 복잡한 객체를 단계별로 조립하여 생성할 때 사용합니다.
---

## 2. Facade Pattern (퍼사드 패턴)

### 퍼사드 패턴이란?

'Facade'는 건물의 정면(외벽)을 의미합니다. 여러 복잡한 서브 시스템(클래스들)의 앞단에 **단순한 인터페이스(창구)**를 두어, 사용자가 내부의 복잡도를 몰라도 기능을 쉽게 사용할 수 있게 하는 패턴입니다.

### 언제 사용하는가?

- **시스템이 너무 복잡할 때:** 수많은 클래스가 얽혀 있어 사용법이 어려울 때, 핵심 기능만 모은 '간편 메뉴판' 역할을 합니다.
- **계층화가 필요할 때:** 서브 시스템 간의 결합도를 낮추고, 외부에서는 퍼사드만 바라보게 하여 진입점을 단일화하고 싶을 때.
- **레거시 코드를 감쌀 때:** 오래되고 복잡한 코드를 새로운 인터페이스로 깔끔하게 정리하고 싶을 때.
### 비슷한 패턴

- **Adapter(어댑터):** 퍼사드가 인터페이스를 '단순화'한다면, 어댑터는 호환되지 않는 인터페이스를 '변환'하여 연결합니다.
- **Proxy(프록시):** 실제 객체에 접근하기 전 제어권을 갖거나 기능을 가로채는 대리인 역할을 합니다.
---

## 3. 핵심 요약 및 비교

|구분|Factory Pattern|Facade Pattern|
|---|---|---|
|**주요 목적**|객체 **생성** 과정의 캡슐화|시스템 **사용** 방식의 단순화|
|**핵심 키워드**|인스턴스화, 유연한 생성|복잡성 은닉, 단일 창구|
|**관점**|"어떻게 만들 것인가?"|"어떻게 쉽게 쓸 것인가?"|

## 1. Factory Method Pattern (팩토리 메서드 패턴)

팩토리 패턴은 **객체 생성 로직을 자식 클래스나 별도의 클래스에 위임**하는 패턴입니다.

``` ts
// 1. 제품(Product) 인터페이스
interface Message {
  send(content: string): void;
}

// 2. 구체적인 제품(Concrete Product)들
class EmailMessage implements Message {
  send(content: string) { console.log(`Sending Email: ${content}`); }
}

class SMSMessage implements Message {
  send(content: string) { console.log(`Sending SMS: ${content}`); }
}

// 3. 팩토리(Creator) 클래스
class MessageFactory {
  static createMessage(type: "email" | "sms"): Message {
    if (type === "email") return new EmailMessage();
    if (type === "sms") return new SMSMessage();
    throw new Error("Unknown type");
  }
}

// 사용 예시
const mail = MessageFactory.createMessage("email");
mail.send("Hello Factory!");
```

- **특징:** `new EmailMessage()`를 직접 호출하지 않습니다. 나중에 `PushMessage`가 추가되어도 `MessageFactory`만 수정하면 될 뿐, 이를 사용하는 클라이언트 코드는 안전합니다.
    

---

## 2. Facade Pattern (퍼사드 패턴)

퍼사드 패턴은 **여러 클래스의 복잡한 상호작용을 하나의 단순한 인터페이스로 감싸는** 패턴입니다.

### TS 코드 예시: 홈 시어터 시스템

TypeScript

```
// 서브 시스템들 (복잡하고 기능이 많음)
class Amplifier { on() { console.log("앰프 켬"); } }
class Projector { on() { console.log("프로젝터 켬"); } }
class Lights { dim() { console.log("조명 어둡게"); } }

// 퍼사드(Facade) 클래스: 복잡한 과정을 하나로 묶음
class HomeTheaterFacade {
  constructor(
    private amp: Amplifier,
    private proj: Projector,
    private lights: Lights
  ) {}

  watchMovie() {
    console.log("--- 영화 감상 준비 ---");
    this.lights.dim();
    this.proj.on();
    this.amp.on();
  }
}

// 사용 예시
const theater = new HomeTheaterFacade(new Amplifier(), new Projector(), new Lights());
// 내부 조작을 다 알 필요 없이 버튼 하나로 해결
theater.watchMovie(); 
```

- **특징:** 사용자는 앰프, 프로젝터의 개별 작동법을 몰라도 `watchMovie()` 하나만 호출하면 됩니다.
    

---

## 3. 요약 및 비교

|**구분**|**Factory Pattern**|**Facade Pattern**|
|---|---|---|
|**핵심 질문**|"어떤 객체를 생성할까?"|"어떻게 기능을 쉽게 쓸까?"|
|**해결책**|객체 생성 코드를 한곳에 몰아넣음|복잡한 API들을 하나의 인터페이스로 통합함|
|**유사 패턴**|**Abstract Factory**: 더 거대한 제품군 생성|**Adapter**: 인터페이스를 변환하여 연결함|