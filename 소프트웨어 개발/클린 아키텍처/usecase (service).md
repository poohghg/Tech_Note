> 유즈케이스는 사용자가 시스템으로 무엇을 할 수 있는가를 코드로 표현한 계층이다.

> 엔티티를 조합하여 하나의 의미 있는 행동을 완결하는 ==애플리케이션 규칙==을 구현한다.
> 유즈케이스는 시스템의 상태를 변경할 수 있다.


```
UI (pages / widgets) [ Frameworks / UI ]
  ↓
Hooks (features) [ Frameworks / UI ]
  ↓
Usecase (interface) 
  ↓
Service (implementation)
  ↓
Repository (interface)
  ↓
API / Storage / Infra

```

### 유즈케이스의 역할

#### 1.시스템 단위의 행동을 정의한다.

> 유즈케이스는 시스템이 제공하는 기능을 나타낸다.
> 유즈케이스는 사용자가 시스템과 상호작용하는 방법을 정의한다. => 사용자 액션

|UI 액션|Use Case|
|---|---|
|로그인 버튼 클릭|LoginUseCase|
|상품 결제|PayOrderUseCase|
|회원 탈퇴|WithdrawUserUseCase|
#### 2. 여러 엔티티를 조합한다.

> 유즈케이스는 하나 이상의 엔티티를 사용하여 복잡한 비즈니스 로직을 구현한다.
> 엔티티의 경우 단일 책임 원칙(SRP)을 준수하여 설계되므로, 유즈케이스는 여러 엔티티를 조합하여 시스템의 행동을 완성한다.

#### 3.비지니스 흐름의 순서를 보장한다.

> 유즈케이스는 비즈니스 로직의 흐름을 제어한다.
> 유즈케이스는 여러 단계를 포함할 수 있으며, 각 단계는 특정 순서로 실행되어야 한다.
> 언제 무엇을 호출하는지는 유즈케이스가 결정한다.


``` text

// 순서가 중요
1. 주문 조회
2. 결제 가능 여부 확인
3. 결제 수행
4. 상태 변경
5. 저장

```

#### 4.외부 의존성을 추상화해서 사용한다.

> 유즈케이스는 외부 시스템과의 상호작용을 추상화한다.
> 인터페이스에 대한 의존성을 통해 외부 시스템과 통신하며, 이를 통해 유즈케이스는 외부 시스템의 변경에 영향을 받지 않는다.

#### 5.성공/실패의 의미를 정의한다

> 유즈케이스는 성공과 실패의 기준을 정의한다.
> 유즈케이스는 작업이 성공적으로 완료되었는지 여부를 판단하는 로직을 포함할 수 있다.

``` ts
try {
  await paymentGateway.pay()
} catch {
  throw new PaymentFailedError()
}

```

> UI는 왜 실패했는지 알 필요가 없다.
> 특정 행동이 성공했는지 실패했는지 여부만 알면 된다.

### 유즈케이스가 절대 하면 안 되는 것

> 유즈케이스는 애플리케이션 규칙을 구현하는 계층이므로, 다음과 같은 작업은 절대 포함해서는 안 된다.
> 유즈케이스는 표현 계층, 기술 관심사, 외부 프레임워크에 의존해서는 안 된다.

|금지 항목|이유|
|---|---|
|UI 상태 관리|프레임워크 의존|
|HTTP 상태 코드 판단|기술 관심사|
|Toast / Alert|표현 계층|
|Redux / Recoil 접근|외부 프레임워크|
|DB 쿼리|Repository 책임|
### Service vs Domain Service

|구분|Service (Use Case)|Domain Service|
|---|---|---|
|위치|Application Layer|Domain Layer|
|책임|행동의 흐름|도메인 계산|
|의존성|Repo, Gateway|Entity만|
|예시|주문 결제|가격 계산|