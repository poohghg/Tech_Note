> 참조
> 
> https://web.dev/articles/optimize-long-tasks?utm_source=devtools&utm_campaign=stable&hl=ko

> 기본 스레드는 한 번에 하나의 작업만 처리할 수 있습니다. 50밀리초 이상 걸리는 작업은 _긴 작업_입니다. 50밀리초를 초과하는 작업의 경우 작업의 총 시간에서 50밀리초를 뺀 값을 작업의 _차단 기간_이라고 합니다.
> 
> 브라우저는 길이가 다른 작업이 실행되는 동안 상호작용이 발생하는 것을 차단하지만 작업이 너무 오래 실행되지 않는 한 사용자는 이를 감지할 수 없습니다. 하지만 긴 작업이 많은 상황에서 사용자가 페이지와 상호작용하려고 하면 사용자 인터페이스가 응답하지 않는 것처럼 느껴지고, 기본 스레드가 매우 오랫동안 차단되면 깨진 것처럼 보일 수도 있습니다.

![Pasted image 20250804034631.png](../img/Pasted%20image%2020250804034631.png)

### 메인 스레드 (Main Thread): 모든 일의 중심

브라우저 중심에는 **메인 스레드**가 있다. 이 스레드는 다음과 같은 매우 중요한 작업들을 **순차적으로(한 번에 하나씩)** 처리한다.

- **JavaScript 실행:** 우리가 작성한 대부분의 코드(클릭 이벤트 핸들러, `useEffect`, 데이터 처리 등)가 여기서 실행됩니다.
- **DOM 파싱 및 조작:** HTML을 파싱하여 DOM 트리를 만들고, JavaScript로 DOM을 변경하는 작업을 수행합니다.
- **CSS 파싱 및 스타일 계산:** CSS를 파싱하여 CSSOM 트리를 만들고, 각 DOM 요소에 어떤 스타일이 적용될지 계산합니다.
- **레이아웃 (Layout/Reflow):** 각 요소가 화면 어디에, 어떤 크기로 배치될지 계산합니다.
- **페인트 (Paint):** 계산된 정보를 바탕으로 각 요소를 화면에 그릴 준비(레이어 생성 등)를 합니다.

**가장 중요한 점:** 이 모든 작업이 **하나의 큐**에서 처리되기 때문에, 만약 JavaScript 실행(Long Task)이 200ms 동안 스레드를 점유하면, 그 시간 동안 다른 모든 작업(레이아웃, 페인트, 다른 이벤트 처리)은 **완전히 멈춘다.** 이것이 바로 '렌더링 블로킹'의 근본적인 원인이다.

### 왜 이렇게 설계되었을까? (동시성 문제 방지)

만약 자바스크립트 실행과 렌더링이 서로 다른 스레드에서 동시에 일어난다고 상상해 보세요.

- **자바스크립트 스레드:** "이 버튼을 DOM에서 제거해!" (`button.remove()`)
- **렌더링 스레드:** "이 버튼의 색을 파란색으로 칠해!" (`button.style.color = 'blue'`)

이 두 명령이 동시에 실행되면 브라우저는 혼란에 빠집니다. 이미 사라진 버튼에 색을 칠하려고 시도하면서 에러가 발생할 수 있습니다. 이런 **동시성(Concurrency) 문제**를 원천적으로 차단하고 DOM 조작을 예측 가능하고 안전하게 만들기 위해, 이 작업들은 하나의 메인 스레드에서 순서대로 처리되도록 설계되었습니다.

### 다른 스레드들의 역할 (브라우저의 조력자들)

- **워커 스레드 (Worker Threads):**
    - **역할:** 메인 스레드와 완전히 분리된 공간에서 순수하게 무거운 JavaScript 연산을 처리
    - **예시:** 거대한 JSON 데이터 파싱, 복잡한 수학 계산, 데이터 암호화 등.
    - **장점:** 워커 스레드에서 아무리 오래 걸리는 작업을 해도 메인 스레드는 영향을 받지 않으므로 UI가 멈추지 않습니다.
    - **주의:** 워커 스레드는 DOM에 직접 접근할 수 없으며, `postMessage`를 통해 메인 스레드와 통신해야 합니다.
- **컴포지터 스레드 (Compositor Thread):**
    - **역할:** 메인 스레드가 페인트(Paint) 단계를 통해 생성한 여러 레이어(Layers)를 받아, 이를 합성(Composite)하여 실제 화면에 표시하는 역할.
    - **특징:** `transform`, `opacity` 같은 속성은 레이아웃과 페인트를 건너뛰고 이 컴포지터 스레드에서 직접 처리됩니다. 이것이 이 속성들을 사용한 애니메이션이 매우 부드러운 이유입니다. 메인 스레드가 바쁘더라도 컴포지터 스레드는 독립적으로 화면을 업데이트할 수 있습니다.
- **네트워크 스레드 (Network Thread):**
    - **역할:** 이미지, API 데이터 등 모든 네트워크 요청을 처리합니다.

### 최종 요약

| 스레드 종류       | 주요 역할                                  | 개발자와의 관련성                                                 |
| ------------ | -------------------------------------- | --------------------------------------------------------- |
| **메인 스레드**   | **JS 실행, DOM, CSS, 레이아웃, 페인트**         | **가장 중요.** 우리가 작성하는 대부분의 코드가 여기서 동작하며, 성능 병목의 주된 원인이 됨.   |
| **워커 스레드**   | 무거운 JS 연산 처리                           | Long Task를 분리하여 메인 스레드의 부담을 덜어줄 때 `Web Worker`를 통해 직접 사용. |
| **컴포지터 스레드** | 레이어 합성, 스크롤, `transform/opacity` 애니메이션 | 성능 최적화를 위해 `transform/opacity`를 사용하면 이 스레드의 도움을 받음.       |
| **네트워크 스레드** | 리소스 다운로드 및 업로드                         | 직접 제어하진 않지만, 네트워크 요청이 완료되면 그 결과 처리는 메인 스레드에서 이루어짐.        |

 **"브라우저는 멀티 스레드로 동작하지만, JS 코드와 렌더링은 하나의 메인 스레드 위에서 경쟁하는 관계다"** 
 
---
### 1. FPS란 무엇인가?

**FPS**는 **Frames Per Second**의 약자로, 우리말로 하면 **"초당 프레임 수"** 이다.

우리가 보는 모든 영상(영화, 게임, 웹 애니메이션)은 사실 연속된 정지 이미지(프레임)를 매우 빠르게 보여줌으로써 움직이는 것처럼 보이게 하는 원리이다.

- **1fps:** 1초에 1장의 이미지를 보여준다. (움직임이 뚝뚝 끊겨 보임)
- **30fps:** 1초에 30장의 이미지를 보여준다. (일반적인 영상, 어느 정도 부드러움)
- **60fps:** 1초에 60장의 이미지를 보여준다. (매우 부드러운 움직임)

**비유: 플립북 (Flipbook)** 어릴 때 교과서 귀퉁이에 그림을 그려 빠르게 넘기면 만화처럼 보이던 것을 생각하시면 됩니다.

- **플립북의 각 페이지 한 장 한 장** = **프레임(Frame)**
- **1초 동안 얼마나 많은 페이지를 넘기는가** = **FPS**

60fps는 1초에 60장의 페이지를 부드럽게 넘기는 것과 같습니다.

### 2.  왜 하필 '60'fps가 중요한가?

대부분의 현대적인 모니터, 스마트폰 화면의 **주사율(Refresh Rate)이 60Hz**이기 때문이다.

- **주사율 (Hz):** 디스플레이가 1초에 화면을 몇 번이나 새로 고칠 수 있는지를 나타내는 물리적인 성능입니다. 60Hz는 1초에 60번 화면을 깜빡이며 새 그림으로 업데이트한다.

**브라우저의 목표:** 화면이 새로고침될 때마다, 그 타이밍에 맞춰 새로운 프레임을 그려서 전달하는 것.

만약 브라우저가 이 60Hz 주사율에 맞춰 1초에 60개의 새로운 프레임을 꾸준히 만들어내지 못하면, 화면은 이전 프레임을 한 번 더 보여주게 됩니다. 이것이 우리 눈에는 **버벅거림(Stutter) 또는 렉(Lag)**으로 느껴집니다.

### 3. "16.67ms의 마법" - 렌더링의 시간 예산

이것이 가장 중요한 핵심입니다. 60fps를 달성하기 위해 브라우저가 하나의 프레임을 만드는 데 허용된 시간은 얼마일까요?

> **1초 / 60 프레임 = 1000밀리초(ms) / 60 프레임 ≈ 16.67ms/프레임**

즉, 브라우저는 **단 16.67ms 안에** 다음 프레임을 그리는 데 필요한 모든 작업을 끝내야 한다. 이 시간을 **'프레임 예산(Frame Budget)'** 이라고 부릅니다.

이 16.67ms 안에 브라우저는 다음과 같은 일들을 처리해야 합니다.

1. **JavaScript 실행:** 이벤트 핸들러, 애니메이션 로직 등 모든 자바스크립트 코드를 실행합니다.
2. **스타일 계산 (Style):** 어떤 CSS 규칙이 어떤 DOM 요소에 적용될지 계산합니다.
3. **레이아웃 (Layout):** 각 요소의 크기와 위치를 계산합니다.
4. **페인트 (Paint):** 각 요소를 픽셀로 변환하기 위해 레이어를 만듭니다.
5. **합성 (Composite):** 생성된 레이어들을 순서대로 합쳐 최종 화면을 만듭니다.

### 4. 프레임 드랍 (Frame Drop): 16.67ms를 초과했을 때

만약 위 5가지 작업의 총합이 16.67ms를 초과하면 어떻게 될까요?

- 예를 들어, 자바스크립트 실행(Long Task)에만 30ms가 걸렸다고 가정해 봅시다.
- 브라우저는 16.67ms가 되는 시점에 새 프레임을 화면에 전달해야 하지만, 아직 작업이 끝나지 않았습니다.
- **결국 브라우저는 새 프레임을 만드는 것을 포기하고, 이전 프레임을 한 번 더 보여줍니다.**
- 이것을 **프레임 드랍(Frame Drop)** 또는 **쟁크(Jank)**라고 부릅니다.

**시각적 설명:**

**✅ 60fps (성공적인 경우)**

Code

```
프레임 1 (16.7ms)  프레임 2 (16.7ms)  프레임 3 (16.7ms)
|------------------|------------------|------------------|
```

**❌ 프레임 드랍 (실패한 경우)**

Code

```
      프레임 1 (30ms 소요)        프레임 2 (16.7ms)
|------------------------------|------------------|
      ↑                          ↑
(여기서 보여줬어야 할 프레임 누락)  (여기서 프레임 1이 한 번 더 보임)
```

사용자는 이 누락된 구간에서 애니메이션이 순간적으로 멈추거나 버벅이는 것을 느끼게 됩니다.

### 최종 요약

- **60fps는** 1초에 60개의 프레임을 그려내어 사용자에게 가장 부드러운 시각적 경험을 제공하는 것을 목표로 하는 성능 지표입니다.
- 이를 달성하려면, 브라우저는 **하나의 프레임을 16.67ms 안에** 그려야 합니다.
- 만약 자바스크립트 실행, 렌더링 등의 작업이 이 **16.67ms라는 시간 예산을 초과**하면 **프레임 드랍(쟁크)**이 발생하여 사용자는 버벅거림을 느끼게 됩니다.

따라서 프론트엔드 성능 최적화란, 결국 **"어떻게든 모든 작업을 16.67ms 안에 끝낼 것인가?"** 라는 질문에 대한 해답을 찾아가는 과정이라고 할 수 있습니다.

---
### 1. 왜 Long Task가 렌더링을 블로킹하는가?

가장 중요한 사실은 **자바스크립트 실행(Scripting)과 렌더링(Rendering)이 모두 동일한 하나의 메인 스레드(Main Thread)에서 일어난다**는 점입니다.

메인 스레드는 한 번에 하나의 일만 처리할 수 있는 '외길'과 같습니다.

**비유: 한 명의 바리스타가 일하는 카페**

- **메인 스레드:** 바리스타 1명
- **태스크(Task):** 손님의 주문 (커피 만들기, 계산하기, 매장 청소 등)
- **렌더링:** 매장 진열대를 정리하고 새 빵을 내놓는 일 (시각적 업데이트)
- **Long Task:** 아주 복잡하고 5분이 걸리는 스페셜 라떼 아트 만들기

만약 바리스타가 이 5분짜리 스페셜 라떼를 만들기 시작하면, 그 5분 동안은 다른 어떤 일도 할 수 없습니다. 다른 손님이 계산을 해달라고 해도, 매장이 더러워져 청소를 해야 해도, 새 빵을 내놓을 시간이 되어도 **라떼 만들기가 끝날 때까지는 모두 멈춰 있어야 합니다.**

이것이 바로 렌더링 블로킹입니다. 200ms가 걸리는 자바스크립트 함수(Long Task)가 실행되는 동안, 메인 스레드는 그 함수를 처리하느라 꽉 붙잡혀 있습니다. 그 결과, 렌더링을 할 기회 자체가 주어지지 않아 화면이 '얼어붙게' 되는 것입니다.

### 2. "마이크로태스크가 없으면 중간에 렌더링하지 않나요?"

**이벤트 루프의 1회 반복(Tick) 순서:**
1. **하나의 태스크(Task) 실행:**
    - 태스크 큐(Task Queue, 또는 Macrotask Queue)에서 가장 오래된 태스크를 하나 꺼냅니다.
    - 이 태스크를 **콜 스택(Call Stack)으로 가져와 실행**합니다.
    - **중요:** 이 태스크가 완전히 끝나서 **콜 스택이 완전히 비워질 때까지** 다른 어떤 작업도 끼어들 수 없습니다. (이것이 ==**Run-to-Completion**== 모델입니다.) 만약 이 태스크가 200ms짜리 Long Task라면, 200ms 동안 이 단계에 머무릅니다.
2. **모든 마이크로태스크(Microtask) 실행:**
    - 콜 스택이 비워지면, 마이크로태스크 큐(Microtask Queue)를 확인합니다.
    - 큐 안에 있는 **모든** 마이크로태스크를 전부 실행합니다. (Promise의 `.then`, `await` 등이 여기에 해당합니다.)
    - 이 과정에서 새로운 마이크로태스크가 추가되면, 그것마저도 이번 Tick에서 모두 처리합니다.
3. **렌더링 업데이트 (선택적):**
    - **여기서 렌더링이 일어납니다.** 브라우저는 "렌더링을 할 필요가 있는가?"를 판단합니다. (예: ==16.7ms(60FPS)가 지났는가?, 시각적 변경이 있었는가?==)
    - 필요하다면, 스타일 계산(Style), 레이아웃(Layout), 페인트(Paint), 합성(Composite) 단계를 거쳐 화면을 업데이트합니다.
    - **핵심:** 이 렌더링 단계는 반드시 **하나의 태스크가 완전히 끝나고, 모든 마이크로태스크까지 처리된 이후**에야 비로소 실행될 기회를 얻습니다.
4. **다음 루프로 복귀:** 다시 1번 단계로 돌아가 다음 태스크를 기다립니다.
    
#### 시각적 설명

**✅ 좋은 경우 (짧은 태스크들)**

Code

```
[Task 1 (JS, 2ms)] -> [Microtasks] -> [Render] -> [휴식] -> [Task 2 (JS, 3ms)] -> [Microtasks] -> [Render] ...
|------------------------------------- 16.7ms (1 프레임) -------------------------------------|
```

짧은 태스크들은 렌더링에게 자주 기회를 넘겨주므로, 애니메이션이 부드럽습니다.

**❌ 나쁜 경우 (하나의 Long Task)**

Code

```
[Long Task (JavaScript, 200ms)                                                       ] -> [Microtasks] -> [Render] ...
| <------------------- 200ms 동안 렌더링 절대 불가. 화면 멈춤 -------------------> |
```

Long Task 하나가 200ms 동안 메인 스레드를 독점하기 때문에, 이벤트 루프는 3단계인 렌더링 단계로 넘어갈 수가 없습니다. 마이크로태스크 큐가 비어있는지 여부와는 아무런 상관이 없습니다. **하나의 태스크가 끝나야만** 그 다음 단계로 넘어갈 수 있기 때문입니다.

### 결론

> **"하나의 태스크는 중간에 끊을 수 없다(Run-to-Completion)"**.

따라서 Long Task가 렌더링을 블로킹하는 이유는, 그 긴 시간 동안 이벤트 루프가 **1단계(태스크 실행)에 갇혀서 3단계(렌더링)로 진행하지 못하기 때문**입니다. 우리가 `setTimeout` 등으로 태스크를 분할하는 것은, 바로 이 1단계에 머무는 시간을 짧게 쪼개어 중간중간 3단계인 렌더링이 실행될 틈을 만들어주는 행위인 것입니다.

---
### 문제 상황: 블로킹을 유발하는 클릭 핸들러

먼저, 문제가 되는 코드의 형태이다. 3개의 무거운 작업이 하나의 클릭 핸들러 안에 있다.

``` js
// 각 함수는 100ms가 걸리는 무거운 작업이라고 가정합니다.
function doHeavyTask1() { /* ... 100ms 소요 ... */ }
function doHeavyTask2() { /* ... 100ms 소요 ... */ }
function doHeavyTask3() { /* ... 100ms 소요 ... */ }

myButton.addEventListener('click', () => {
  console.log('클릭 이벤트 시작!');
  
  doHeavyTask1();
  doHeavyTask2();
  doHeavyTask3();
  
  // 총 300ms가 걸리는 Long Task
  // 이 시간 동안 UI는 완전히 멈춥니다.
  console.log('모든 작업 완료!');
});
```

이 코드는 총 300ms 동안 메인 스레드를 차단한다. 우리는 이 작업을 50ms 미만의 작은 덩어리로 쪼개야 한다.

---
### 해결 전략: "실행하고, 양보하고, 다시 실행하기"

핵심은 **하나의 작은 작업을 실행한 뒤, 브라우저에게 제어권을 잠시 돌려주고(yield), 그 후 다음 작업을 실행**하는 것입니다. 브라우저는 이 짧은 틈을 이용해 UI 렌더링이나 다른 이벤트를 처리할 수 있습니다.

### 방법 1: `setTimeout(callback, 0)` 사용 (고전적 방법)

`setTimeout`에 지연 시간 0을 주면 "지금 당장 실행"하라는 의미가 아니라, "현재 실행 중인 코드가 모두 끝난 뒤, 가능한 가장 빠른 시점에 이 함수를 태스크 큐에 넣어 실행해달라"는 의미가 됩니다. 이를 이용해 실행 흐름을 분리할 수 있습니다.


``` js
myButton.addEventListener('click', () => {
  console.log('클릭 이벤트 시작!');
  
  // 첫 번째 작업은 즉시 실행
  doHeavyTask1(); 

  // 두 번째 작업은 브라우저에게 제어권을 넘겨준 뒤 실행
  setTimeout(() => {
    doHeavyTask2();

    // 세 번째 작업도 마찬가지
    setTimeout(() => {
      doHeavyTask3();
      console.log('모든 작업 완료!');
    }, 0);
  }, 0);
});
```

- **장점:** 간단하고 이해하기 쉽습니다.
- **단점:** 코드가 깊어지는 콜백 지옥(Callback Hell)이 발생할 수 있고, 실행 순서를 제어하기가 까다롭습니다.

---

### 방법 2: `async/await`와 비동기 함수 활용 (현대적 방법)

`async/await`를 사용하면 코드를 훨씬 더 읽기 쉽게 만들 수 있습니다. "제어권을 양보하는" 헬퍼 함수를 만들어 사용합니다.


``` js
// 제어권을 브라우저에 잠시 넘겨주는 헬퍼 함수
function yieldToMain() {
  return new Promise(resolve => {
    setTimeout(resolve, 0);
  });
}

myButton.addEventListener('click', async () => { // 이벤트 핸들러를 async로 변경
  console.log('클릭 이벤트 시작!');
  
  doHeavyTask1();
  await yieldToMain(); // 여기서 잠시 멈추고 브라우저에 제어권 양보

  doHeavyTask2();
  await yieldToMain(); // 또 양보

  doHeavyTask3();
  console.log('모든 작업 완료!');
});
```

- **장점:** 동기 코드처럼 보여 가독성이 매우 좋습니다. 순차적인 로직을 유지하면서 태스크를 분할할 수 있습니다.
- **단점:** `async/await` 문법에 대한 이해가 필요합니다.

---

### 방법 3: 루프(Loop) 안의 긴 작업 분할하기 (가장 실용적인 예제)

수천 개의 데이터를 처리하는 루프가 가장 흔한 Long Task의 원인입니다. 이 루프를 작은 덩어리(chunk)로 나누어 처리하는 것이 핵심입니다.

**❌ 나쁜 예: 전체 루프를 한 번에 실행**

``` js
function processAll(hugeArray) {
  for (let i = 0; i < hugeArray.length; i++) {
    // 매우 복잡하고 무거운 작업
    processItem(hugeArray[i]); 
  }
}

myButton.addEventListener('click', () => {
  processAll(myHugeArray); // 배열이 크면 UI가 멈춤
});
```

**✅ 좋은 예: 루프를 작은 덩어리로 나누어 처리**

``` js
const CHUNK_SIZE = 100; // 한 번에 처리할 작업량

async function processArrayInChunks(hugeArray) {
  let index = 0;
  
  function doChunk() {
    const start = index;
    const end = Math.min(index + CHUNK_SIZE, hugeArray.length);

    for (let i = start; i < end; i++) {
      processItem(hugeArray[i]);
    }

    index = end;

    // 아직 처리할 데이터가 남았다면, 다음 chunk를 예약
    if (index < hugeArray.length) {
      setTimeout(doChunk, 0); // 다음 작업을 위해 제어권 양보
    } else {
      console.log('모든 데이터 처리 완료!');
    }
  }

  // 첫 번째 chunk 실행 시작
  doChunk();
}

myButton.addEventListener('click', () => {
  processArrayInChunks(myHugeArray);
});
```

이 방식은 **점진적 렌더링(Progressive Rendering)**을 가능하게 합니다. 100개 처리하고 화면 한 번 업데이트, 또 100개 처리하고 화면 업데이트하는 식으로 사용자에게 처리 과정을 시각적으로 보여줄 수도 있습니다.

### 방법 4: `requestIdleCallback` (실험적 기능)

이 API는 브라우저가 정말로 한가할 때 (Idle 상태일 때) 콜백 함수를 실행시켜 줍니다. 중요하지 않은 백그라운드 작업(예: 로그 전송)에 적합합니다.


``` js
function doLowPriorityTask() {
  // ...
}

requestIdleCallback(() => {
  doLowPriorityTask();
});
```

- **주의:** 모든 브라우저에서 지원하지 않으며, 콜백이 언제 실행될지 보장할 수 없으므로 긴급하거나 중요한 작업에는 사용하면 안 됩니다.

### 최종 정리 및 추천

|방법|추천 상황|장점|단점|
|---|---|---|---|
|**`async/await` + Helper**|**가장 일반적으로 추천.** 순차적 로직을 유지해야 할 때.|**가독성이 매우 높음**, 제어가 쉬움.|`async/await` 문법 필요.|
|**루프 Chunk 처리**|**대용량 데이터/배열 처리** 시 필수.|UI 블로킹 방지에 가장 효과적, 점진적 렌더링 가능.|코드 구조가 다소 복잡해짐.|
|`setTimeout(callback, 0)`|간단한 분리가 필요하거나 레거시 환경일 때.|간단함.|콜백 지옥, 복잡한 로직에 부적합.|
|`requestIdleCallback`|중요도가 매우 낮은 백그라운드 작업.|브라우저 유휴 시간을 활용하여 성능 영향 최소화.|실행 시점 불확실, 지원 브라우저 제한.|

**결론적으로, `async/await`와 헬퍼 함수를 이용해 로직의 흐름을 분리하고, 특히 긴 루프가 있다면 Chunk 단위로 쪼개는 것이 현대적인 웹 개발에서 Long Task를 해결하는 가장 효과적인 방법입니다.**