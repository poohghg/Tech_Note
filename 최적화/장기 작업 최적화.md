> 참조
> 
> https://web.dev/articles/optimize-long-tasks?utm_source=devtools&utm_campaign=stable&hl=ko

> 기본 스레드는 한 번에 하나의 작업만 처리할 수 있습니다. 50밀리초 이상 걸리는 작업은 _긴 작업_입니다. 50밀리초를 초과하는 작업의 경우 작업의 총 시간에서 50밀리초를 뺀 값을 작업의 _차단 기간_이라고 합니다.
> 
> 브라우저는 길이가 다른 작업이 실행되는 동안 상호작용이 발생하는 것을 차단하지만 작업이 너무 오래 실행되지 않는 한 사용자는 이를 감지할 수 없습니다. 하지만 긴 작업이 많은 상황에서 사용자가 페이지와 상호작용하려고 하면 사용자 인터페이스가 응답하지 않는 것처럼 느껴지고, 기본 스레드가 매우 오랫동안 차단되면 깨진 것처럼 보일 수도 있습니다.

![[Pasted image 20250804034631.png]]

### 메인 스레드 (Main Thread): 모든 일의 중심

브라우저 중심에는 **메인 스레드**가 있다. 이 스레드는 다음과 같은 매우 중요한 작업들을 **순차적으로(한 번에 하나씩)** 처리한다.

- **JavaScript 실행:** 우리가 작성한 대부분의 코드(클릭 이벤트 핸들러, `useEffect`, 데이터 처리 등)가 여기서 실행됩니다.
- **DOM 파싱 및 조작:** HTML을 파싱하여 DOM 트리를 만들고, JavaScript로 DOM을 변경하는 작업을 수행합니다.
- **CSS 파싱 및 스타일 계산:** CSS를 파싱하여 CSSOM 트리를 만들고, 각 DOM 요소에 어떤 스타일이 적용될지 계산합니다.
- **레이아웃 (Layout/Reflow):** 각 요소가 화면 어디에, 어떤 크기로 배치될지 계산합니다.
- **페인트 (Paint):** 계산된 정보를 바탕으로 각 요소를 화면에 그릴 준비(레이어 생성 등)를 합니다.

**가장 중요한 점:** 이 모든 작업이 **하나의 줄**에서 처리되기 때문에, 만약 JavaScript 실행(Long Task)이 200ms 동안 스레드를 점유하면, 그 시간 동안 다른 모든 작업(레이아웃, 페인트, 다른 이벤트 처리)은 **완전히 멈춥니다.** 이것이 바로 '렌더링 블로킹'의 근본적인 원인입니다.

### 왜 이렇게 설계되었을까? (동시성 문제 방지)

만약 자바스크립트 실행과 렌더링이 서로 다른 스레드에서 동시에 일어난다고 상상해 보세요.

- **자바스크립트 스레드:** "이 버튼을 DOM에서 제거해!" (`button.remove()`)
- **렌더링 스레드:** "이 버튼의 색을 파란색으로 칠해!" (`button.style.color = 'blue'`)

이 두 명령이 동시에 실행되면 브라우저는 혼란에 빠집니다. 이미 사라진 버튼에 색을 칠하려고 시도하면서 에러가 발생할 수 있습니다. 이런 **동시성(Concurrency) 문제**를 원천적으로 차단하고 DOM 조작을 예측 가능하고 안전하게 만들기 위해, 이 작업들은 하나의 메인 스레드에서 순서대로 처리되도록 설계되었습니다.

### 다른 스레드들의 역할 (브라우저의 조력자들)

- **워커 스레드 (Worker Threads):**
    - **역할:** 메인 스레드와 완전히 분리된 공간에서 순수하게 무거운 JavaScript 연산을 처리합니다.
    - **예시:** 거대한 JSON 데이터 파싱, 복잡한 수학 계산, 데이터 암호화 등.
    - **장점:** 워커 스레드에서 아무리 오래 걸리는 작업을 해도 메인 스레드는 영향을 받지 않으므로 UI가 멈추지 않습니다.
    - **주의:** 워커 스레드는 DOM에 직접 접근할 수 없으며, `postMessage`를 통해 메인 스레드와 통신해야 합니다.
- **컴포지터 스레드 (Compositor Thread):**
    - **역할:** 메인 스레드가 페인트(Paint) 단계를 통해 생성한 여러 레이어(Layers)를 받아, 이를 합성(Composite)하여 실제 화면에 표시하는 역할을 합니다.
    - **특징:** `transform`, `opacity` 같은 속성은 레이아웃과 페인트를 건너뛰고 이 컴포지터 스레드에서 직접 처리됩니다. 이것이 이 속성들을 사용한 애니메이션이 매우 부드러운 이유입니다. 메인 스레드가 바쁘더라도 컴포지터 스레드는 독립적으로 화면을 업데이트할 수 있습니다.
- **네트워크 스레드 (Network Thread):**
    - **역할:** 이미지, API 데이터 등 모든 네트워크 요청을 처리합니다.

### 최종 요약

| 스레드 종류       | 주요 역할                                  | 개발자와의 관련성                                                 |
| ------------ | -------------------------------------- | --------------------------------------------------------- |
| **메인 스레드**   | **JS 실행, DOM, CSS, 레이아웃, 페인트**         | **가장 중요.** 우리가 작성하는 대부분의 코드가 여기서 동작하며, 성능 병목의 주된 원인이 됨.   |
| **워커 스레드**   | 무거운 JS 연산 처리                           | Long Task를 분리하여 메인 스레드의 부담을 덜어줄 때 `Web Worker`를 통해 직접 사용. |
| **컴포지터 스레드** | 레이어 합성, 스크롤, `transform/opacity` 애니메이션 | 성능 최적화를 위해 `transform/opacity`를 사용하면 이 스레드의 도움을 받음.       |
| **네트워크 스레드** | 리소스 다운로드 및 업로드                         | 직접 제어하진 않지만, 네트워크 요청이 완료되면 그 결과 처리는 메인 스레드에서 이루어짐.        |

 **"브라우저는 멀티 스레드로 동작하지만, JS 코드와 렌더링은 하나의 메인 스레드 위에서 경쟁하는 관계다"** 
 
---
### 1.FPS란 무엇인가?

**FPS**는 **Frames Per Second**의 약자로, 우리말로 하면 **"초당 프레임 수"** 입니다.

우리가 보는 모든 영상(영화, 게임, 웹 애니메이션)은 사실 연속된 정지 이미지(프레임)를 매우 빠르게 보여줌으로써 움직이는 것처럼 보이게 하는 원리입니다.

- **1fps:** 1초에 1장의 이미지를 보여줍니다. (움직임이 뚝뚝 끊겨 보임)
- **30fps:** 1초에 30장의 이미지를 보여줍니다. (일반적인 영상, 어느 정도 부드러움)
- **60fps:** 1초에 60장의 이미지를 보여줍니다. (매우 부드러운 움직임)

**비유: 플립북 (Flipbook)** 어릴 때 교과서 귀퉁이에 그림을 그려 빠르게 넘기면 만화처럼 보이던 것을 생각하시면 됩니다.

- **플립북의 각 페이지 한 장 한 장** = **프레임(Frame)**
- **1초 동안 얼마나 많은 페이지를 넘기는가** = **FPS**

60fps는 1초에 60장의 페이지를 부드럽게 넘기는 것과 같습니다.

### 2. 왜 하필 '60'fps가 중요한가?

대부분의 현대적인 모니터, 스마트폰 화면의 **주사율(Refresh Rate)이 60Hz**이기 때문입니다.

- **주사율 (Hz):** 디스플레이가 1초에 화면을 몇 번이나 새로 고칠 수 있는지를 나타내는 물리적인 성능입니다. 60Hz는 1초에 60번 화면을 깜빡이며 새 그림으로 업데이트합니다.

**브라우저의 목표:** 화면이 새로고침될 때마다, 그 타이밍에 맞춰 새로운 프레임을 그려서 전달하는 것.

만약 브라우저가 이 60Hz 주사율에 맞춰 1초에 60개의 새로운 프레임을 꾸준히 만들어내지 못하면, 화면은 이전 프레임을 한 번 더 보여주게 됩니다. 이것이 우리 눈에는 **버벅거림(Stutter) 또는 렉(Lag)**으로 느껴집니다.

### 3. "16.67ms의 마법" - 렌더링의 시간 예산

이것이 가장 중요한 핵심입니다. 60fps를 달성하기 위해 브라우저가 하나의 프레임을 만드는 데 허용된 시간은 얼마일까요?

> **1초 / 60 프레임 = 1000밀리초(ms) / 60 프레임 ≈ 16.67ms/프레임**

즉, 브라우저는 **단 16.67ms 안에** 다음 프레임을 그리는 데 필요한 모든 작업을 끝내야 합니다. 이 시간을 **'프레임 예산(Frame Budget)'** 이라고 부릅니다.

이 16.67ms 안에 브라우저는 다음과 같은 일들을 처리해야 합니다.

1. **JavaScript 실행:** 이벤트 핸들러, 애니메이션 로직 등 모든 자바스크립트 코드를 실행합니다.
2. **스타일 계산 (Style):** 어떤 CSS 규칙이 어떤 DOM 요소에 적용될지 계산합니다.
3. **레이아웃 (Layout):** 각 요소의 크기와 위치를 계산합니다.
4. **페인트 (Paint):** 각 요소를 픽셀로 변환하기 위해 레이어를 만듭니다.
5. **합성 (Composite):** 생성된 레이어들을 순서대로 합쳐 최종 화면을 만듭니다.

### 4. 프레임 드랍 (Frame Drop): 16.67ms를 초과했을 때

만약 위 5가지 작업의 총합이 16.67ms를 초과하면 어떻게 될까요?

- 예를 들어, 자바스크립트 실행(Long Task)에만 30ms가 걸렸다고 가정해 봅시다.
- 브라우저는 16.67ms가 되는 시점에 새 프레임을 화면에 전달해야 하지만, 아직 작업이 끝나지 않았습니다.
- **결국 브라우저는 새 프레임을 만드는 것을 포기하고, 이전 프레임을 한 번 더 보여줍니다.**
- 이것을 **프레임 드랍(Frame Drop)** 또는 **쟁크(Jank)**라고 부릅니다.

**시각적 설명:**

**✅ 60fps (성공적인 경우)**

Code

```
프레임 1 (16.7ms)  프레임 2 (16.7ms)  프레임 3 (16.7ms)
|------------------|------------------|------------------|
```

**❌ 프레임 드랍 (실패한 경우)**

Code

```
      프레임 1 (30ms 소요)        프레임 2 (16.7ms)
|------------------------------|------------------|
      ↑                          ↑
(여기서 보여줬어야 할 프레임 누락)  (여기서 프레임 1이 한 번 더 보임)
```

사용자는 이 누락된 구간에서 애니메이션이 순간적으로 멈추거나 버벅이는 것을 느끼게 됩니다.

### 최종 요약

- **60fps는** 1초에 60개의 프레임을 그려내어 사용자에게 가장 부드러운 시각적 경험을 제공하는 것을 목표로 하는 성능 지표입니다.
- 이를 달성하려면, 브라우저는 **하나의 프레임을 16.67ms 안에** 그려야 합니다.
- 만약 자바스크립트 실행, 렌더링 등의 작업이 이 **16.67ms라는 시간 예산을 초과**하면 **프레임 드랍(쟁크)**이 발생하여 사용자는 버벅거림을 느끼게 됩니다.

따라서 프론트엔드 성능 최적화란, 결국 **"어떻게든 모든 작업을 16.67ms 안에 끝낼 것인가?"** 라는 질문에 대한 해답을 찾아가는 과정이라고 할 수 있습니다.