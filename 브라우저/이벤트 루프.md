> 참조
> 
> https://wikidocs.net/156323

브라우저는 js 코드를 실행하는 것 외에도, 다양한 작업(테스크)을 처리한다. 화면을 렌더링하고, dom의 이벤트를 관리하고, callback 과 promise를 적절한 시점에 실행되도록 하는 일 등은 전부 브라우저과 관리한다. 이런 작업을 테스트라고 하며, 테스크들은 순서대로 테스크 큐에 담겨서 실핸된다.

### Task란?

태스크는 이벤트나 콜백 등의 작업을 수행하는 알고리즘을 담은 객체이다. 태스크는 이벤트나 파싱, 콜백 등을 담당하는 작업의 한 단위이다. 태스크는 태스크 큐에서 오래된 순으로 선택되어 실행 되므로, 태스크가 생겨나는 것은 태스크 큐에 적재(enqueue) 된다는 것이다. 태스트가 큐에 담기는 경우는 아래와 같다.
1. 새로운 js 프로그램이 `<script>` 요소나 콘솔 등에서 실행되는 경우
2. 이벤트가 발생하여 이벤트의 콜백 함수가 태스크 큐에 적재되는 경우
3. `setTimeout`이나 `setInterval` 등의 타이머 함수가 실행되어 태스크 큐에 적재되는 경우`


> The steps to prepare to run script with an [environment settings object](https://html.spec.whatwg.org/#environment-settings-object) settings are as follows:
> 
> 1. Push settings's [realm execution context](https://html.spec.whatwg.org/#realm-execution-context) onto the [JavaScript execution context stack](https://tc39.es/ecma262/#execution-context-stack); it is now the [running JavaScript execution context](https://tc39.es/ecma262/#running-execution-context).
> 
> To prepare to run a callback with an [environment settings object](https://html.spec.whatwg.org/#environment-settings-object)settings:
> 
> 2. Push settings onto the [backup incumbent settings object stack](https://html.spec.whatwg.org/#backup-incumbent-settings-object-stack).
> 3. Let context be the [topmost script-having execution context](https://html.spec.whatwg.org/#topmost-script-having-execution-context).
> 
> 8.1.5.3.1 HostCallJobCallback(callback, V, argumentsList)
> 
> If script execution context is not null, then [push](https://infra.spec.whatwg.org/#stack-push) script execution context onto the [JavaScript execution context stack](https://tc39.es/ecma262/#execution-context-stack).

- 명세의 내용
1. 스크립트를 실행할 준비를 하기 위한 단계는 다음과 같다.
2. 설정의 realm 실행 컨텍스트를 JavaScript 실행 컨텍스트 스택에 푸시한다. 이제 실행중인 JavaScript 실행 컨텍스트가 된다.
3. 환경 설정 객체 settings로 콜백을 실행할 준비를 하기 위한 단계는 다음과 같다.
4. 설정을 백업 임원 설정 객체 스택에 푸시한다.
5. context를 최상위 스크립트 실행 컨텍스트로 한다.
6. 만약 스크립트 실행 컨텍스트가 null이 아니라면, 스크립트 실행 컨텍스트를 JavaScript 실행 컨텍스트 스택에 푸시한다.

브라우저가 담당하는 태스크들을 서로 다른 간격으로 실행되어야 한다. 예를 들어 JS를 실행하는 태스크는 가능한 한 쉼없이 실행해야 하지만, 브라우저 렌더링은 초당 60번 정도면 충분하다. 자바스크립트 태스크들을 실행하고, setTimeout() 과 setInterval() 등이 예약한 콜백 함수를 시간에 맞게 태스크 큐에 추가하고, 비동기 함수와 requestAnimationFrame 콜백 함수를 실행하고, 바뀐 DOM을 반영해서 렌더링을 하는 복잡한 상황을 일관되게 처리할 수 있도록 정의하는 규칙이 필요하다.

---
### 이벤트 루프의 규칙

`이벤트 루프`는 브라우저의 탭 하나가 열릴 때 부터 닫힐 때까지, 브라우저가 실행하는 모든 태스크가 실행되는 순서를 제어한다. 이러한 표준 덕분에 브라우저는 다양한 이벤트와 태스크를 일관된 규칙에 따라 실행하며, 개발자는 예측 가능하게 실행되는 코드를 작성 할 수 있다.

> [https://html.spec.whatwg.org/#definitions-3](https://html.spec.whatwg.org/#definitions-3) 8.1.6.1 Definitions To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section.
> 
> [https://html.spec.whatwg.org/#event-loop-processing-model](https://html.spec.whatwg.org/#event-loop-processing-model)
> 
> An [event loop](https://html.spec.whatwg.org/#event-loop) must continually run through the following steps for as long as it exists: (...)

- 명세의 내용
- 이벤트 루프는 이벤트, 사용자 상호작용, 스크립트, 렌더링, 네트워킹 등을 조정하기 위해 사용자 에이전트가 이 섹션에서 설명하는 이벤트 루프를 사용해야 한다.
---
### 이벤트 루프의 주요 순서

1. Task queue에 있는 가장 오래된 태스크를 실행한다.
2. Microtask Checkpoint를 실행한다.
3. 필요 시, 렌더링을 실행한다.
	1. resize, scroll, input, DOM mutation 등의 이벤트가 발생하면 렌더링이 실행된다.
	2. animation frame callbacks 실행 (requestAnimationFrame으로 추가된 callback을 말함)
	3. update intersection observation steps 실행
	4. 화면 업데이트

- Microtask Checkpoint 실행은 Microtask Queue에 담긴 Microtask를 실행하는 것으로, 규칙은 아래와 같다.
1. “perfoming a microtask checkpoint” 변수가 false이면 계속한다.
2. “perfoming a microtask checkpoint”를 참으로 한다.
3. 이벤트 루프의 마이크로태스크 큐가 빌 때까지:
    1. 마이크로태스크 큐의 가장 오래된 마이크로태스크를 실행한다.
    2. 이 때, 실행 중인 마이크로태스크가 콜백을 실행하는 경우, Microtask Checkpoint가 실행되는데, 이 때에는 “perfoming a microtask checkpoint”가 이미 참이기 때문에, 이 반복문이 2중으로 실행되는 것을 방지한다.
- 요약하자면 마이크로태스크 큐가 빌 때까지 마이크로태스크를 실행하고, 이 때 실행 중인 마이크로태스크가 콜백을 실행하는 경우, Microtask Checkpoint가 실행된다.
---
### Microtask

Microtask queue는 Promise, Observer, MutationObserver, process.nextTick 등이 추가한 태스크를 말한다. Microtask queue의 Task는 일반 Task보다 먼저 실행되며, 일반 Task가 실행되기 전에 Microtask가 모두 실행된다. 

> A microtask is a colloquial way of referring to a [task](https://html.spec.whatwg.org/#concept-task) that was created via the [queue a microtask](https://html.spec.whatwg.org/#queue-a-microtask) algorithm.

- 명세의 내용
- 마이크로태스크는 queue a microtask 알고리즘을 통해 생성된 태스크를 가리키는 비공식적인 용어이다.

태스크와 마이크로태스크는 사실상 같은 반면, 아래의 명세에서는 마이크로태스크 큐는 태스크 큐와 다름을 밝히고 있다.

> [https://html.spec.whatwg.org/#definitions-3](https://html.spec.whatwg.org/#definitions-3) 
> The [microtask queue](https://html.spec.whatwg.org/#microtask-queue) is not a [task queue](https://html.spec.whatwg.org/#task-queue).

이 떄문에, 특정한 상황에서 마이크로태스크는 마이크로태스크 큐에서 태스크 큐로 이동될 수 있다.

queueMicrotask() 함수를 사용하면 마이크로태스크를 생성할 수 있다. 태스크나 Microtask queue 실행 중에 이 함수를 호출하면, Microtask queue의 맨 끝에 해당 작업을 추가한다.

---
### requestAnimationFrame

 requestAnimationFrame은 브라우저에게 다음 렌더링이 실행될 때 콜백 함수를 실행 하라고 요청하는 함수이다. 이 함수는 브라우저가 다음 렌더링을 실행하기 직전에 실행 되며, 이 때 콜백 함수는 렌더링이 실행되기 전에 실행된다.

- 테스크 실행과 렌더링은 따로 실행된다. 브라우저는 60Hz의 주사율을 맞추기 때문에 렌더링이 매 루프마다 실행될 필요가 없다.
- 일반적으로 테스크가 빨리 실행되는 것이 목표이기에 렌더링까지 고려하지 않는다. 하지만 애니메이션, 등 화면 효과와 관련된 코드, 혹은 상태를 읽어오는 코드는 화면이 렌더링되는 시점에 맞추어 실행되어야 한다.
- requestAnimationFrame 함수는 이러한 이유로 존재한다. requestAnimationFrame에 등록된 콜백 함수들은 화면이 렌더링되기 직전에 실행된다. 또한 추가된 콜백은 cancelAnimationFrame 함수로 취소할 수 있다.

일반적인 태스크나 마이크로태스크는 각각 task queue, microtask queue에 저장되었다가 하나씩 실행되는데,
requestAnimationFrame로 추가된 콜백함수는 animation frame callbacks라는 큐에 저장되었다가 실행된다.
- 순서는 다음과 같다.
- resize, scroll등의 이벤트가 실행된 후

