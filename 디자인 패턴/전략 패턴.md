**전략 패턴**은 객체 지향 디자인 패턴 중 하나로, **행위 패턴(Behavioral Pattern)**에 속합니다. 이 패턴의 핵심 아이디어는 다음과 같습니다:

> **알고리즘(전략)군을 정의하고, 각 알고리즘을 캡슐화하여, 이들을 서로 교체 가능하게 만듭니다. 전략 패턴을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있습니다.**

조금 더 풀어서 설명하면, 어떤 작업을 수행하는 데 있어 여러 가지 방법(전략)이 있을 때, 각 방법을 별도의 클래스로 만들어 놓고, 상황에 따라 원하는 방법(클래스 인스턴스)을 선택하여 사용할 수 있도록 하는 디자인 패턴입니다.

**주요 구성 요소:**

1. **Context (문맥):**
    - 전략을 사용하는 주체입니다.
    - 내부에 구체적인 전략(Concrete Strategy) 객체에 대한 참조를 유지합니다.
    - 클라이언트는 Context를 통해 특정 작업을 요청합니다. Context는 실제 작업 수행을 현재 참조하고 있는 전략 객체에게 위임합니다.
    - Context는 구체적인 전략 클래스의 세부 구현을 알지 못하며, 오직 Strategy 인터페이스하고만 소통합니다.
    - 필요에 따라 동적으로 전략을 변경할 수 있는 메서드(예: `setStrategy`)를 제공할 수 있습니다.
2. **Strategy (전략 인터페이스 또는 추상 클래스):**
    - 모든 구체적인 전략 클래스들이 구현해야 하는 공통 인터페이스(메서드 시그니처)를 정의합니다.
    - Context는 이 인터페이스를 통해 구체적인 전략 객체의 메서드를 호출합니다.
3. **Concrete Strategy (구체적인 전략):**
    - Strategy 인터페이스를 구현하는 실제 클래스들입니다.
    - 각 클래스는 특정 알고리즘 또는 행동 방식을 캡슐화합니다.
    - 예를 들어, `SortStrategy` 인터페이스가 있다면 `BubbleSortStrategy`, `QuickSortStrategy`, `MergeSortStrategy` 등이 Concrete Strategy가 될 수 있습니다.

**동작 방식:**

1. 클라이언트는 특정 전략을 수행할 Context 객체를 생성합니다.
2. 클라이언트는 Context에게 사용할 구체적인 전략(Concrete Strategy 인스턴스)을 설정합니다. (생성 시 주입하거나, 별도 메서드로 설정)
3. 클라이언트가 Context에게 작업을 요청합니다.
4. Context는 자신이 참조하고 있는 Strategy 객체에게 해당 작업 수행을 위임(메서드 호출)합니다.
5. 선택된 Concrete Strategy 객체가 실제 알고리즘을 실행합니다.

**예시 시나리오 (결제 시스템):**

- **Context:** `ShoppingCart` (장바구니) - 결제 기능 필요
- **Strategy Interface:** `PaymentStrategy` - `pay(amount)` 메서드 정의
- **Concrete Strategies:**
    - `CreditCardPaymentStrategy` - `pay` 메서드에 신용카드 결제 로직 구현
    - `PayPalPaymentStrategy` - `pay` 메서드에 PayPal 결제 로직 구현
    - `BankTransferStrategy` - `pay` 메서드에 계좌 이체 로직 구현

사용자는 장바구니(Context)에서 결제 방법을 선택(Strategy 설정)하고 결제(Context의 작업 요청)를 진행하면, 장바구니는 선택된 결제 방법(Concrete Strategy)의 `pay` 메서드를 호출하여 실제 결제를 처리합니다.

**장점:**

1. **개방-폐쇄 원칙 (OCP):** 기존 Context 코드를 수정하지 않고 새로운 전략(알고리즘)을 쉽게 추가할 수 있습니다. (확장에는 열려 있고, 수정에는 닫혀 있음)
2. **조건문 감소:** Context 내부에 알고리즘 선택을 위한 복잡한 `if-else` 나 `switch` 문을 제거하고, 각 전략을 별도의 클래스로 분리하여 코드를 더 깔끔하고 관리하기 쉽게 만듭니다.
3. **전략 교체 용이:** 런타임(실행 중)에도 Context가 사용하는 전략을 쉽게 변경할 수 있습니다.
4. **관심사 분리:** Context는 "무엇을 할지"(작업 요청)에 집중하고, Concrete Strategy는 "어떻게 할지"(구체적인 알고리즘 구현)에 집중하여 역할 분담이 명확해집니다.
5. **테스트 용이성:** 각 전략 클래스를 독립적으로 테스트하기 용이합니다.

**단점:**

1. **클래스 수 증가:** 각 전략마다 별도의 클래스가 필요하므로, 전략의 수가 많아지면 전체 클래스 수가 늘어날 수 있습니다.
2. **약간의 오버헤드:** Context와 Strategy 객체 간의 간접적인 통신으로 인해 아주 약간의 성능 오버헤드가 발생할 수 있습니다. (대부분의 경우 무시 가능)
3. **클라이언트의 책임 증가:** 클라이언트는 어떤 전략이 있는지 알고, 상황에 맞는 적절한 전략 객체를 선택하여 Context에 제공해야 할 수 있습니다.

**결론적으로, 전략 패턴은 동일한 문제를 해결하는 여러 알고리즘이나 행동 방식이 있고, 이들을 캡슐화하여 클라이언트가 실행 중에 선택하거나 교체할 수 있도록 하고 싶을 때 매우 유용한 디자인 패턴입니다.**