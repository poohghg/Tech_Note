> 참조
> 
> https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)
> https://tech.kakaobank.com/posts/2411-solid-truth-or-myths-for-developers/
> https://fe-developers.kakaoent.com/2023/230330-frontend-solid/

## SOLID 원칙의 중요성 

SOLID 원칙은 함수와 데이터 구조를 효과적으로 결합하고, 이 집합들을 서로 유기적으로 연결하는 방법을 제시한다. SOLID 원칙의 핵심은 다음과 같은 소프트웨어 구조를 만드는데 있다.

1. 변경에 유연한 구조
	- `변경에 유연하다.`는 곧 결합도는 낮고, 응집도는 높은 구조를 의미한다.
	- 만약에 시스템에 작은 기능의 추가가 수십 개의 테스트가 깨질 만큼 복잡하다면, 기능을 추가하는 작업이 어려울 것이다.
2. 이해하기 쉬운 구조
	- `이해하기 쉽다.`는 곧 가독성이 좋다는 표현이다.
	- 깔금한 코드는 디버깅과 유지보수성를 쉽게 만들어 소프트웨어 품질 향상에 기여한다.

> 추상화란?
> 복잡한 내부 동작이나 세부 구현을 숨기고, 꼭 필요한 개념/기능만을 외부에 제공하는 것이다.
> 
> 추상화는 복잡한 시스템에서 핵심적인 부분만을 추출하여 단순화하는 과정이다. 이를 통해 개발자는 복잡한 세부 사항을 숨기고, 중요한 개념에 집중할 수 있다. 추상화는 객체 지향 프로그래밍에서 중요한 역할을 하며, 인터페이스와 추상 클래스를 통해 구현된다.
> 
> - 사용자는 단순한 인턴페이스를 보고 사용
> - 복잡한 내부 구현은 캡슐화
> - 추상화는 **복잡성을 줄이고** 코드의 **유연성과 재사용성**을 높여줌.

> 추상화에서 생각해야할 부분?
> 추상화는 SOLID 원칙의 핵심 요소이다. 추상화를 통해 모듈은 추상화에 의존하고, 추상화는 모듈에 의존하지 않도록 설계되어야 한다. 이는 모듈의 확장성과 변경 용이성을 높이는 데 중요한 역할을 한다.
> 
> **변하는 것과 변하지 않는 것**을 분리 
> 변하는 것과 변하지 않는 것을 분리하는 것은 소프트웨어 설계의 핵심 원칙 중 하나이다. 변하지 않는 부분은 안전성을 제공하고, 변하는 부분은 유연성을 제공한다. 이를 통해 소프트웨어는 변경에 강하고, 유지보수가 용이한 구조를 갖출 수 있다.
> 
> 특정 기능에 종속되지 않고 **여러 곳에서 재사용 가능**하도록 설계 (인자로 받기))
> 
> 1. 의도적으로 드러내기: 코드의 의도를 명확하게 드러내는 것이 중요하다. 함수나 클래스의 이름, 변수명 등을 통해 코드가 무엇을 하는지 쉽게 이해할 수 있도록 해야 한다.(필수적인 맥락을 인자로 받기)
> 2. 변경 가능성이 높은 부분을 추상화: 변경 가능성이 높은 부분을 추상화하여, 변경이 필요할 때 해당 부분만 수정하면 되도록 한다. 이를 통해 코드의 유지보수성을 높일 수 있다.
> 3. 재사용성을 해치 않는 선에서 추상화: 추상화는 재사용성을 높이는 데 도움이 되지만, 지나친 추상화는 오히려 코드를 복잡하게 만들 수 있다. 따라서 재사용성을 해치지 않는 선에서 적절한 수준의 추상화를 유지하는 것이 중요하다.


결합도가 낮고 응집도가 높으며 가독성이 좋은 코드를 작성하는 것이 모든 소프트웨어 설계가 추구하는 궁극적인 지향점이다. 이를 통해 유연하고 유지보수하기 쉬운 소프트웨어를 개발할 수 있다.
## Single Responsibility Principle(단일 책임 원칙)

- SRP의 최종 버전은 다음과 같다. 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
- 한 객체는 하나의 책임만 가져야 한다.
	- 책임 = 변경의 이유
	- 하지만 각자가 생각하기에 책임의 범위는 항상 동일하지 않는다.
	- `책임`이라는 단어는 매우 주관적인 개념이다.
	- `단일 모듈은` 변경의 이유가 하나, 오직 하나뿐이여야 한다.
- 변경의 이유가 하나라고 정의함으로써 객관적으로 변경점 파악이 가능해진다.
	- 서로 다른 책임을 분리하면 응집도가 높아지고, 결합도가 낮아진다.
	- 이는 가독성과 재사용성이 높아지고 유지보수가 쉬워진다.

## Open-Closed Principle(개방-폐쇄 원칙)

OCP는 소프트웨어 엔티티가 확장에는 열러 있어야 하지만 변경에는 닫혀 있어야 한다는 원칙이다. 여기서 `변경`이란 기존의 코드베이스를 수정하는 것을 의미한다.

따라서 새로운 메서드를 추가할 때 기존 코드나 인터페이스를 수정하지 않고 새로운 인터페이스나 클래스를 생성하는것은 OCP를 준수하는 것이다.

그러나 기존의 인터페이스를 변경하거나 기존 구현을 수정해야 한다면 이는 OCP를 위반하는 것이다. 예를 들어, 기존 인터페이스에 새로운 메서드를 추가하면 이를 구현하는 모든 클래스들이 이 새로운 메서드를 구현해야 하므로 기존 코드를 수정해야 한다.

OCP를 준수하는 법칙
1. 새로운 인터페이스 생성: 기존 인터페이스를 수정하지 않고 새로운 인터페이스를 생성하여 필요한 메서드를 추가한다.
2. 기존 클래스를 확장: 기존 클래스를 확장하여 새로운 메서드를 추가한다.

- 확장에 열려 있고, 변경에는 닫혀있어야 한다.
	- 새로운 기능을 추가할 때 기존의 코드를 변경하지 않아야 한다.
- 확장에 대해 열려 있다.
	- 모듈의 동작을 확장할 수 있다는 것을 의미한다. 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있었어야한다. 
	- 새로운 기능을 추가할 때 기존의 코드를 변경하지 않아야 한다.
- 수정에 닫혀 있다.
	- 모듈의 코드를 수정하지 않고도 모듈의 기능을 확장하거나 변경할 수 있다. 즉 모듈의 기존 코드를 수정하지 않는다.
	- 기존의 인터페이스, 기존 구체화된 코드를 수정하지 않고 새로운 기능을 추가할 수 있어야 한다.
- 추상화는 OCP의 핵심요소이다.
	- 모듈은 추상화를 조작할 수 있다. 모듈은 추상화에 의존하며, 추상화는 모듈에 의존하지 않는다.
	- 반대로 추상화의 새로운 기능을 만든는 것을 통해 확장이 가능하다.

``` ts

// OCP

interface Shape {
  area(): number;
}

// 새로운 도형을 추가할 때, AreaCalculator 클래스를 수정하지 않아도 된다.
// 확장에 열려 있다.

class Circle implements Shape {
  constructor(private radius: number) {}

  area() {
    return this.radius ** 2 * Math.PI;
  }
}

class Square implements Shape {
  constructor(private width: number) {}

  area() {
    return this.width ** 2;
  }
}

class AreaCalculator {
  constructor(private shapes: Shape[]) {}

  sum() {
    return this.shapes.reduce((acc, shape) => acc + shape.area(), 0);
  }
}

const shapes = [new Circle(5), new Square(4)];

const calculator = new AreaCalculator(shapes);

```

```ts
interface Animal {
  makeSound(): void;
}

class Dog implements Animal {
  makeSound(): void {
    console.log('Woof!');
  }
}

// -> 새로운 기능을 추가하기 위해 기존 인터페이스를 수정하지 않고 새로운 인터페이스와 클래스를 생성할 수 있다.

interface Animal {
  makeSound(): void;
}

interface AdvancedAnimal extends Animal {
  doTrick(): void;
}

class Dog implements Animal {
  makeSound(): void {
    console.log('Woof!');
  }
}

class AdvancedDog extends Dog implements AdvancedAnimal {
  doTrick(): void {
    console.log('Dog does a trick!');
  }
}

```

## Liskov Substitution Principle(리스코프 치환 원칙)

> 1. 타입 T가 있습니다.  
> 2.서브타입 S가 있습니다.  
> 2. T타입으로 만든 프로그램 P가 있습니다.  
> 3. 프로그램 P에서 T를 서브타입 S로 치환합니다.  
> 4. 프로그램의 행위가 변하지 않고 정상적으로 동작한다면, S는 T의 하위타입입니다.

``` ts

class Bird {
  fly() {
    console.log("I can fly");
  }
}

class Sparrow extends Bird {
  fly() {
    console.log("Flap flap");
  }
  // Sparrow는 Bird의 하위 타입
  chirp() {
    console.log("Chirp chirp");
  }
}

class Ostrich extends Bird {
  // Ostrich는 Bird의 하위 타입이 아님
  fly() {
    throw new Error("Ostriches can't fly");
  }
}

function makeBirdFly(bird: Bird) {
  bird.fly();
}

const sparrow = new Sparrow();
makeBirdFly(sparrow); // 정상 작동

const ostrich = new Ostrich();
makeBirdFly(ostrich); // 오류 발생

```


- 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
	- 서브 타입은 기반 타입의 규약을 지켜야 한다.
	- 
- 타입을  치환해도 프로그램의 행위가 변하지 않아야한다.
- 하위 타입 구현 시, 부모 타입의 기능을 무작위로 수정하다면, 타입을 취환해서 호출하려 할 때 동작 여부를 확실할 수 없기에 서로 치환할 수 없게 된다. 따라서 LSP 원칙은 `하위타입 구현 시, 부모의 기능을 수정하면 안된다는` 원칙 이다.
	- 자식 클래스에서 부모 클래스의 메소드를 오버라이딩 할 때, 부모 클래스의 메소드가 하는 일을 변경하면 안된다.(==타입을 치환해도 프로그램의 행위가 변하지 않아야 한다.==)
	- 부모 클래스를 자식 클래스로 갈아 꼇을 때 에러가 발생한다 ? -> LSP 위반

## Interface Segregation Principle (인터페이스 분리 원칙)

-  **“사용하지 않는 것에 의존하지 않아야 한다.”**
- 인터페이스는 클라이언트에 필요한 메서드만 제공해야 한다.
	- 클라이언트가 사용하지 않는 메서드에 의존하지 않아야 한다.
- 인터페이스 분리 원칙은 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.
	- 작은 단위들을 역할 인터페이스라고도 부른다.
	- 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다.

![Pasted image 20250322012706.png](../img/Pasted%20image%2020250322012706.png)

![Pasted image 20250322012714.png](../img/Pasted%20image%2020250322012714.png)

## Dependency Inversion Principle(의존 역전 원칙)

- 상위 계층이 하위 계층에 의존하는 전통적인 의존 관계를 반전 시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다.
	- 상위 계층은 하위 계층의 구현이 아닌 추상화에 의존해야 한다.
	- 추상화는 구체화에 의존해서는 안된다.
- 고수준 모듈은 저수준 모듈에 의존해서는 안된다.
	- 둘 다 추상화에 의존해야 한다.
- **“추상화에 의존해야 하며 구체화에 의존하면 안 된다.”**
- "변동성이 큰 구현체보다 안정된 인터페이스를 참조해야 한다."
	- 인터페이스 와 구현체가 있을 때인터페이스가 수정되면 구현체도 수정해야 한다.
	- 반면 구현체가 수정되면 인터페이스는 수정하지 않아도 된다.
	- 따라서 인터페이스는 구현체보다 변동성이 낮다.
	- 즉 변동성이 큰 구현체보다 안정된 인터페이스를 참조해야한다.

![Pasted image 20250322014014.png](../img/Pasted%20image%2020250322014014.png)
- **제어흐름과 반대 방향으로 역전되는 이유**로 인해 이 원칙의 이름을 ‘의존성 역전 원칙’인 DIP라고 부른다.

![Pasted image 20250322014541.png](../img/Pasted%20image%2020250322014541.png)

> 여기서 많이 보셨을 클린 아키텍처 이미지가 있습니다. 클린 아키텍처는 양파 껍질처럼, **가장 안쪽에 변하지 않는 고수준 정책을 배치하고, 바깥쪽으로 갈수록 변동성이 큰 저수준 모듈들을 배치**합니다. 의존성은 바깥쪽에서 안쪽으로 향하고, 이렇게 하면 바깥쪽의 변화가 안쪽에 영향을 주지 않도록 할 수 있습니다. 따라서 변동성이 큰 저수준 모듈들은 바깥쪽에 자리 잡고, 이들의 변화가 안쪽으로 전파되지 않는 것이 클린 아키텍처의 핵심입니다.


1. 분리 원칙 (Separation of Concerns, SoC)

> **"하나의 모듈이 하나의 관심사만을 다루도록 분리하는 원칙"**

 2. 카테고리 이론 (Categorization)

> **"데이터를 논리적으로 그룹화하여 관리하는 방법"**