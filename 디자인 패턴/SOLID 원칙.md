> 참조
> 
> 	https://tech.kakaobank.com/posts/2411-solid-truth-or-myths-for-developers/

## SOLID 원칙의 중요성 

SOLID 원칙은 함수와 데이터 구조를 효과적으로 결합하고, 이 집합들을 서로 유기적으로 연결하는 방법을 제시한다. SOLID 원칙의 핵심은 다음과 같은 소프트웨어 구조를 만드는데 있다.

1. 변경에 유연한 구조
	- `변경에 유연하다.`는 곧 결합도는 낮고, 응집도는 높은 구조를 의미한다.
	- 만약에 시스템에 작은 기능의 추가가 수시 개의 테스트가 깨질 만큼 복잡하다면, 기능을 추가하는 작업이 어려울 것이다.
2. 이해하기 쉬운 구조
	- `이해하기 쉽다.`는 곧 가독성이 좋다는 표현이다.
	- 깔금한 코드는 디버깅과 유지보수성를 쉽게 만들어 소프트웨어 품질 향상에 기여한다.

결합도가 낮고 응집도가 높으며 가독성이 좋은 코드를 작성하는 것이 모든 소프트웨어 설계가 추구하는 궁극적인 지향점이다. 이를 통해 유연하고 유지보수하기 쉬운 소프트웨어를 개발할 수 있다.
## Single Responsibility Principle(SRP)

#### 단일 책임 원칙 이란

- 한 객체는 하나의 책임만 가져야 한다.
	- 책임 = 변경의 이유
	- 하지만 각자가 생각하기에 책임의 범위는 항상 동일하지 않는다.
	- `책임`이라는 단어는 매우 주관적인 개념이다.
	- `단일 모듈은` 변경의 이유가 하나, 오직 하나뿐이여야 한다.
- 변경의 이유가 하나라고 정의함으로써 객관적으로 변경점 파악이 가능해진다.
	- 서로 다른 책임을 분리하면 응집도가 높아지고, 결합도가 낮아진다.
	- 이는 가독성과 재사용성이 높아지고 유지보수가 쉬워진다.

## Open-Closed Principle(OCP)

- 확장에 열려 있고, 변경에는 닫혀있어야 한다.
	- 새로운 기능을 추가할 때 기존의 코드를 변경하지 않아야 한다.
- 확장에 대해 열려 있다.
	- 모듈의 동작을 확장할 수 있다는 것을 의미한다. 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있었어야한다. 즉 모듈이 하는 일을 변경할 수 있다.
- 수정에 닫혀 있다.
	- 모듈의 코드를 수정하지 않고도 모듈의 기능을 확장하거나 변경할 수 있다. 즉 모듈의 기존 코드를 수정하지 않는다.
- 추상화는 OCP의 핵심요소이다.
	- 모듈은 추상화를 조작할 수 있다. 모듈은 추상화에 의존하며, 추상화는 모듈에 의존하지 않는다.
	- 반대로 추상화의 새로운 기능을 만든는 것을 통해 확장이 가능하다.
## Liskov Substitution Principle(LSP)

> 1. 타입 T가 있습니다.  
> 2. _(정답을 미리 알려드리면)_ 서브타입 S가 있습니다.  
> 2. T타입으로 만든 프로그램 P가 있습니다.  
> 3. 프로그램 P에서 T를 서브타입 S로 치환합니다.  
> 4. 프로그램의 행위가 변하지 않고 정상적으로 동작한다면, S는 T의 하위타입입니다.

- 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
	- 서브 타입은 기반 타입의 규약을 지켜야 한다.
- 타입을  치환해도 프로그램의 행위가 변하지 않아야한다.
- 하위 타입 구현 시, 부모 타입의 기능을 무작위로 수정하다면, 타입을 취환해서 호출하려 할 때 동작 여부를 확실할 수 없기에 서로 치환할 수 없게 된다. 따라서 LSP 원칙은 `하위타입 구현 시, 부모의 기능을 수정하면 안된다는` 원칙 이다.
