> 코드베이스가 커져도 모듈화된 구조를 유지하여 재사용성과 가동성을 확보하는 것이 중요하다. 컴포넌트가 서로 얽히고 결합된 구조일수록, 유지보수와 테스트가 까다로울 뿐만 아니라 새로운 기능을 추가하거나 기존 기능을 변경하는 작업이 어려워진다. 

> 합성은 위와 같은 문제를 해결하기 위해 체계적이고 확장 가능하며 깔금한 코드베이스를 만들 수 있게 해주는 강력한 기술이다. 하나의 거대한 컴포넌트에 여러 가지 기능을 만들지 않고, 작고 다루기 편한 조각으로 분리하여 다양한 방법으로 이를 조합할 수 있다. 이러한 접근 방식은 로직을 간소화하고 재사용성을 향상시키며 관심사를 명확하게 분리 할 수 있다.

### 1. 고차 함수

> 고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수이다. 리액트에서 고차 함수는 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 패턴으로 자주 사용된다. 이를 통해 공통된 로직이나 상태 관리를 여러 컴포넌트에 쉽게 적용할 수 있다.

> 고차 컴포넌트 (Higher-Order Component, HOC)는 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 함수입니다. 이를 통해 공통된 로직이나 상태 관리를 여러 컴포넌트에 쉽게 적용할 수 있습니다.

``` tsx

const withLoading = <P extends object>(WrappedComponent: ComponentType<P>) => {  
  return (props: P & { isLoading: boolean }) => {  
    const { isLoading, ...rest } = props;  
    if (isLoading) {  
      return <div>Loading...</div>;  
    }    return <WrappedComponent {...(rest as P)} />;  
  };  
};  
```

``` tsx

const MyComponent: React.FC<{ data: string }> = ({ data }) => {  
  return <div>Data: {data}</div>;  
};  
  
const MyComponentWithLoading = withLoading(MyComponent);  
  const MyComponent: React.FC<{ data: string }> = ({ data }) => {  
  return <div>Data: {data}</div>;  
};  
  
const MyComponentWithLoading = withLoading(MyComponent);  
  
export const Test = () => {  
  return <MyComponentWithLoading isLoading={true} data="Hello, World!" />;  
};
```

![[Pasted image 20250925205016.png]]

>  객체 지향 프로그래밍에 익숙하다면 이 개념은 데코레이터 패턴과 유사하다. 구조를 변경하는 대신 객체를 감싸서 동작을 동적으로 추가하는 방법이다. 이 방식은 원래 객체의 기능을 변강하지 않고 기능을 확장 할 수 있으므로 서브클래스보다 훨씬 유연하다.

### 2. 커스텀 훅

> 훅은 상태가 있는 로직을 컴포넌트에서 분리할 수 있게 하여 독립적인 테스팅과 재사용성을 가능하게 해준다. 컴포넌트 구조를 바꾸지 않고도 상태가 있는 로직을 재사용할 수 있게 한다. 기본적으로 훅을 사용하면 함수 컴포넌트에서 리액틔 상태 또는 기타 생명주기 기능들을 연동 할 수 있다.

> 훅은 재사용이 가능한 로직을 포함하며, 컴포넌트와 분리되어 있지만 쉽게 결합할 수 있다. HOC를 통해 감싸는 접근법과 달리 훅은 플러그인 형태의 방식을 제공하여 리액트를 통해 가벼운 형태로 관리하기 쉽다. 이러한 훅은 특성은 코드 모듈화를 쉽게 해줄 뿐만 아니라, 깔금하고 직관적인 형태로 컴포넌의 기능을 확장할 수 있게 해준다.

> 훅은 다양한 기능을 제공한다. UI와 관련된 상태를 관리하는 것뿐만 아니라, 데이터를 가져오거나 페이지 단위의 전역 이벤트 핸들링 등 UI의 부수 효과를 다룰 때도 사용한다.

> 로직을 훅으로 추출하는 것은 동일한 기본 기능을 유지하면서도 다른 UI를 구현해야 할 때 유용하다. 이를 통해 상태관리와 상호작용 로직을 UI렌더링으로부터 분리할 수 았다. 로직을 재사용할 수 있을 뿐만 아니라, UI를 변경하거나 확장하는 것도 훨씬 쉬워진다.

``` tsx
import { useState, useEffect } from "react";import { fetchPost } from "./api"; // 가상의 API 함수
import { Post } from "./types"; // 가상의 타입 정의

const usePost = (id: string) => {  
  const [post, setPost] = useState<Post | null>(null);  
  const [isLoading, setIsLoading] = useState<boolean>(true);  
  const [error, setError] = useState<string | null>(null);  
  
  useEffect(() => {  
    setIsLoading(true);  
    fetchPost(id)  
      .then((data) => {  
        setPost(data);  
        setIsLoading(false);  
      })  
      .catch((err) => {  
        setError(err.message);  
        setIsLoading(false);  
      });  
  }, [id]);  
  
  return { post, isLoading, error };  
};  
  export default usePost;
```

``` tsx
import React from "react";import usePost from "./usePost"; // 위에서 만든 커스텀 훅

import { Post } from "./types"; // 가상의 타입 정의



