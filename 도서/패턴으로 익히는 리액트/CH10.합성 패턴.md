> 코드베이스가 커져도 모듈화된 구조를 유지하여 재사용성과 가동성을 확보하는 것이 중요하다. 컴포넌트가 서로 얽히고 결합된 구조일수록, 유지보수와 테스트가 까다로울 뿐만 아니라 새로운 기능을 추가하거나 기존 기능을 변경하는 작업이 어려워진다. 

> 합성은 위와 같은 문제를 해결하기 위해 체계적이고 확장 가능하며 깔금한 코드베이스를 만들 수 있게 해주는 강력한 기술이다. 하나의 거대한 컴포넌트에 여러 가지 기능을 만들지 않고, 작고 다루기 편한 조각으로 분리하여 다양한 방법으로 이를 조합할 수 있다. 이러한 접근 방식은 로직을 간소화하고 재사용성을 향상시키며 관심사를 명확하게 분리 할 수 있다.

### 1. 고차 함수

> 고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수이다. 리액트에서 고차 함수는 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 패턴으로 자주 사용된다. 이를 통해 공통된 로직이나 상태 관리를 여러 컴포넌트에 쉽게 적용할 수 있다.

> 고차 컴포넌트 (Higher-Order Component, HOC)는 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 함수입니다. 이를 통해 공통된 로직이나 상태 관리를 여러 컴포넌트에 쉽게 적용할 수 있습니다.

``` tsx

const withLoading = <P extends object>(WrappedComponent: ComponentType<P>) => {  
  return (props: P & { isLoading: boolean }) => {  
    const { isLoading, ...rest } = props;  
    if (isLoading) {  
      return <div>Loading...</div>;  
    }    return <WrappedComponent {...(rest as P)} />;  
  };  
};  
```

``` tsx

const MyComponent: React.FC<{ data: string }> = ({ data }) => {  
  return <div>Data: {data}</div>;  
};  
  
const MyComponentWithLoading = withLoading(MyComponent);  
  const MyComponent: React.FC<{ data: string }> = ({ data }) => {  
  return <div>Data: {data}</div>;  
};  
  
const MyComponentWithLoading = withLoading(MyComponent);  
  
export const Test = () => {  
  return <MyComponentWithLoading isLoading={true} data="Hello, World!" />;  
};
```

![[Pasted image 20250925205016.png]]

>  객체 지향 프로그래밍에 익숙하다면 이 개념은 데코레이터 패턴과 유사하다. 구조를 변경하는 대신 객체를 감싸서 동작을 동적으로 추가하는 방법이다. 이 방식은 원래 객체의 기능을 변강하지 않고 기능을 확장 할 수 있으므로 서브클래스보다 훨씬 유연하다.

### 2. 커스텀 훅

>  훅은 상태가 있는 로직을 컴포넌트에서 분리할 수 있게 하여 독립적인 테스팅과 재사용성을 가능하게 해준다. 컴포넌트 구조를 바꾸지 않고도 상태가 있는 로직을 재사용할 수 있게 한다. 기본적으로 훅을 사용하면 함수 컴포넌트에서 리액틔 상태 또는 기타 생명주기 기능들을 연동 할 수 있다.

> 훅은 재사용이 가능한 로직을 포함하며, 컴포넌트와 분리되어 있지만 쉽게 결합할 수 있다. HOC를 통해 감싸는 접근법과 달리 훅은 플러그인 형태의 방식을 제공하여 리액트를 통해 가벼운 형태로 관리하기 쉽다. 이러한 훅은 특성은 코드 모듈화를 쉽게 해줄 뿐만 아니라, 깔금하고 직관적인 형태로 컴포넌의 기능을 확장할 수 있게 해준다.

> 훅은 다양한 기능을 제공한다. UI와 관련된 상태를 관리하는 것뿐만 아니라, 데이터를 가져오거나 페이지 단위의 전역 이벤트 핸들링 등 UI의 부수 효과를 다룰 때도 사용한다.

> 로직을 훅으로 추출하는 것은 동일한 기본 기능을 유지하면서도 다른 UI를 구현해야 할 때 유용하다. 이를 통해 상태관리와 상호작용 로직을 UI렌더링으로부터 분리할 수 있다. 

### 3. 헤드리스 컴포넌트

> 헤드리스 컴포넌트 패턴은 JSX 코드를 기본 로직으로 부터 분리하는 방법이다. 헤드리스 컴포넌트는 UI를 렌더링하지 않고, 대신 자식 컴포넌트에 필요한 상태와 동작을 제공하는 컴포넌트이다. 이를 통해 UI와 로직을 분리하여 재사용성과 유지보수성을 향상시킬 수 있다.

> 헤드리스 컴포넌트는 로직을 캡슐화해서 담고 있지만 렌더링과 고나련된 것은 없는 함수를 뜻한다. 렌더링 영역은 사용자에게 맡김으로써, UI 렌더링에 있어서 유연성을 제공한다.

``` tsx

interface UseToggleProps {
  initial?: boolean;
  onToggle?: (state: boolean) => void;
}


const useToggle = ({ initial = false, onToggle }: UseToggleProps = {}) => {  
  const [on, setOn] = useState(initial);  
  
  const toggle = useCallback(() => {  
    setOn(prevOn => {  
      const newOn = !prevOn;  
      onToggle?.(newOn);  
      return newOn;  
    });  
  }, [onToggle]);  
  
  return { on, toggle };  
};  



```