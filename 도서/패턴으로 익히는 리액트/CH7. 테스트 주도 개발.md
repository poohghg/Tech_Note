> 기능이 계속하여 추가, 수정되며 끊임없이 변화하는 소프트웨어 개발 환경에서 TDD는 버그와 회귀의 함정을 피할 수 있게 가이드역할을 한다.
> 
> 실제 코드를 구현하기 전에 테스트 코드를 작성하면 코드가 제대로 구현되었는지 확인할 수 있고, 미래의 코드 변경으로 인한 위험을 줄일 수 있다.

### 1. TDD 이해하기

> TDD는 소프트웨어 개발과 배포를 짧은 주기로 자주 진행하는 것을 권장하는 익스트링 프로그래밍(XP) 방법론에서 비롯된 개발 기법이다. TDD는 테스트를 먼저 작성하고 그 테스트를 통과하는 코드를 구현하는 반복적인 사이클을 따른다. 이 과정은 코드의 품질을 높이고, 버그를 줄이며, 유지보수성을 향상시키는 데 도움을 준다.

#### TDD의 핵심 레드-그린 -리팩터링 사이클

![[Pasted image 20250911204041.png]]


- 레드: 새로운 기능 또는 기능의 수정 사항을 확인하기 위한 테스트를 작성한다. 아직 기능 구현이 되지 않은 상태에서 작성하기 때문에 초기에는 테스트가 실패할 수 밖에 없다. 이 단계는 테스트가 올바르게 실패하는지 확인하는 단계이다.
- 그린: 테스트를 통과시키키 위한 최소환의 코드를 작성한다. 되도록 적은 코드를 작성하여 테스트를 통과하고, 텍스트를 통과시키는 것이 목표이다.
- 리팩터링: 기능 동작을 유지하면서 코드를 정리한다. 기능을 그대로 유지하면서 코드의 효율성과 가독성을 옾이는 작업을 진행한다. 이 단계에서는 중복된 코드를 제거하고, 코드 구조를 개선하며, 성능을 향상시킬 수 있다. 리팩터링이 완료된 후에는 모든 테스트가 여전히 통과하는지 확인한다.
  
#### TDD의 장점

> 전통적인 개발 방식과 달리 테스트를 실제 코드보다 먼저 작성한다는 점이 TDD의 핵심이다. 이 접근법은 개발자가 코드의 요구사항을 명확히 이해하고, 코드가 예상대로 동작하는지 지속적으로 확인할 수 있게 한다.

- 집중적으로 문제 해결: 특정 기능에 대한 테스트를 먼저 작성함으로써 한 번에 하나의 문제만 집중하고 개발 부담을 줄 일 수 있다.
- 예측 가능한 다음 단계: 테스트 주도 방식에 따르면, 다음 단계에서 해야 할 일은 늘 정확히 정해져 있다. 즉,  다음에 작성해야 할 테스트를 작성하고, 그 테스트를 통과시키는 코드를 작성하는 것이다.
- 단순하고 유지보수하기 쉬운 설계: 테스트를 통과하는 데 필요한 가장 단순한 코드를 작성하게 한다. 최소한의 설계를 구성하므로 이해하고 유지보수하기 쉬운 코드를 작성하게 한다.
- 사고의 흐름 유지: TDD는 코딩에 대한 구조화된 접근 방식으로 사고의 흐름을 유지하게 한다. 이는 생산적인 코딩의 흐름을 방해하는 잦은 컨테스트 전환을 줄여주어 하나의 작업에만 집중할 수 있게 도와준다.
- 자동화된 테스트 커버리지: TDD는 애플리케이션이 탄탄한 커버리지를 이미 가지고 있음을 보장한다. 테스트 작업 이후에 추가하는게 아니라 개발 과정에 포함되어 있기 때문에, 보다 안정적인 코드베이스를 유지할 수 있다.
  
> TDD는 문제 해결에 더욱 집중할 수 있고 예측 가능한 개발과 단순한 설계, 더 나은 생산성과 견고한 테스트 커버리지를 얻을 수 있다.


### 2. 여러 종류의 TDD

#### 기본 TDD

> 기본 TDD는 가장 널리 알려진 형태로, 앞서 설명한 레드-그린-리팩터링 사이클을 따른다. 이 방법은 작은 단위의 기능을 개발할 때 매우 효과적이다. 주로 단위 테스트에 집중한다.
> 
> 이방식은 개별 함수나 메서드와 같은 가장 작은 단위의 코드에 대한 테스트를 작성한다. 코드베이스 각 부분들이 격리된 상태에서 잘 동작하는지를 확인하는 것이 목표이다. 로직과 알고리즘을 테스트하기에는 강력하지만, 사용자 인터페이스나 통합 테스트에는 적합하지 않을 수 있다.

#### ATDD (Acceptance Test-Driven Development)

![[Pasted image 20250911205934.png]]

> 사용자 승인 테스트로 알려진 ATDD는 TDD의 확장된 형태로, 개발자, 테스터, 비즈니스 이해관계자가 협력하여 사용자 스토리나 요구사항에 기반한 테스트를 작성하는 방법론이다. ATDD는 기능이 실제 사용자 요구사항을 충족하는지 확인하는 데 중점을 둔다.
> 
> 이러한 승인 테스트는 이후 기능 개발의 기초 자료로 활용한다. ATDD는 특히 사용자가 원하는 것과 요구하는 사항들을 명확히 이해하는 것이 중요한 프로젝트에서 유용하다. 이 방식은 팀 간의 협업을 촉진하고, 요구사항이 올바르게 구현되었는지 확인하는 데 도움을 준다.

#### BDD (Behavior-Driven Development)

> 애플리에키션에 주어지는 입력에 대한 반응에 주목한다. 시스템이 특정 조건에서 예상한대로 동작하는지를 확인한다. BDD는 TDD의 또 다른 확장 형태로, 테스트를 작성할 때 시스템의 행동과 상호작용에 초점을 맞춘다. BDD는 개발자와 비즈니스 이해관계자 간의 의사소통을 개선하는 데 중점을 둔다.

### 3. 사용자 가치에 집중하기

> 사용자의 시선으로 바라보는 관점이 중요하다. 리액트 컴포넌트는 사용자와 상호작용을 하는 UI의 일부이므로, 이를 테스트에 반영해야 합니다. 개발자가 어떻게 상태를 관리하고 효율적으로 생명주기 메서드를 관리하는지 사용자는 아무 관심이 없다. 버튼을 클릭하면 드롭다운 영역을 보여주거나 폼 양식을 제출하면 기대한 결과가 나오는 것이 사용자에겐 중요합니다.

> 리액트 테스팅 라이브러리를 만든 켄트 C. 도지(Kent C. Dodds)는 "사용자 중심의 테스트"라는 개념을 강조한다. 이는 테스트가 사용자의 관점에서 작성되어야 한다는 의미이다. 즉, 사용자가 애플리케이션과 상호작용하는 방식을 시뮬레이션하고, 사용자가 기대하는 결과를 검증하는 테스트를 작성해야 한다는 것이다.
> 
> 소프트웨어를 사용하는 방식을 닯은 테스트일수록 더 좋은 테스트이다. 즉 사용자 경험에 집중해야 한다는 뜻이다. 사용자가 버튼을 클릭하고, 폼을 제출하고, 페이지를 탐색하는 방식을 테스트해야 한다. 이는 단순히 컴포넌트의 내부 상태나 구현 세부사항을 테스트하는 것보다 훨씬 더 가치 있는 테스트이다.
> 
> 세부 구현보다 상호작용의 결과에 집중하는 BDD와 ATDD 역시 사용자 중심 접근법과 같은 맥락이다. 이러한 접근법은 사용자의 요구사항과 기대치를 충족하는지 확인하는 데 도움을 준다.

### 4. 애플리케이션 요구사항 세분화

> 애플리케이션 요구사항을 세분화하는데 일반적으로 상향식 접근법과 하향식 접근법이 있다. 상향식 접근법은 작은 단위의 기능부터 시작하여 점차적으로 전체 시스템을 구축하는 방식이다. 반면, 하향식 접근법은 전체 시스템의 큰 그림을 먼저 그리고, 이를 구성하는 작은 단위의 기능으로 세분화하는 방식이다.

#### 상향식 TDD

> 상향식 TDD는 작고 기초적인 기능들의 테스트 코드를 작성하고 기능을 구현하는 것부터 시작한다. 이 접근 방식은 개별 단위 또는 클래스부터 만들어가면서 상위 컴포넌트로 결합하여 구성하기 전에 철저하게 테스트한다. 시스템의 개별 부분들을 강력하게 검증하여 견고한 기반을 만드는데 도움이 된다.
> 
> 하지만 이 방식은 개별 단위 간 상호작용에 대한 고려와 전체 시스템을 통합적으로 보는 관점이 부족할 경우, 실제 통합 작업 시 여려움을 겪게 될 수도 있다.

> 상향식 TDD 개발 방식은 각각의 작업마다 개별 컴포넌트에 집중한다. 컴포넌트들은 최소한의 기능에서 시작하여, 점점 세부 기능들이 추가된다. 테이스 케이스도 마찬기지로 기능의 요구사항에 따라 늘려 가면서 몇몇 엣지 케이스들도 점검하기 위해 추가한다.

#### 하향식 TDD

> 하향식 TDD는 상향식 TDD와 반대로 시스템 전체 구조와 기능부터 시작한다. 메인 컴포넌트의 기능을 구현하는 것부터 시작하여 이후 세부적인 기능들로 점진적으로 확장해 나간다.

> 하향식 TDD는 시스템의 주된 목적과 작업의 흐름을 초반부터 확립할 수 있고, 명확한 개발 로드맵을 알 수 있다. 전체 목표에 더 잘 맞는 방식으로 통합을 유도할수 있지만, 개발되기 전인 하위 단계 컴포넌트의 동작을 파악하기 위해 임시로 스텁이나 모킹이 필요할 수 있다.

> 하향식 TDD 개발 방식에서는 개별 컴포넌트 단위가 아닌, 전체 애플리케이션에 대한 큰 그림이 있다. 따라서 세부적인 구현 내용과 상관없이 애플리케이션의 외부 모습을 그릴 수 있다.
> 
> 컴포넌트가 너무 크다면 큰 단위의 컴포넌트에서 점점 작은 컴포넌트를 분리, 세분화하여 구현
 
