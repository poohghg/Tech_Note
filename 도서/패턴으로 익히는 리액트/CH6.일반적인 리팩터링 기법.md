> 리팩터링은 특정 언어나 프레임워크를 가리지 않으며 모든 코드에 적용 가능한 개념이다.
> 변수 이름 바꾸기, 함수 선언 변경하기, 함수 추출하기, 필드의 이동 등 다양한 기법이 있다.
> 이해하기 쉽고 유지보수하기 쉬운 코드를 만드는 데 매우 유용하다.
> 
> 리팩터링은 일회성 작업이 아니라 소규모로, 반복해서 수행하면서 코드 품질과 구조를 점진적으로 발전시켜 나가는 과정이다. 튼튼하고 작업하기 쉬운 코드베이스는 반복되는 개선작업을 통해 유지할 수 있다.


### 1. 리팩터링 이해하기

> 리팩터링은 체계화된 절차와 방법에 따라 기존의 코드베이스에서 기능 동작의 외적인 변화 없이 구조를 개선하는 것을 의미한다. 리팩터링은 코딩의 기본이며, 반복적이고 점진적인 소프트웨어 개발 과정의 특성상 반드시 실천해야 한다.
> 
> - 기존의 코드베이스를 개선하기 위한 제어된 기술로, 이를 통해 이해와 확장, 유지보수가 용이한 코드를 만들수 있다.
> 
> 새로운 기능을 직접 추가하는 것은 아니지만, 신규 기능들을 버그 없이 빠르게 추가하여 제공할 수 있게 하고 요구사항의 변화에 빠르고 유연하게 대처할 수 있게 한다. 끊임없는 리팩터링을 통해 코드를 깔끔하고 다루기 쉽게 유지할 수 있으며, 장기적으로 지속 가능한 개발 환경이 조성된다.

> 리팩터링은 체계화된 방법을 통해 코드베이스를 보다 깔금하게 가독성읖 높여 작업하기 편하게 개선하는 것이다.
> 
> 반면에 리스트럭처링은 보다 광범위하고 과감한 과정이다.
> 
> 대규모의 변경을 통해 소프트웨어 내부 구조뿐만 아니라 외부 특성까지 영향을 미칠 수 있다.
> 소프트웨어의 가용성, 성능 향상, 또는 심각한 기술 부채를 해결해야 하는 경우에 주로 진행한다.

>리팩터링과 리스트럭처링 모두 코드베이스의 품질을 높이기 위한 활동이지만, 리팩터링은 보통 그 범위가 크지 않고 외부 기능의 변화가 없으며 일반적인 개발 과정의 한 작업으로 수행한다. 반면에 리스트럭처링은 큰 범위로 이루어지며 외부 기능의 변화가 있을 수 있고, 규모가 큰 프로젝트의 일부로서 요구사항을 해결하기 위해 상당한 변경을 수행한다.


### 2. 변수 이름 바꾸기

>  변수 이름 바꾸기는 직관적이면서도 효과적으로 코드의 가독성과 유지보수성을 높일 수 있는 리팩터링 기술이다. 변수의 이름을 변수가 가진 목적과 성격을 반영하여 변경하거나, 특정 네이밍 표준을 따르게 바꿀 수 있다.

### 3. 변수 추출하기

> 변수 추출하기는 코드의 가독성과 유지보수성을 높이는 보편적인 리팩터링 기법이다. 이 과정은 값을 계산하는 코드 영역을 새로운 변수로 대체하고 원래 표현식의 결괏값을 대체하는 변수에 할당한다. 이렇게 하면 코드가 더 명확해지고, 중복된 계산을 피할 수 있으며, 나중에 값을 쉽게 재사용할 수 있다.
> 
> 주로 복잡한 표현식의 일부를 의미 있는 이름의 변수로 추출하면 코드를 쉽게 이해하고 다루기 편해진다.

``` ts
// 리팩터링 전
const calculateTotalPrice = (items: { price: number; quantity: number }[]) => {
  return items.reduce((total, item) => total + item.price * item.quantity, 0);
};
```

``` ts
// 리팩터링 후
const calculateTotalPrice = (items: { price: number; quantity: number }[]) => {
  const itemTotal = (item: { price: number; quantity: number }) => item.price * item.quantity;
  return items.reduce((total, item) => total + itemTotal(item), 0);
};

```

### 4. 반복문을 파이프라인으로 바꾸기

> 반복문을 파이프라인으로 바꾸기는 말 그대로 반복문 구조를 변환 파이프라인 구조로 변경하는 것이다.
> 일반적으로 고차 함수 또는 함수형 프로그래밍 기법을 활용하여 구현한다.
> 
> 반복문을 파이프라인으로 대체하는 것은 코드를 깔금하게 해주고 가독성을 높여줄 수 있지만, 대용량의 데이터 세트를 다룰 때는 효과적인 선택이 아닐 수 있다. 따라서 대용량의 데이터 세트를 반복해서 다뤄야 하는 경우 유지보수성과 성능 요구사항을 균형 있게 고려해야한다.

### 5. 함수 추출하기

>  함수 추출하기는 크고 복잡한 함수를 작고 다루기 쉽게 분리하여 코드의 가독성과 유지보수성을 높여주는 리팩터링 기법이다.
>  
>  여러 동작을 수행하는 함수를 예로 들어보면 다음과 같다.
>  
>  데이터 검증, 계산 수행, 결과 로깅, 상태 업데이트 등의 다양한 역할을 하나의 함수가 맡으면 길고 복잡하여 이해하기 쉽지 않다.
>  
>  함수 추출 리팩터링은 개별적인 기능들을 식별하고 별도의 함수로 분리한 후, 원래 함수에서 새로 만든 함수를 호출하는 과정이다.
>  
>  함수 추출 리팩터링은 개별적인 기능들을 식별하고 별도의 함수로 분리 한 후, 원래 함수에서 새로 만든 함수를 호출 하는 과정이다.


**행위 기반 상태 변경 (CRUD 의미 부여)**

- 상태 변경에 **의도가 들어가는 경우**에는 행위 동사를 붙입니다.    
- 예시:
    - `openDropDown`, `closeDropDown`, `toggleDropDown`
    - `addItem`, `removeItem`, `updateUser`, `resetForm`
`set` 대신 `open`/`close`/`toggle` 같은 도메인 맥락의 동사를 쓰면 가독성이 좋다.  
 **CRUD → add/remove/update/reset** 패턴은 팀에서 정해두면 아주 직관적입니다.

|상황|네이밍 패턴|예시|
|---|---|---|
|단순 state setter|`setXxx`|`setIsOpen`, `setUser`|
|행위 기반 상태 변경|도메인 동사|`openDropDown`, `closeDropDown`, `toggleDropDown`, `addItem`, `resetForm`|
|외부에서 주입되는 이벤트 콜백|`onXxx`|`onSelect`, `onSubmit`, `onClose`|
|내부에서 정의하는 이벤트 핸들러|`handleXxx`|`handleSelect`, `handleSubmit`, `handleClose`|
``` tsx

interface ButtonProps {
  onClick: () => void   // 외부에서 주입되는 콜백
}

const Button = ({ onClick }: ButtonProps) => {
  const handleClick = () => {
    // 내부 처리
    onClick()
  }
  return <button onClick={handleClick}>Click</button>
}
```
### 6. 매개변수 객체 도입

> 매개변수 객체 도입은 함수가 많은 수의 매개변수를 가지거나, 여러 개의 함수가 같은 매개변수를 공유할 때 사용하는 이팩터링 기법이다. 연관된 매개변수들을 하나의 객체로 묶고, 이 객체를 함수에 인자로 전달한다.
> 
> 관련된 매개변수를 하나의 객체로 묶어주면 코드의 가독성이 높아지고 함수의 역할을 이해하기 쉬우며, 함수 호출이 단순하고 깔금해진다.
> 
> 매개변수 객체 도입은 코드에서 드러나지 않던 도메인 개념을 명확하게 표현하는 데도 도움이 된다.
> 매개변수 객체는 그 자체로 별도의 기능과 데이터를 다루는 하나의 클래스가 될 수 있다. 이는 좀더 객체 지향적이고 캡술화된 코드로 발전시키는 데 기여한다.


### 7. 조건문 분해하기

> 조건문 분해하기는 복잡한 조건문을 더 단순하고 이해하기 쉽게 만드는 리팩터링 기법이다. 복잡한 조건문은 여러 개의 논리 연산자와 중첩된 조건문으로 이루어져 있어 가독성을 떨어뜨리고 유지보수를 어렵게 만든다.
> 
> 조건문인 if절과 else절을 별도의 함수로 나누고, 각각이 지닌 기능 또는 그것이 무엇을 확인하는지 나타낼 수 있도록 이름을 정해준다. 이름이 잘 지어진 함수로 대체하여, 코드만 보고도 이해할 수 있게 한다.


``` ts

function isDiscountEligible(item: Item) {
	return item.quantity > 10;
}

function applyDiscountIfEligible(item: Item, subTotal: number) {
	return isDiscountEligible(item)
	? subTotal * DISCOUNT_RATE
	: subTotal;
}

```

### 8. 함수 이동하기

> 함수 이동은 함수의 위치를 좀 더 적절한 곳으로 옮기는 것을 뜻한다.
> 이 리팩터링 기법은 기능들이 논리적으로 가장 알맞은 곳에 있게 하여, 가독성과 유지보수성을 높이고 코드를 구조화하는 것이다.
> 
> 함수 이동 리팩터링 기법은 함수를 기능의 연과넛ㅇ이 높거나 필요한 곳으로 옮김으로써 클래스의 복잡도를 낮출 수 있다. 이는 연관된 코드가 함께 위치하게 하여 코드 응집도를 높여준다. 또한 서로 다른 코드 간의 불필요한 상호 의존관계를 낮출 수 있다.