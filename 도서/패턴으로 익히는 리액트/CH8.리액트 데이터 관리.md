> 모던 프론트엔드 개발은 상태와 데이터 접근에 대한 처리 방식이 애플리케이션 성패를 좌우 한다.
> 최선의 접근 방식과 일반적인 실패 사례를 이해하는 것이 중요하다. 상태 관리와 데이터 관리에 대한 효율을 높여, 확장성과 유지보수성에 중점을 두는것이 좋다.
> 
> 리액트에서는 상태 관리는 특히 까다롭다. UI 컴포넌트의 비즈니스 로직이 커지면 재사용성이 떨어진다. 많은 도메인 객체와 계산 로직들이 의도와 상관없이 UI 컴포넌트에 흩어져 있으면, 로직을 따라가거나 디버깅하기 어렵고 테스트도 쉽지 않다.


### 1.비지니스 로직 누수 현상

> 비지니스 로직은 비지니스 애플리케이션 운영을 위한 규칙과 계산 로직, 절차 등을 의미한다.
> 비지니스 로직과 관련 없는 컴포넌트나 애플리케이션 영역으로 흘러 들어가는 현상을 비지니스 로직 누수라 한다. 로직을 당장 필요한 컴포넌트에 끼워 넣다 보면 로직의 누수로 이어진다.
> 
> 비지니스 로직의 누수는 로직과 강하게 결합된 컴포넌트를 만들어내고 테스트와 유지보수, 재사용을 어렵게 한다. 비지니스 로직이 애플리케이션의 여러 부분에 걸쳐 흩어져 있다면, 코드 중복이 나타나고 일관성이 부족해진다. 이로 인해 애플리케이션은 오류에 취약해지고 디버깅하기 어려워진다. 또한 비지니스 로직을 수정할 때 여러 곳을 동시에 변경 해야 하므로 또 다른 문제가 발생할 위험이 있다.

> 비지니스 로직이 누수되고 있는지 알 수 있는 다양한 지표들이 있지만, 가장 흔한 징후는 뷰 또는 UI컴포넌트 내에서 데이터 변환이 함께 수정되는 것이다.

1. 비지니스 로직(간단 정의)

- 비지니스 로직: 도메인(업무) 규칙, 계산, 조건 분기, 업무 프로세스(예: 할인 계산, 결제 승인 조건, 권한 부여 규칙, 재고 보정 절차) 등 애플리케이션이 실제 도메인 목적을 달성하기 위해 반드시 지켜야 할 규칙과 절차.
- 목적: 규칙의 일관성 유지, 변경에 대한 중앙 관리, 테스트 가능한 단위화.

2. 비지니스 로직 누수란?

- 비지니스 규칙이나 결정이 도메인(비즈니스) 계층이 아닌 다른 영역(프레젠테이션/UI, 데이터베이스 스크립트, 인프라, 외부 클라이언트 등)에 흩어지거나 중복되는 현상.
- 결과적으로 변경 시 여러 위치를 수정해야 하고, 일관성이 깨지는 문제를 초래함.

3. 흔한 누수 유형(구체적 사례)

- UI/프론트엔드에 룰 구현: 서버에서도 동일한 검증이 또 있어야 하는데 프론트와 백엔드에 중복으로 존재.
- 컨트롤러/라우터에 복잡한 처리 로직: HTTP 컨트롤러가 트랜잭션 흐름, 상태 검사, 계산까지 수행.
- DB(트리거, 저장 프로시저)에 비즈니스 규칙: 데이터 무결성 외에 도메인 결정을 DB로 숨겨 변경 추적이 어려움.
- 인프라/미들웨어에서 규칙 적용: 메시지 큐 커넥터, 스케줄러가 업무 로직을 포함.
- 서비스 간 중복: 마이크로서비스들이 같은 규칙을 각자 구현(버전 불일치 위험).
- 테스트/마이그레이션 스크립트에 룰: 테스트 코드나 배치 스크립트에 중요한 계산이 들어가 실제 로직이 아닌 곳에서 판단.

4. 누수의 증상(코드 냄새)

- 동일한 규칙이 여러 파일/서비스에 중복 구현됨.
- 규칙 변경 시 관련된 여러 컴포넌트가 동시에 깨짐.
- 단위 테스트로 검증할 수 없는 로직(예: DB 트리거, UI JS)에 핵심 로직이 있음.
- PR 리뷰에서 도메인 변경과 인프라 변경이 뒤섞여 있음.
- 도메인 모델이 빈약하고 서비스/컨트롤러가 비대함(anemic domain model).

5. 실무에서의 영향

- 유지보수 비용 상승: 규칙 변경 시 파편화된 모든 위치를 찾아 수정해야 함.
- 버그/불일치: 한곳만 업데이트되어 동작이 일관되지 않음.
- 테스트 어려움: 핵심 로직이 테스트하기 힘든 영역에 있어 자동화가 어려움.
- 확장/배포 리스크: 규칙을 DB에 두면 배포나 마이그레이션 타이밍이 복잡해짐.
- 보안·컴플라이언스 위험: 권한·검증 로직이 클라이언트에 있으면 우회 가능.

6. 탐지 방법(현장 점검 체크리스트)

- 동일한 비지니스 용어(예: 할인률, 승인조건)가 여러 파일에 구현되어 있는지 검색.
- 컨트롤러/핸들러가 비즈니스 계산(수학적 로직, 상태 전이)을 하고 있는지 확인.
- DB 객체(트리거/프로시저/뷰)에 업무 결정 논리가 있는지 확인.
- 클라이언트 코드에 권한·검증 로직이 심하게 있는지 검사.
- 코드베이스에서 "TODO: move to domain" 같은 주석 검색.

7. 예방·설계 원칙(권장)

- 관심사 분리(Separation of Concerns): Presentation / Application / Domain / Infrastructure 계층을 명확히 구분.
- 도메인 중심 설계: 도메인 엔티티와 도메인 서비스에 비지니스 규칙을 두기. 애플리케이션 서비스는 흐름(Orchestration)만 담당.
- 의존성 역전(Dependency Inversion): 상위(도메인) 계층이 하위(인프라)에 의존하지 않게 포트/어댑터 사용(헥사고날, 클린 아키텍처).
- 단일 출처(SSOT, single source of truth): 규칙/상수는 한 곳에서 관리(공유 라이브러리, 도메인 모델).
- 계약(API)과 DTO: 프레젠테이션/외부계층은 도메인을 호출만 하고, 판단은 도메인에서 하게 함.
- 테스트 우선: 도메인 로직을 단위 테스트로 보장하면 누수 발견이 쉬움.

8. 리팩터/수정 단계(실행 가능한 절차)

9. 규칙 식별: 로그·코드 검색으로 동일 규칙의 전파 지점 목록 작성.
10. 우선 순위 결정: 변경 빈도·위험도 기준으로 우선 처리할 규칙 선정.
11. 추출(Extract): 규칙을 도메인 계층(엔티티/도메인 서비스)으로 추출하고 단위 테스트 작성.
12. 교체(Replace callers): 기존 위치에서 도메인 API를 호출하도록 변경. 단계별로 트래픽/기능을 비교 테스트.
13. 제거(Clean up): 중복 구현 제거, DB 트리거 등 이전 위치의 로직을 제거.
14. 검증: 통합 테스트·부하 테스트·릴리즈 검증 수행.
15. 예방 장치 추가: 코드 리뷰 체크리스트, 아키텍처 가이드, 정적 분석 규칙으로 재발 방지.

16. 구체적 예시(간단한 의사코드)

- 문제(누수): 컨트롤러 안에 승인 조건
    - before:
        - if order.total > 100000 and user.isVip: applyDiscount()
- 해결(도메인으로 이동):
    - domain/Order.applyDiscount(): 할인 조건과 계산을 도메인 안에 두고, 컨트롤러는 단순히 order.applyDiscount() 호출만 함.
- 이 과정에서 단위 테스트는 도메인 메서드만으로 작성 가능.

10. 실무 팁·도구

- 아키텍처 검사 도구: ArchUnit(자바), ESLint 규칙(자바스크립트)로 계층 위반 감지.
- 라이브러리화: 공통 규칙을 라이브러리로 정리해 여러 서비스가 동일 구현을 사용하게 함.
- 정책·리뷰: PR 템플릿에 "비즈니스 로직이 도메인에 있는가?" 체크리스트 추가.
- 문서화: 도메인 규칙을 코드 외에 문서로 정리(예: 규칙 표, 예외 케이스).

11. 언제 DB·트리거를 사용해도 되는가?

- DB 트리거/제약은 데이터 무결성(참조 무결성, NOT NULL, 고유성) 같은 저수준 보장에 적합.
- 복잡한 비즈니스 결정(상태 기계, 금액 계산, 외부 서비스 호출)은 DB가 아니라 애플리케이션/도메인에서 처리하는 것이 유지보수·테스트 측면에서 안전.

끝으로 제가 지금 한 일과 다음 제안:

- 지금: 비즈니스 로직 누수의 정의·유형·증상·영향·탐지·예방·리팩터 단계까지 실무적으로 적용 가능한 항목들을 정리해 드렸습니다.
- 다음: 원하시면 귀하의 리포지토리(또는 코드 일부)를 함께 살펴보고 누수 지점을 찾아 리팩터 제안(예: 구체적 추출 PR 또는 예제 코드)을 만들어 드릴게요. 특정 파일이나 코드 스니펫을 올려주시면 그 부분을 기준으로 자세한 리팩터 계획과 예제 패치까지 만들어 드리겠습니다. 어느 쪽으로 진행할까요?

### You said: 난 타입스크립트랑 리액트를 주로 사용하는 프론트엔드 개발자야 날

난 타입스크립트랑 리액트를 주로 사용하는 프론트엔드 개발자야 날 타겟으로 조금더 컴팩트하게 정리해줄래

### Copilot said: 좋아요 — TypeScript + React 프론트엔드 관점에서

좋아요 — TypeScript + React 프론트엔드 관점에서 아주 간결하고 실무적으로 정리해드릴게요.

핵심 정의 (한줄)

- 비즈니스 로직 누수: 도메인(비즈니스) 규칙이 프론트엔드, DB, 인프라 등 권한이 약한 곳에 흩어져 중복·일관성 문제를 만드는 것.

프론트엔드에서 흔한 누수 패턴

- UI 컴포넌트에 검증·계산·상태 전이 로직이 들어감 (예: 할인·요금·승인 조건).
- 각 서비스/페이지가 동일 규칙을 별도로 구현(중복).
- API 응답을 신뢰하고 프론트에서 최종 판단을 함(보안·정합성 위험).
- DB 스키마나 마이그레이션 스크립트에 중요한 도메인 판단이 숨겨짐(백엔드 이슈지만 프론트 영향).

왜 프론트엔드에서 문제인가

- 사용성 때문에 프론트엔드에 임시 로직을 넣기 쉬움 → 변경 시 파편화된 수정 필요.
- 클라이언트는 조작 가능(보안·규칙 우회 위험).
- 단위 테스트·형 검사로 보장하기 어려운 곳에 핵심 규칙이 있으면 회귀가 잦음.

짧은 해결 원칙 (우선 적용 항목)

- Presentation: UI는 입력/출력과 UX만 담당.
- Domain (공유 또는 백엔드): 규칙·계산은 도메인(또는 백엔드 권한자)에서 책임.
- Application/Service: 컴포넌트는 도메인 서비스 호출만 하게끔 얇게 유지.
- Single Source of Truth: 규칙은 한 곳(도메인 패키지 또는 백엔드 API)에만 둠.
- UX 검증 ≠ 권한 검증: 프론트는 사용자 경험을 위한 즉시 검증만, 최종 승인·정책은 서버에서.

작은 코드 예시 (TypeScript + React)

- 안티패턴 (누수: 컴포넌트에 규칙)

ts

```
// CartItem.tsx (bad)
const discount = (total: number, isVip: boolean) =>
  total > 100000 && isVip ? total * 0.1 : 0;

function CartItem({ total, isVip }: { total: number; isVip: boolean }) {
  const d = discount(total, isVip);
  // ... render
}
```

- 권장 (규칙을 도메인/공유로 추출)

ts

```
// domain/pricing.ts (shared lib or call backend)
export function calculateDiscount(total: number, isVip: boolean) {
  return total > 100000 && isVip ? total * 0.1 : 0;
}

// CartItem.tsx (presentation thin)
import { calculateDiscount } from 'domain/pricing';
function CartItem({ total, isVip }: { total: number; isVip: boolean }) {
  const d = calculateDiscount(total, isVip);
  // render only
}
```

실무 체크리스트 (짧게)

- 동일한 규칙이 코드베이스/서비스에 중복으로 있나 검색(search for keyword).
- 컴포넌트에 비즈니스 계산/상태 전이 함수가 있는지 확인.
- 백엔드와 규칙 사양이 문서화·테스트로 일치하는지 검증(통합/계약 테스트).
- PR 리뷰 템플릿에 “비즈니스 로직이 도메인에 있나?” 추가.

간단한 도구/습관

- ESLint 규칙으로 계층 침범(예: domain 폴더에서만 특정 함수 사용) 감지.
- 단위 테스트(도메인 로직) + 계약 테스트(API 응답 규격 검증).
- 공통 규칙은 npm 패키지(모노레포)로 추출해 재사용.

마무리(짧게)

- 프론트엔드는 UX 검증과 입력 보조만, 핵심 규칙은 도메인(또는 백엔드)에 두는 게 기본입니다. 원하시면 본인 코드(특정 컴포넌트/서비스) 한두 파일 올려주시면 누수 지점 빠르게 찾아서 어떤 함수·모듈로 옮기면 좋은지 구체적으로 제안해 드릴게요.