> 모던 프론트엔드 개발은 상태와 데이터 접근에 대한 처리 방식이 애플리케이션 성패를 좌우 한다.
> 최선의 접근 방식과 일반적인 실패 사례를 이해하는 것이 중요하다. 상태 관리와 데이터 관리에 대한 효율을 높여, 확장성과 유지보수성에 중점을 두는것이 좋다.
> 
> 리액트에서는 상태 관리는 특히 까다롭다. UI 컴포넌트의 비즈니스 로직이 커지면 재사용성이 떨어진다. 많은 도메인 객체와 계산 로직들이 의도와 상관없이 UI 컴포넌트에 흩어져 있으면, 로직을 따라가거나 디버깅하기 어렵고 테스트도 쉽지 않다.


### 1.비지니스 로직 누수 현상

> 비지니스 로직은 비지니스 애플리케이션 운영을 위한 규칙과 계산 로직, 절차 등을 의미한다.
> 비지니스 로직과 관련 없는 컴포넌트나 애플리케이션 영역으로 흘러 들어가는 현상을 비지니스 로직 누수라 한다. 로직을 당장 필요한 컴포넌트에 끼워 넣다 보면 로직의 누수로 이어진다.
> 
> 비지니스 로직의 누수는 로직과 강하게 결합된 컴포넌트를 만들어내고 테스트와 유지보수, 재사용을 어렵게 한다. 비지니스 로직이 애플리케이션의 여러 부분에 걸쳐 흩어져 있다면, 코드 중복이 나타나고 일관성이 부족해진다. 이로 인해 애플리케이션은 오류에 취약해지고 디버깅하기 어려워진다. 또한 비지니스 로직을 수정할 때 여러 곳을 동시에 변경 해야 하므로 또 다른 문제가 발생할 위험이 있다.

> 비지니스 로직이 누수되고 있는지 알 수 있는 다양한 지표들이 있지만, 가장 흔한 징후는 뷰 또는 UI컴포넌트 내에서 데이터 변환이 함께 수정되는 것이다.


- 비즈니스 로직 누수: 도메인(비즈니스) 규칙이 프론트엔드, DB, 인프라 등 권한이 약한 곳에 흩어져 중복·일관성 문제를 만드는 것.

프론트엔드에서 흔한 누수 패턴

- UI 컴포넌트에 검증·계산·상태 전이 로직이 들어감 (예: 할인·요금·승인 조건).
- 각 서비스/페이지가 동일 규칙을 별도로 구현(중복).
- API 응답을 신뢰하고 프론트에서 최종 판단을 함(보안·정합성 위험).
- DB 스키마나 마이그레이션 스크립트에 중요한 도메인 판단이 숨겨짐(백엔드 이슈지만 프론트 영향).

왜 프론트엔드에서 문제인가

- 사용성 때문에 프론트엔드에 임시 로직을 넣기 쉬움 → 변경 시 파편화된 수정 필요.
- 클라이언트는 조작 가능(보안·규칙 우회 위험).
- 단위 테스트·형 검사로 보장하기 어려운 곳에 핵심 규칙이 있으면 회귀가 잦음.

짧은 해결 원칙 (우선 적용 항목)

- Presentation: UI는 입력/출력과 UX만 담당.
- Domain (공유 또는 백엔드): 규칙·계산은 도메인(또는 백엔드 권한자)에서 책임.
- Application/Service: 컴포넌트는 도메인 서비스 호출만 하게끔 얇게 유지.
- Single Source of Truth: 규칙은 한 곳(도메인 패키지 또는 백엔드 API)에만 둠.
- UX 검증 ≠ 권한 검증: 프론트는 사용자 경험을 위한 즉시 검증만, 최종 승인·정책은 서버에서.

작은 코드 예시 (TypeScript + React)

- 안티패턴 (누수: 컴포넌트에 규칙)

ts

```
// CartItem.tsx (bad)
const discount = (total: number, isVip: boolean) =>
  total > 100000 && isVip ? total * 0.1 : 0;

function CartItem({ total, isVip }: { total: number; isVip: boolean }) {
  const d = discount(total, isVip);
  // ... render
}
```

- 권장 (규칙을 도메인/공유로 추출)

ts

```
// domain/pricing.ts (shared lib or call backend)
export function calculateDiscount(total: number, isVip: boolean) {
  return total > 100000 && isVip ? total * 0.1 : 0;
}

// CartItem.tsx (presentation thin)
import { calculateDiscount } from 'domain/pricing';
function CartItem({ total, isVip }: { total: number; isVip: boolean }) {
  const d = calculateDiscount(total, isVip);
  // render only
}
```

실무 체크리스트 (짧게)

- 동일한 규칙이 코드베이스/서비스에 중복으로 있나 검색(search for keyword).
- 컴포넌트에 비즈니스 계산/상태 전이 함수가 있는지 확인.
- 백엔드와 규칙 사양이 문서화·테스트로 일치하는지 검증(통합/계약 테스트).
- PR 리뷰 템플릿에 “비즈니스 로직이 도메인에 있나?” 추가.

간단한 도구/습관

- ESLint 규칙으로 계층 침범(예: domain 폴더에서만 특정 함수 사용) 감지.
- 단위 테스트(도메인 로직) + 계약 테스트(API 응답 규격 검증).
- 공통 규칙은 npm 패키지(모노레포)로 추출해 재사용.

마무리(짧게)

- 프론트엔드는 UX 검증과 입력 보조만, 핵심 규칙은 도메인(또는 백엔드)에 두는 게 기본입니다. 원하시면 본인 코드(특정 컴포넌트/서비스) 한두 파일 올려주시면 누수 지점 빠르게 찾아서 어떤 함수·모듈로 옮기면 좋은지 구체적으로 제안해 드릴게요.