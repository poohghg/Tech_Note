> 모던 프론트엔드 개발은 상태와 데이터 접근에 대한 처리 방식이 애플리케이션 성패를 좌우 한다.
> 최선의 접근 방식과 일반적인 실패 사례를 이해하는 것이 중요하다. 상태 관리와 데이터 관리에 대한 효율을 높여, 확장성과 유지보수성에 중점을 두는것이 좋다.
> 
> 리액트에서는 상태 관리는 특히 까다롭다. UI 컴포넌트의 비즈니스 로직이 커지면 재사용성이 떨어진다. 많은 도메인 객체와 계산 로직들이 의도와 상관없이 UI 컴포넌트에 흩어져 있으면, 로직을 따라가거나 디버깅하기 어렵고 테스트도 쉽지 않다.


### 1. 비지니스 로직 누수 현상

> 비지니스 로직은 비지니스 애플리케이션 운영을 위한 규칙과 계산 로직, 절차 등을 의미한다.
> 비지니스 로직과 관련 없는 컴포넌트나 애플리케이션 영역으로 흘러 들어가는 현상을 비지니스 로직 누수라 한다. 로직을 당장 필요한 컴포넌트에 끼워 넣다 보면 로직의 누수로 이어진다.
> 
> 비지니스 로직의 누수는 로직과 강하게 결합된 컴포넌트를 만들어내고 테스트와 유지보수, 재사용을 어렵게 한다. 비지니스 로직이 애플리케이션의 여러 부분에 걸쳐 흩어져 있다면, 코드 중복이 나타나고 일관성이 부족해진다. 이로 인해 애플리케이션은 오류에 취약해지고 디버깅하기 어려워진다. 또한 비지니스 로직을 수정할 때 여러 곳을 동시에 변경 해야 하므로 또 다른 문제가 발생할 위험이 있다.

> 비지니스 로직이 누수되고 있는지 알 수 있는 다양한 지표들이 있지만, 가장 흔한 징후는 뷰 또는 UI컴포넌트 내에서 데이터 변환이 함께 수정되는 것이다.


- 비즈니스 로직 누수: 도메인(비즈니스) 규칙이 프론트엔드, DB, 인프라 등 권한이 약한 곳에 흩어져 중복·일관성 문제를 만드는 것.

프론트엔드에서 흔한 누수 패턴

- UI 컴포넌트에 검증·계산·상태 전이 로직이 들어감 (예: 할인·요금·승인 조건).
- 각 서비스/페이지가 동일 규칙을 별도로 구현(중복).
- API 응답을 신뢰하고 프론트에서 최종 판단을 함(보안·정합성 위험).
- DB 스키마나 마이그레이션 스크립트에 중요한 도메인 판단이 숨겨짐(백엔드 이슈지만 프론트 영향).

왜 프론트엔드에서 문제인가

- 사용성 때문에 프론트엔드에 임시 로직을 넣기 쉬움 → 변경 시 파편화된 수정 필요.
- 클라이언트는 조작 가능(보안·규칙 우회 위험).
- 단위 테스트·형 검사로 보장하기 어려운 곳에 핵심 규칙이 있으면 회귀가 잦음.

짧은 해결 원칙 (우선 적용 항목)

- Presentation: UI는 입력/출력과 UX만 담당.
- Domain (공유 또는 백엔드): 규칙·계산은 도메인(또는 백엔드 권한자)에서 책임.
- Application/Service: 컴포넌트는 도메인 서비스 호출만 하게끔 얇게 유지.
- Single Source of Truth: 규칙은 한 곳(도메인 패키지 또는 백엔드 API)에만 둠.
- UX 검증 ≠ 권한 검증: 프론트는 사용자 경험을 위한 즉시 검증만, 최종 승인·정책은 서버에서.

작은 코드 예시 (TypeScript + React)

- 안티패턴 (누수: 컴포넌트에 규칙)

``` tsx
// CartItem.tsx (bad)
const discount = (total: number, isVip: boolean) =>
  total > 100000 && isVip ? total * 0.1 : 0;

function CartItem({ total, isVip }: { total: number; isVip: boolean }) {
  const d = discount(total, isVip);
  // ... render
}
```

- 권장 (규칙을 도메인/공유로 추출)

``` tsx
// domain/pricing.ts (shared lib or call backend)
export function calculateDiscount(total: number, isVip: boolean) {
  return total > 100000 && isVip ? total * 0.1 : 0;
}

// CartItem.tsx (presentation thin)
import { calculateDiscount } from 'domain/pricing';
function CartItem({ total, isVip }: { total: number; isVip: boolean }) {
  const d = calculateDiscount(total, isVip);
  // render only
}
```

실무 체크리스트 
- 컴포넌트에 비즈니스 계산/상태 전이 함수가 있는지 확인.
- 백엔드와 규칙 사양이 문서화·테스트로 일치하는지 검증(통합/계약 테스트).
- PR 리뷰 템플릿에 “비즈니스 로직이 도메인에 있나?” 추가.

간단한 도구/습관

- ESLint 규칙으로 계층 침범(예: domain 폴더에서만 특정 함수 사용) 감지.
- 단위 테스트(도메인 로직) + 계약 테스트(API 응답 규격 검증).
- 공통 규칙은 npm 패키지(모노레포)로 추출해 재사용.

### 2. ACL(오류 방지 계층)

> 소프트웨어 개발에서 ACL은 각각 다른 언어를 사용하는 다른 서브시스템 간의 통역가 또는 중재자 역할을한다.
> 서로 다른 규칙과 구조를 가진 두 시스템을 직접 연결한다면 서로 의도치 않게 영향을 끼칠 수 있고 각각의 고유 도메인 로직을 훼손할 수 있다.
> 
> 프런트엔드 ACL은 여러 다른 형식의 데이터들을 프런트엔드 애플리케이션에서 이해 할 수 있는 형태로 변환하는 역할을 한다. UI컴포넌트는 각 서비스별 데이터 형식의 복잡한 세부 사항에 대해 신경 쓰지 않아도 되므로 개발과 테스트, 유지보수를 쉽게 할 수 있다.
> 
> ACL은 캐시 처리, 오류 변환과 같은 여러 문제를 처리하는 전략 계층으로 활용할 수 있다.
> 이러한 기능들을 한 곳에 집중하면 로직이 여러 프런트엔드 코드베이스에 분산되는 것을 방지 하게 되므로 중복 배제 (DRY) 원칙을 유지하는 데 도움이 된다.

#### 예외 상황 대응 또는 기본값

> 데이터를 변환할 때 자주 보이는 상황 중 하나는 뷰에 과도하게 방어적인 코드를 작성하는것이다.
> 방어적 프로그래밍은 다양한 상황에서 유용하게 사용되는 좋은 방법이지만, 컴포넌트 안에서 과도하게 널 체크를 하거나 예외 상황에 대한 대응 코드를 작성 하는 것은 복잡하게 하고 이해하기 어렵게 만든다.

`방어적 프로그래밍은 발생할수 있는 오류와 실패 또는 예외 상황 등을 자연스럽게 처리하기 위해, `