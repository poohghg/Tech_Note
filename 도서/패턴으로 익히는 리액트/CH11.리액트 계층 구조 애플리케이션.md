> 애플리케이션이 점차 커지고 복잡해지면 코드를 효율적으로 관리하기 어려워진다.
> 기능은 선형적으로 추가되지만, 코드의 복잡도는 기하급수적으로 증가하여 읽는 것뿐만 아니라 테스트와 유지보수도 어려워진다. 계층 구조는 애플리케이션 개발에 유용한 접근 방식이다.

#### 1. 계층화의 이점

- 관심사 분리: ==서로 다른 계층은 각기 다른 책임==을 다루게 되므로 코드베이스를 쉽게 이해하고 찾아 볼 수 있다.
- 높은 재사용성: 비지니스 로직과 데이터 모델을 애플리케이션 전반에서 재사용하기 쉬워진다.
- 테스트 용이성: 계층 구조는 테스트와 통합 테스트를 작성하기 수월하게 하므로 더욱 탄탄한 애플리케이션을 만들 수 있다.
- 유지보수성: 계층 구조로 설계하면 애플리케이션이 커지더라도 기능을 추가하기가 수월해진다.

> 단일 컴포넌트를 여러 개로 분할하면 각 컴포넌트의 기능 구현에 집중할 수 있다는 장점이 있다.
> 단일 컴포넌트를 복합 컴포넌트로 변경하면 컴포넌트마다 역할이 나뉘게 된다.
> 
> 컴포넌의 역할이 분명해진 것은 좋지만, 애플리케이션이 커질수록 역할이 뷰 계층을 넘어 확장된다.
> 네트워크 요청을 보내거나 뷰에서 사용할 수 있는 형태로 데이터를 가공하거나, 서버에 전달할 데이터를 모으는 등의 작업이 추가되기 때문이다. 이러한 로직을 뷰 내부에 가지고 있는 것은 사용자 인터페이스와 직접 관련이 없기 때문에 적절하지 않다.결과적으로 컴포넌트는 내부 상태가 과도하게 늘어나서 혼란스러워진다.


![[Pasted image 20250927193908.png]]

>몇 개의 순수 프레젠테이션 컴포넌트와 상태가 있고 컴포넌트로 만들 수 있게 해주는 재사용 가능한 훅, 그리고 데이터 요청 등의 기능을 다루는 컨테이너 컴포넌트가 있다.
>
>이 단계에서는 계산 로직들이 뷰와 훅, 기능 함수 등에 분산되어 있다.

![[Pasted image 20250927194358.png]]

> 컨테이너 컴포넌트(Container Component)를 나누는 기준은 주로 **관심사 분리(Separation of Concerns)**와 **도메인(Domain) 또는 기능 영역**에 기반한다.  `Page > Container >Presentational Component (PC)`는 리액트에서 매우 권장되는 패턴이다.

#### 컨테이너 컴포넌트를 나누는 기준

> 컨테이너 컴포넌트는 단일 책임 원칙(SRP)을 준수하도록 설계되어야 한다. 이 컴포넌트의 주된 책임은 데이터를 가져오고, 상태를 관리하며, 비즈니스 로직을 처리하는 것이다.

 1. 도메인(Domain) 또는 기능 영역별 분리

 특정 도메인(업무 영역)과 관련된 데이터와 로직은 하나의 컨테이너로 묶s 
- **예시:** 결제 페이지(`PaymentPage`)에는 다음과 같은 컨테이너가 있을 수 있습니다.
    - **`PaymentInfoContainer`:** 결제 수단 목록 가져오기(`usePaymentMethods`), 결제 처리 로직 관리.
    - **`OrderSummaryContainer`:** 주문된 상품 목록, 할인 정보, 총액 계산(`useRoundUp` 포함).
    - **`ShippingAddressContainer`:** 배송지 목록 및 선택 로직.
        

2. 독립적인 데이터 생명주기 및 상태 관리

데이터를 가져오는 시점이나 상태 변화가 다른 섹션과 완전히 독립적일 때 분리합니다.

- **독립적인 데이터 Fetching:** 한 섹션의 데이터 로딩 실패나 리프레시가 다른 섹션에 영향을 주지 않아야 할 때 별도의 컨테이너를 사용합니다.
- **자체 상태:** 특정 섹션의 UI 상호작용(예: 폼 입력, 토글)에 대한 상태가 다른 섹션과 무관하게 관리될 때 컨테이너로 분리합니다.

3. 재사용 가능한 기능 단위

페이지 내부의 섹션이지만, 다른 페이지에서도 **동일한 로직 묶음**을 필요로 한다면 컨테이너로 분리합니다.
- **예시:** 위시리스트에 상품을 추가하는 기능을 여러 페이지에서 사용해야 한다면, 이 기능을 캡슐화한 **`WishlistContainer`**를 만들어 필요한 페이지에 삽입할 수 있습니다.
#### 권장되는 계층 구조: P > C > PC

 **Smart/Dumb Component 패턴** 또는 **Container/Presentational 패턴**이라고 불리며, 리액트 프로젝트에서 로직을 구조화하는 표준적인 방법 중 하나이다.

| 계층                      | 이름        | 주요 책임 (Focus)                                                                                | 예시                               |
| ----------------------- | --------- | -------------------------------------------------------------------------------------------- | -------------------------------- |
| **P (Page)**            | 페이지 컴포넌트  | **레이아웃 및 구성(Composition)**. 어떤 컨테이너나 컴포넌트를 어디에 배치할지 결정. _최상위 컨테이너 역할도 겸할 수 있음._              | `<PaymentPage>`                  |
| **C (Container)**       | 컨테이너 컴포넌트 | **도메인 로직 및 데이터 처리**. Hooks 사용, Context 관리, 비즈니스 로직(총액 계산 등) 실행.                              | `<OrderSummaryContainer>`        |
| **PC (Presentational)** | 표현 컴포넌트   | **UI 렌더링**. 오직 Props로 받은 데이터를 화면에 표시하고, 사용자 이벤트를 Props 함수를 통해 상위로 전달. _Hooks/Context 사용 금지._ | `<DonationCheckbox>`, `<Button>` |
|                         |           |                                                                                              |                                  |

#### 장점

1. **명확한 관심사 분리:** 로직(`C`)과 뷰(`PC`)가 완전히 분리되어 `PC`는 **재사용성**이 극대화되고, `C`는 **테스트**가 용이해집니다.
2. **쉬운 통합 테스트:** `PC`는 Props만 Mocking하여 쉽게 테스트 가능하며, `C`는 데이터/로직을 테스트하는 데 집중할 수 있습니다.
3. **유지보수성:** UI가 변경되어도 로직 컴포넌트(`C`)는 그대로 두고 `PC`만 수정하면 되며, 반대의 경우도 마찬가지입니다.

``` tsx
  export const Payment = ({ amount }: { amount: number }) => {
    const { paymentMethods } = usePaymentMethods();
  
    const { total, tip, agreeToDonate, updateAgreeToDonate } = useRoundUp(amount);
  
    return (
      <div>
        <h3>Payment</h3>
        <PaymentMethods options={paymentMethods} />
        <DonationCheckbox
          onChange={updateAgreeToDonate}
          checked={agreeToDonate}
          content={formatCheckboxLabel(agreeToDonate, tip)}
        />
        <button>${total}</button>
      </div>
    );
  };
```

(Container)**인 `Payment`가 모든 로직과 데이터를 처리하고, (Presentational)인 하위 컴포넌트들이 오직 UI만 렌더링하도록 Props를 받는 모범적인 구조**

- **상위에서 훅을 모으는 방식**은 **통합 테스트와 데이터 흐름 가시성**에 유리하고, 재사용성을 확보함.
- **하위로 훅을 내리는 방식**은 **응집도와 SRP**에 유리하고, 단위 테스트가 쉬움.

| 기준          | 상위에 훅                  | 하위에 훅               |
| ----------- | ---------------------- | ------------------- |
| **응집도**     | 낮음 (데이터-UI 분리)         | 높음 (컴포넌트 자율성↑)      |
| **SRP**     | Payment 책임 커짐          | 컴포넌트별 책임 분리 명확      |
| **데이터 플로우** | 한눈에 명확                 | 분산되어 추적 어려움         |
| **재사용성**    | 자식 컴포넌트 재사용 쉬움         | 재사용 어려움 (데이터 소스 고정) |
| **단위 테스트**  | 자식은 mock 필요            | 자식만 독립적으로 테스트 가능    |
| **통합 테스트**  | 쉽다 (Payment 하나로 전체 검증) | 어렵다 (mock 분산 필요)    |