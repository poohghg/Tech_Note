타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 추론은 수동으로 명시해야 하는 타입 구문의 수를 줄여 주기 때문에 , 코드의 전체적인 안정성이 향상된다. 해당 챕터에서는 타입 추론에서 발생 할 수 있는 몇 가지 문제와 그 해법을 안내한다.

### 아이템19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

타입스크립트에서 많은 타입 구문은 사실 불필요 할 수 있다. 모든 코드에 타입을 선언하는 것은 비생산적이고 형편없는 스타일로 여겨 질 수 있다.

비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 한다. 여기에 추가로 명시적 타입 구문을 넣는다면 불필요한 타입 선언으로 인해 코드가 번잡해 질 수 있다.

정보가 부족해서 타입스크립트가 스스로 타입을 판단하기 어려운 상황도 일부 있다.
일반적으로 타입스크립트에서 변수의 타입은 처음 등장할 때 결정된다.

==이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는다. 타입 구문을 생략하여 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 하는 것이 좋다.==

객체 리터럴의 경우 타입을 명시 하면 좋다. ==잉여 속성 체크==가 동작하여, 선택적 속성이 있는 타입의 오타 같은 오류를 잡는 데 효과적이다. 그리고 변수가 사용 되는 순간이 아닌 할당하는 시점에 오류가 표시 되도록 한다.

함수의 반환에 타입을 명시하는 이점
- 반환 타입을 명시하면, 구현상의 오류가 사용자 코드의 오류로 표기 되지 않는다.
- 반환 타입을 명시하는 것은 함수를 더욱 명확하게 정의하는 것이다.
	- 타입 시그니처를 먼저 작성하면 구현에 맞추어 함수를 정의 할 수 있다.
- 반환 타입을 명시하면 명명된 타입을 사용 할 수 있다.

###### 요약
- 타입스크립트가 타입을 추론 할 수 있다면 타입 구문을 작성하지 않는게 좋다.
- 이상적인  경우 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없다.
- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해 준다.
---
### 아이템20. 다른 타입에는 다른 변수 사용하기

변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다. 타입을 바꿀 수 있는 한 가지 방법은 범위를 좁히는 것인데 새로운 변수값을 포함하도록 확장하는 것이 아니라 타입을 더 작게 제한하는 것이다.

==동일한 변수명에 타입이 다르다면, 타입스크립트 코드는 잘 동작할지 몰라도 사람에게 혼란을 줄 수 있다.==
목적이 다른 곳에는 별도의 변수명을 사용하는게 좋다.
- 유니온 타입을 선언시에는 사용할때마다 확인 과정(타입 체크)이 필요하다.

###### 다른 타입에 별도의 변수를 사용하는게 바람직한 이유
- 서로 관련이 없는 두 개의 값을 분리 할 수 있다.
- 변수명을 더 구체적으로 지을 수 있다.
- 타입 추론을 향상시키며, 타입 구문이 불필요 해진다.
- 타입이 좀 더 간결해진다.
- const 키워드를 사용하면 코드가 간결해지고, 타입 체커가 타입을 추론하기 좋다.

###### 요약
- 변수의 값은 바뀔 수 있지만 타입은 일반적으로 바뀌지 않는다.
- 혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재상용하지 않다록 해야 한다.
---
### 아이템21.타입 넓히기

런타임에 모든 변수는 유일한 값을 가진다. 그러나 ==타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에, 변수는 "가능한" 값 들의 집합인 타입을 가진다.== 상수를 사용해서 변수를 초기화 할 때 타입을 명시하지 않으면 타입체커는 타입을 결정해야 한다. 즉 단일 값을 가지고 할당 가능한 값 들의 집합을 유추해야 한다는 뜻이다. 타입스크립트에서 이과정을 넓히기 라고 부른다.
- 타입 넗히기가 진행될 때, 주어진 값으로 추론 가능한 타입이 여러 개이기 때문에 상당히 모호하다.

###### 타입 넓히기 과정을 제어 할 수 있는 방법
1. const 사용 하기 const를 사용 하여 원시타입의 변수를 선언하면 더 좁은 타입이 된다.
	- const로 원시 타입인 값을 선언하면 해당 타입은 리터럴 타입으로 선언된다.
	 ![Pasted image 20241030144834.png](../../img/Pasted%20image%2020241030144834.png)
2. 객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것 처럼 다룬다.
	- 명시적인 타입 구문을 제공
	- 타입 체커에 추가적인 문백을 제공
	- as const 사용하기
		- as const를 작성하면, 타입스크립트는 최대한 좁은 타입으로 추론한다.
		- 배열을 튜플 타입으로 추론할 때에도 as const를 사용할 수 있다.

타입 넓히기로 인해 오류가 발생한다고 생각되면, 명시적 타입 구문 또는 const 단언문을 추가하는 것을 고려해야 한다.

###### 요약
- 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법을 이해해야 한다.
- 동작에 영향을 줄 수 있는 방법인 const, 타입 구문, 문맥, as const에 익숙해져야 한다.
---
### 아이템 22.타입 좁히기

타입 좁히기는 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말한다.
타입스크립트는 아래와 같은 조건문에서 타입 좁히기를 잘 해내지만, 타입별칭이 존재 한다면 그러지 못할 수도 있다.

```
const el = document.getElementById('el'); // 타입이 HTMLElement | null 또는   
// 분기문을 통한 타입 좁히기
if (el) {  
	el.innerHTML = 'Hello';  
}
```

###### 타입을 좁히는 방법들
- 조건문을 통한 타입 검사
- 인스턴스의 경우 instanceof를 사용
- 속성 체크
	- 객체 속성 체크 in 연산자를 활용
- ==명시적 태그사용==
	- 태그된 유니온 또는 구별된 유니온이라고도 한다.
	- 타입 분기를 위한 명시적인 속성값을 추가하는것이다.
		- 개인적으로 가장 선호하는 방식이다.
- 사용자 정의 타입 가드
	- 타입 식별을 위한 커스텀 함수를 사용 하는것이다.

``` tsx
// 명시적 태그 사용

interface Square {  
  kind: 'square';  
  size: number;  
} 

interface Rectangle {  
  kind: 'rectangle';  
  width: number;  
  height: number;  
}  

interface Circle {  
  kind: 'circle';  
  radius: number;  
} 

type Shape = Square | Rectangle | Circle;  

function getArea(s: Shape): number {  
  switch (s.kind) {  
    case 'square':  
      return s.size * s.size;  
    case 'rectangle':  
      return s.height * s.width;  
    case 'circle':  
      return Math.PI * s.radius ** 2;  
    default:  
      const _exhaustiveCheck: never = s;  
      return _exhaustiveCheck;  
  }  
} 


```

###### 요약
- 분기문 외에도 여러 종류의 제어 흐름을 살펴보며 타입스크립트가 타입을 좁히는 과정을 이해해야 한다.
- 태근된/구변된 유니온과 사용자 정의 타입 가드를 사용하여 타입 좁히기 과정을 원할하게 만들 수 있다.
---
### 아이템 23.한꺼번에 객체 생성하기

==타입스크립트의 타입은 일반적으로 변경되지 않는다. 이러한 특성 덕분에 일부 자바스크립트 패턴을 타입스크립트로 모델링 하는게 쉬워진다.== 즉, 객체를 생성할 때는 속성을 하나씩 추가 하기보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.

```
interface Point {  
	x: number;  
	y: number;  
} 

// 타입 단언을 통해 객체를 생성해서 객체 속성값을 추가 할 수 있지만, 타입 과 실제 속성값이 맞지 않기에 위험한 방법이다.

const point: Point = {} as Point;  
point.x = 10;  
point.y = 20;

```

객체 전개 연사자를 사용하면 타입 걱정 없이 필드 단위로 객체를 생성할 수 있다. 업데이트 마다 새 변수를 사용하여 각각 새로운 타입을 얻도록 하는 게 중요하다.

객체가 유니온 타입이 아닌 추가적인 속성을 옵셔널로 표현하려면 아래와 같은 헬퍼 함수가 도움이 된다.

```
const addOptionalProperty = <T extends object, U extends Object>(  
	a: T,  
	b: U,  
): T & Partial<U> => {  
	return { ...a, ...b };  
};
```

###### 요약
- 속성을 제각각 추가하지 말고 한꺼번에 객체로 만들어야 한다. 안전한 타입으로 속성을 추가하려면 전개연사자를 사용하면 된다.
---
### 아이템24. 일관성 있는 별칭 사용하기

별칭을 남발해서 사용하면 제어 흐름을 분석하기 어렵다. 별칭을 신중하게 사용해야 한다. 그래야 코드를 잘 이해할 수 있고, 오류도 쉽게 찾을 수 있다.
- 객체의 비구조화를 이용하면 보다 간결한 문법으로 일관된 이름을 사용 할 수 있다.
###### 요약
- 별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.
- 비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.
- 함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 한다. 속성 보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.
---
### 아이템25. 비동기 코드는 콜백 대신 async 함수 사용하기

과거의 자바스크립트에서는 비동기 동작을 모델링하기 위해 콜백을 사용했고, 필연적으로 콜백 지옥을 마주할 수 밖에 없었다. 콜백이 중첩된 코드는 직관적으로 이해하기 어렵다.

ES2015는 콜백 지옥을 극복하기 위해 프로미스(promise) 개념을 도입했다. 프로미스는 미래에 가능해질 어떤 것을 나타낸다.

ES2017에서는 async와 await키워드를 도입하여 콜백 지옥을 더욱 간단하게 처리 할 수 있게 되었다.

==ES2015 또는 더 이전 버전을 대상으로 할 때, 타입스크립트 컴파일러는 async와await가 동작하도록 정교한 변환을 수행한다. 타입스크립트는 런타임에 관계없이 async/await를 사용할 수 있다.==

프로미스 생성보다 async/await를 사용해야 하는 이유
- 일반적으로 더 간결하고 직관적인 코드가 된다.
- async함수는 항상 프로미스를 반환하도록 강제 한다.

즉시 사용 가능한 값에도 프로미스를 반환하는게 이상하게 보일 수 있지만, 실제로는 비동기 함수로 통일하도록 강제하는 데 도움이 된다. 함수는 항상 동기 또는 비동기 함수로 실행되어야 하며 절대 혼용 해서는 안된다.
###### 요약
- 콜백보다는 프로미스를 사용하는 게 코드 작성과 타입 추론 면에서 유리하다.
- 가능하면 프로미스를 생성하기보다는 async/await를 사용하는 것이 좋다. 간결하고 직관적인 코드를 작성 할 수 있고 모든 종류의 오류를 제거 할 수 있다.
- 어떤 함수가 프로미스를 반환한다면 async로 선언하는 것이 좋다.
---
### 아이템 26.타입 추론에 문맥이 어떻게 사용되는지 이해하기

타입스크립트는 타입을 추론할 때 단순히 값만 고려하지 않는다. 값이 존재하는 곳의 문맥 까지도 살핀다.
문맥과 값을 분리하면 추후에 근본적인 문제를 발생시킬 수 있다.

- 명확한 타입을 부여하기
- as const를 사용해서 상수화 시키기.

###### 요약
- 타입 추론에서 문맥이 어떻게 쓰이는지 주의해서 살펴봐야 한다.
- 변수를 뽑아서 별도로 선언했을 때 오류가 발생한다면 타입 선언을 추가해야 한다.
- 변수가 정말로 상수라면 상수 단언(as const)을 사용해야 한다. 그러나 상수 단언을 사용하면 정의한 곳이 아니라 사용한 곳에서 오류가 발생 하므로 주의해야 한다.
---
### 아이템 27. 함수형 기법과 라이브러리로 타입 흐름 유지하기

###### 요약
- 타입 흐릅음 개선하고, 가독성을 높이고, 명시적인 타입 구문의 필요성을 줄이기 위해 직접 구현하기보다는 내장된 함수형 기법과 로대시 같은 유틸리티 라이브러리르 사용하는 것이 좋다.