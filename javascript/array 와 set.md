## 1. **데이터 구조 및 내부 구현**

### 배열 (`Array`)

- **구조**: 순차적으로 데이터를 저장하는 **리스트형 데이터 구조**.
- **내부 구현**: 일반적으로 연속된 메모리 공간에 데이터를 저장하는 방식. 하지만 자바스크립트의 배열은 실제로 객체처럼 동작하며, 효율적인 인덱싱과 순회에 최적화된 구조입니다.

### Set

- **구조**: 중복을 허용하지 않는 **집합형 데이터 구조**.
- **내부 구현**: 대부분의 자바스크립트 엔진은 `Set`을 해시 테이블로 구현. 이는 키-값 매핑을 사용하는 `Map`과 비슷하지만, 키만 저장하며 중복을 자동으로 제거.

---

## 2. **주요 차이점 비교**

|**특징**|**Array**|**Set**|
|---|---|---|
|**중복 허용**|중복된 값을 허용.|중복된 값을 허용하지 않음.|
|**순서 보장**|값이 삽입된 순서를 유지함.|값이 삽입된 순서를 유지함.|
|**탐색 시간 복잡도**|O(n) (순차 탐색 시)|O(1) (평균적으로 빠른 탐색)|
|**삽입 시간 복잡도**|O(1) (끝에 추가 시) 또는 O(n) (특정 위치)|O(1)|
|**삭제 시간 복잡도**|O(n) (값 삭제 시, 검색 포함)|O(1)|
|**요소 접근 방식**|인덱스 기반으로 접근 가능.|인덱스가 없으며, 직접 접근 불가.|
|**유일성 보장**|직접 중복을 확인해야 함 (`new Set()` 사용 가능).|자동으로 유일성 보장.|

## 3. **성능 비교**

### 탐색 성능

- **배열**: `includes`나 `indexOf`를 사용하면 값이 배열에 있는지 순차적으로 탐색하므로 최악의 경우 O(n).
- **Set**: 해시 테이블 기반으로 구현되어 `has` 메서드는 평균적으로 O(1).

### 삽입 및 삭제 성능

- **배열**: 값 추가/삭제 시에는 인덱스 위치에 따라 성능이 다름.
    - 끝에서 추가/삭제: O(1).
    - 중간에서 추가/삭제: O(n) (재배치 필요).
- **Set**: 삽입과 삭제 모두 평균적으로 O(1).

### 메모리 사용

- **Set**: 중복 제거와 해시 테이블 유지 비용 때문에 배열보다 메모리 소비가 약간 높음.
- **배열**: 일반적으로 메모리를 더 적게 사용.

---

## 5. **실제 사용 사례**

### 배열 사용 사례

1. 순서가 중요한 데이터.
2. 중복이 허용되는 데이터.
3. 특정 위치에서 값 접근이나 조작이 필요한 경우.

예:

- 사용자 목록, 점수 배열 등.

### Set 사용 사례

1. 데이터의 유일성이 중요한 경우.
2. 빠른 조회, 삽입, 삭제가 필요한 경우.
3. 중복 제거가 자동으로 이루어져야 하는 경우.

예:

- 유일한 태그 리스트, 중복되지 않는 ID 관리 등.

