자바스크립트는 객체를 상속하기 위하여 포로토타입 방식을 사용한다.

자바스크립트는 흔히 프로토타입 기반 언어라 불린다. 모든 객체들이 메소드와 속성들을 상속받기 위한 템플릿으로써 프로토타입 객체를 가


**자바스크립트는 객체기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 원식타입을 제외한 모든값들은 객체로 구성되어 있다.**

자바스크립트의 모든 객체는 객체간 상속을 위해 object라는 내부의 prototype 가지고 있다.
- 자바스크립트의 내장된 기본 상태 및 함수이다.
- 직접 접근은 불가하지만, 내부슬롯의 경우 `__proto__` 접근자 프로퍼티를 통해 간접적으로 접근할 수 있다.

자바스크립트에서 객체간 상속의 연결고리는 프로토타입 체인으로 연결되어 있다
- 배열 -> array -> object

자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 속성을 기본값으로 자동정의한다.

#### 데이터 프로퍼티: 키와값으로 구성된 일반적인 프로퍼티.
- value: 객체속성의 값
- writable: 값을 변경할수 있을지의 유무(값의 갱신 가능 여부)
- enumerable: 속성을 열거가능한지
    - -false 인경우 in, Object 문의 열거함수로 열거 할 수없다.
- configurable: 속성이 삭제될수 있는지유무(재정의 가능 여부)

```js
const obj1 = {
  name: 'kwon',
  age: 31,
  desc() {
    return `age:${this.age},name:${this.name}`;
  },
};
// 객체의 권한을 수정해서 객체를 관리 할 수 있다.
Object.defineProperties(obj1, {
  name: {
    writable: false,
  },
  age: {
    value: 29,
    enumerable: false,
  },    
}); 
/**
{
  name: {
    value: 'kwon',
    writable: false,
    enumerable: true,
    configurable: true
  },
  age: { value: 29, writable: true, enumerable: false, configurable: true },
  desc: {
    value: [Function: desc],
    writable: true,
    enumerable: true,
    configurable: true
  }
*/
console.log(Object.getOwnPropertyDescriptors(obj1));
```

#### 접근자 프로퍼티
접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할때 사용하는 접근자 함수로 구성된다.

```js
function accesoorProtp() {
  const user = {
    name: 'kwon',
    age: 31,
    get ageInfo() {
      return `${this.age}`;
    },
    set ageInfo(age) {
      this.age = age;
    },
  };

  // setter 호출
  user.ageInfo = 33;
  // getter 호출
  console.log(user.ageInfo);
}
```

#### 프로퍼타입

프로퍼타입은 어떤 객체의 상위 객체의 역할을 하는 객체다. 프로퍼타입은 하위 객체에게 자신의 프로퍼티와 메서드를 상속한다. 하위 객체는 상위 프로퍼타입의 프로퍼티 또는 메서드를 사용 할 수 있다. 프로퍼타입 체인은 단방향 링크드리스트 형태로 구성되어 있다. 객체나 메서드에 접근하려 할때 해당 객체의 프로퍼티 또는 메서드가 없다면, 프로퍼타입 체인을 따라 상위 프로퍼타입을 검색한다.

프로토타입 확인해보기

``` js
function checkProtoLevel(params) {
  function Info(name, age) {
    this.name = name;
    this.age = age;
    // 인스턴스 레벨의 함수
    // 각각의 객체마다 함수를 생성해서 가지고 았다.
    // 메모리상 비효율적.
    // this.printinfo = function () {
    //   return `name:${this.name}/age:${this.age}`;
    // };
  }
  // 프로토타입의 함수를 생성하면, 프로타타입레벨의 함수를 가질수 있다.
  Info.prototype.printUser = function () {
    return `name:${this.name}/age:${this.age}`;
  };
  const kwon = new Info('kwon', 31);
  const kim = new Info('kim', 27);
  console.log(kwon);
}
```