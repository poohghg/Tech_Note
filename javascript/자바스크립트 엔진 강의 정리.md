해당 내용은 인프런 인강을[강의](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A4%91%EA%B3%A0%EA%B8%89/dashboard)내용을 정리 하였습니다.
- [ECMAScript2025](https://tc39.es/ecma262/#sec-intro)
- https://gamguma.dev/post/2022/04/js_execution_context

### ES3/ES5 스펙의 아키텍처, 메커니즘 관련 키워드

엔진 처리는 해석과 실행으로 나눌 수 있다.
- 해석이란: 컴파일과 실행할 환경을 설정하는 것이다.
- 실행이란


- EC(Execution Contexts): 실행 컨테스트
	- 실행 컨테스트란 함수가 호출되었을 때 함수가 실행 될 수 있는 환경
	- 함수가 실행 되었을때 결과를 저장하는 영역
	- 즉 실행하는 코드의 묶음이다.
	- LEC(Lexical Environments): 렉시컬 환경 컴포넌트

ER: 환경 레코드

- DER: 선언적 환경 레코드
- OER: 오브젝트 환경 레코드

OLER: 외부 렉시컬 환경 참조

VEC: 변수 환경 컴포넌트

TBC: this 바인딩 컴포넌트

### 실행 컨테스트 형태

```javascript
function book() {
  var point = 123

  function show() {
    var title = 'JS책'
  }

  function getPoint() {
    return point
  }

  show()
}

book()
```

![image-20240302203347182](/Users/khg/Library/Application Support/typora-user-images/image-20240302203347182.png)

- book 함수의 호출과정

  - show Function 오브젝트 생성
  - show의 [[scope]]에 스크프 설정

- show 함수의 호출과정(실행과정)

  - EC(실행 컨테스트) 생성

    - 함수는 실행전 선언단계에서 이미 [[scope]]에 스크프 설정을 한다.

  - 이는 함수 실행을 위한 Context 환경 구축이다.

    - 함수가 메모리에 올라가기 전 참조 환경(정적 환경)을 구축한다. 이를 실행 컨테스트라고 한다.

      - 함수 실행시 컨테스트가 참조된다.

    - LEC(렉시컬 환경 컴포넌트) 생성

      - 정적인 렉시컬 환경 컴포넌트를 생성한다.

      - ER(환경 레코드)

        - DER (선언적 환경 레코드)
        - 함수에서 값을 구하는 형태
          - 파라메터 에서 값을 구한다.
          - 변수 선언으로 값을 구한다.
          - 함수호출로 호출 된 함수의 반환값을 사용 할 수 있다.
          - 함수 밖의 값을 구할수 있다.
            - show 함수의 [[scope]]에 함수가 선언된 스코프를 알 수 있다.
          - this를 통해 값을 구을 구한다.
            - this는 해당 함수가 선언된 오브젝트를 참조한다.
              - 오브젝트가 없을시 글로벌 오브젝트 = 호스트 오브젝트를 참조한다.
              - window | global
            - 이는 TBC의해 일어난다.
        - OER(오브젝트 환경 레코드)

      - OLER(외부 렉시컬 환경 레코드)

        ```javascript
        {
          point:123
          getPoint:funcion(){}
        }
        ```

    - VEC 생성

      - 변수 환경 컴포넌트로 초기 렉시컬 환경 컴포넌트와 변수 환경 컴포넌트의 값은 동일하다.

    - TBC에 글로벌 오브젝트 바인딩

  - LEC에 ER, OLER 첨부

  - ER에 DER, OER 첨부

- DER에 show 함수의 변수, 함수 기록

- OLER에 show의 [[scope]]를 설정

- this 바인딩 컴포넌트에 this 참조 설정



### 식별자 해결

- 식별자 해결

  - 사용할 변수/함수를 결정하는것

  - 신속,정확한 검색을 위한 스코프 필요

- 스코프에서 이름을 찾기 위해

  - 스코프에 이름을 설정
  - 값을 변경되지만, 이름은 변경되지 않음
    - 자바스크립트의 값 저장형태가 프로퍼티이기 때문이다.
  - 식별자 해결 대상은 이름

- 스코프의 용도

  - 식별자 해결을 위한 수단,방법
  - 스코프가 목적이 아님
  - 식별자가 유일하면 스코프는 필요하지 않음
    - 하지만 유일하게 작성이 불가능 그래서 스코프가 필요
    - 계층적으로 스코프를 사용하는 이유

### 스코프 체인

- ES3
  - 스코프 체인은 식별자를 검색하기 위한 프로퍼티이다
    - {name:value} 리스트
  - 함수가 호출되면 스코프를 생성하고 {name:value} 형태로 설정한다. 
  - 생성한 스코프를 스코프 체인에 연결하고, 스코프 체인에서 식별자를 해결한다.
    - 동적으로 처리된다.
  - es5 에서는 스코프 체인은 없고, Activation object에 대응하는 렉시컬 환경이 있다.

### 렉시컬 환경(정적 환경)

```javascript
var point = 100

function book() {
  return getPoint()
}

book()
```

- function 키워드를 만나면
  - function 오브젝트를 생성한다.
  - 스코프(함수가 선언된 스코프)를 function object [[Scope]]에 설정
  - 이것은 함수 밖의(함수가 선언된 위치의) 스코프가 설정된다.
  - 함수 키워드를 만났을때 함수밖(상위)의 스코프가 결정된다.
  - 
    - 이는 정적으로 결정된다.
- 함수가 호출되면
  - function 오브젝트의 [[Scope]]를 실행 컨테스트의 렉시컬 환경 컴포넌트의 외 외부 렉시커 환경 참조에 설정
- 고전적인 var의 문제
  - var 키워드는 함수에서 선언시 내부 스코프를 참조
  - 하지만 함수가 아닌곳에서 선언시 글로벌 오브젝트에 설정됨
    - 최상위 글로벌 오브젝트에 선언되어 렉시컬 체인이 발생
  - 이는 렉시컬 환경 구조에 맞지 않음
  - 해결법 
    - use strict, let, const 키워드 사용
- 동적 환경을 구성 요소
  - with문, eval()함수


---
### this

this의 값은 함수를 호출한 방법의 의해 결정된다. 실행 중 할당으로 설정할 수 없고, 함수를 호출할 때 마다 다를 수 있다. es5는 함수를 어떻게 호출 했는지 상관하지 않고 this값을 설정할 수 있는 bind 메서드를 도입했고, es2015는 스스로의 this바인딩을 제공하지 않는 화살표 함수를 추가했다(렉시컬 컨테스트안의 this 값을 유지).
- this의 값은 런타임에 결정된다. 컨테스트에 따라 달라진다.
- 메서드가 어디서 정의되었는지(정적 렉시컬 환경)에 상관없이 this는 참조 객체가 무엇이지에 따라 결정된다.

#### 값

실행 컨텍스트(global, function 또는 eval)의 프로퍼티는 비엄격 모드에서 항상 객체를 참조한다. 엄격 모드에서는 어떠한 값이든 될 수 있다.

- 전역 문맥: 글로벌 오브젝트에서 this는 글로벌 오브젝트 참조
	- 전역 실행 맥락에서 this는 엄격 모드 여부에 관계 없이 전역 객체를 참조한다.
- 함수 문맥: 함수 내부에서 this의 값은 함수를 호출한 방법에 의해 좌우된다.
	- 비엄격 모드 - this의 값이 호출에 의해 설정되지 않으므로, host 오브젝트(window)를 참조
	- 엄격 모드 - this 값은 실행 문맥에 진입하며 설정되는 값을 유지한다.
- this와 window 오브젝트의 관계
	- window 객체는 JS에서 만든 것이 아니며 글로벌 오브젝트의 스코프도 아님
	- window 와 글로벌 오브젝트를 같은 선상에서 사용
		- 브라우저에서 window가 글로벌 오브젝트를 참조하므로 window.value 형태로 글로벌 변수가 사용 가능하다.
	- 이는 host 오브젝트 개념을 사용한 것이다.
		- window 오브젝트와 같이 다른 오브젝트를 사용하는 개념을 Host 오브젝트라고 한다.
		- DOM 오브젝트도 Host 오브젝트이다.
- 전역 스코프 내 함수 안에서 작성한 this는 글로버 오브젝트를 참조한다.
	- 함수 내부 this는 함수 앞에 작성한 오브젝트를 참조한다.

#### this 참조 범위
- 오브젝트.함수이름() 형태로 함수 호출
	- 글로벌 오브젝트는 오브젝트 이름이 없으므로 함수 이름만 작성하여 호출
- strict 모드에서는 window.book() 처럼 book() 앞에 window를 글로벌 오브젝트로 작성
- 함수 앞에 오브젝트를 작성하지 않으면
	- this 바인딩 컴포넌트에 undefined가 설정되어 this로 window를 참조 할 수 없음.

```js
function book() {  
	'use strict';  
	// undefined  
	return this;  
}

function book1() {  
	'use strict';  
	// undefined  
	return this;  
}

var obj = window.book();
obj === window // true
```

this가 참조하는 object
``` ts
const book = {  
	point: 200,  
	member: {  
		point: 100,
		// get 함수의 this 바인딩 컴포넌트는 book.member를 참조하고 있음.  
		get: function () {  
			console.log(this === book.member); // true  
			return this.point;  
	},  
		getArrow: () => {  
			console.log(this); // {}  
			return this.point;  
		},  
	},  
};  
  
console.log(book.member.get()); // 100  
console.log(book.member.getArrow()); // undefined
```

#### this와 인스턴스
- 인스턴스 목적 - 인스턴스마다 고유 값 유지
	- this로 인스턴스 참조
	- this.[value] 형태로 프로퍼티에 접근
- __ proto __ 프로프티 접근
	- prototype에 연결된 프로퍼티가 인스턴스의 __ proto __ 에 첨부되며
		- prototype에 연결된 프로퍼티는 모든 인스턴스가 공유하고,
	- this.method()형태로 __ proto __ 에 첨부된 method 호출
#### this 호출

`this`의 값을 한 문맥에서 다른 문맥으로 넘기려면 다음 예시와 같이 [`call()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call)이나 [`apply()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)를 사용해야 한다.

``` js
function add(c, d) {
  return this.a + this.b + c + d;
}

var o = { a: 1, b: 3 };

// 첫 번째 인자는 'this'로 사용할 객체이고,
// 이어지는 인자들은 함수 호출에서 인수로 전달된다.
add.call(o, 5, 7); // 16

// 첫 번째 인자는 'this'로 사용할 객체이고,
// 두 번째 인자는 함수 호출에서 인수로 사용될 멤버들이 위치한 배열이다.
add.apply(o, [10, 20]); // 34
```

> 비엄격 모드에서 `this`로 전달된 값이 객체가 아닌 경우, `call`과 `apply`는 이를 객체로 변환하기 위한 시도를 합니다. `null`과 `undefined` 값은 전역 객체가 됩니다. `7`이나 `'foo'`와 같은 원시값은 관련된 생성자를 사용해 객체로 변환되며, 따라서 원시 숫자 `7`은 `new Number(7)`에 의해 객체로 변환되고 문자열 `'foo'`는 `new String('foo')`에 의해 객체로 변환됩니다.

#### bind 메서드

`f.bind(someObject)`를 호출하면 `f`와 같은 본문(코드)과 범위를 가졌지만 this는 원본 함수를 가진 새로운 함수를 생성한다. 새 함수의 `this`는 호출 방식과 상관없이 영구적으로`bind()`의 첫 번째 매개변수로 고정된다.

#### 화살표 함수

화살표 함수에서 this는 자신을 감싼 정적 범위이다. 전여 코드에서는 전역 객체를 가르킨다.
화살표 함수 all()`, `bind()`, `apply() 를 사용해 호출 해도 생성 시점의 ==렉시컬 컨텍스트가== 유지 된다.
- 별개의 this가 만들어지지 않을때 사용.

> **참고**: 화살표 함수를 `call()`, `bind()`, `apply()`를 사용해 호출할 때 `this`의 값을 정해주더라도 무시합니다. 사용할 매개변수를 정해주는 건 문제 없지만, 첫 번째 매개변수(`thisArg`)는 `null`을 지정해야 합니다.

#### 객체의 프로토타입 체인에서의 this

객체의 프로토타입 체인 어딘가에 정의한 메서드가 어떤 객체의 프로토타입 체인 위에 존재하면, this의 값은 그 객체가 메서드를 가진 것 마냥 설정 된다.