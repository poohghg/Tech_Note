해당 내용은 인프런 인강을[강의](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A4%91%EA%B3%A0%EA%B8%89/dashboard)내용을 정리 하였습니다.

### 용어 정리

EC: 실행 컨테스트

LEC: 렉시컬 환경 컴포넌트

ER: 환경 레코드

- DER: 선언적 환경 레코드
- OER: 오브젝트 환경 레코드

OLER: 외부 렉시컬 환경 참조

VEC: 변수 환경 컴포넌트

TBC: this 바인딩 컴포넌트

### 실행 컨테스트 형태

```javascript
function book() {
  var point = 123

  function show() {
    var title = 'JS책'
  }

  function getPoint() {
    return point
  }

  show()
}

book()
```

![image-20240302203347182](/Users/khg/Library/Application Support/typora-user-images/image-20240302203347182.png)

- book 함수의 호출과정

  - show Function 오브젝트 생성
  - show의 [[scope]]에 스크프 설정

- show 함수의 호출과정(실행과정)

  - EC(실행 컨테스트) 생성

    - 함수는 실행전 선언단계에서 이미 [[scope]]에 스크프 설정을 한다.

  - 이는 함수 실행을 위한 Context 환경 구축이다.

    - 함수가 메모리에 올라가기 전 참조 환경(정적 환경)을 구축한다. 이를 실행 컨테스트라고 한다.

      - 함수 실행시 컨테스트가 참조된다.

    - LEC(렉시컬 환경 컴포넌트) 생성

      - 정적인 렉시컬 환경 컴포넌트를 생성한다.

      - ER(환경 레코드)

        - DER (선언적 환경 레코드)
        - 함수에서 값을 구하는 형태
          - 파라메터 에서 값을 구한다.
          - 변수 선언으로 값을 구한다.
          - 함수호출로 호출 된 함수의 반환값을 사용 할 수 있다.
          - 함수 밖의 값을 구할수 있다.
            - show 함수의 [[scope]]에 함수가 선언된 스코프를 알 수 있다.
          - this를 통해 값을 구을 구한다.
            - this는 해당 함수가 선언된 오브젝트를 참조한다.
              - 오브젝트가 없을시 글로벌 오브젝트 = 호스트 오브젝트를 참조한다.
              - window | global
            - 이는 TBC의해 일어난다.
        - OER(오브젝트 환경 레코드)

      - OLER(외부 렉시컬 환경 레코드)

        ```javascript
        {
          point:123
          getPoint:funcion(){}
        }
        ```

    - VEC 생성

      - 변수 환경 컴포넌트로 초기 렉시컬 환경 컴포넌트와 변수 환경 컴포넌트의 값은 동일하다.

    - TBC에 글로벌 오브젝트 바인딩

  - LEC에 ER, OLER 첨부

  - ER에 DER, OER 첨부

- DER에 show 함수의 변수, 함수 기록

- OLER에 show의 [[scope]]를 설정

- this 바인딩 컴포넌트에 this 참조 설정



### 식별자 해결

- 식별자 해결

  - 사용할 변수/함수를 결정하는것

  - 신속,정확한 검색을 위한 스코프 필요

- 스코프에서 이름을 찾기 위해

  - 스코프에 이름을 설정
  - 값을 변경되지만, 이름은 변경되지 않음
    - 자바스크립트의 값 저장형태가 프로퍼티이기 때문이다.
  - 식별자 해결 대상은 이름

- 스코프의 용도

  - 식별자 해결을 위한 수단,방법
  - 스코프가 목적이 아님
  - 식별자가 유일하면 스코프는 필요하지 않음
    - 하지만 유일하게 작성이 불가능 그래서 스코프가 필요
    - 계층적으로 스코프를 사용하는 이유

### 스코프 체인

- ES3
  - 스코프 체인은 식별자를 검색하기 위한 프로퍼티이다
    - {name:value} 리스트
  - 함수가 호출되면 스코프를 생성하고 {name:value} 형태로 설정한다. 
  - 생성한 스코프를 스코프 체인에 연결하고, 스코프 체인에서 식별자를 해결한다.
    - 동적으로 처리된다.
  - es5 에서는 스코프 체인은 없고, Activation object에 대응하는 렉시컬 환경이 있다.

### 렉시컬 환경(정적 환경)

```javascript
var point = 100

function book() {
  return getPoint()
}

book()
```

- function 키워드를 만나면
  - function 오브젝트를 생성한다.
  - 스코프(함수가 선언된 스코프)를 function object [[Scope]]에 설정
  - 이것은 함수 밖의(함수가 선언된 위치의) 스코프가 설정된다.
  - 함수 키워드를 만났을때 함수밖(상위)의 스코프가 결정된다.
    - 이는 정적으로 결정된다.
- 함수가 호출되면
  - function 오브젝트의 [[Scope]]를 실행 컨테스트의 렉시컬 환경 컴포넌트의 외 외부 렉시커 환경 참조에 설정
- 고전적인 var의 문제
  - var 키워드는 함수에서 선언시 내부 스코프를 참조
  - 하지만 함수가 아닌곳에서 선언시 글로벌 오브젝트에 설정됨
    - 최상위 글로벌 오브젝트에 선언되어 렉시컬 체인이 발생
  - 이는 렉시컬 환경 구조에 맞지 않음
  - 해결법 
    - use strict, let, const 키워드 사용
- 동적 환경을 구성 요소
  - with문, eval()함수


---
### this

- 글로벌 오브젝트에서 this는 글로벌 오브젝트 참조
- this와 window 오브젝트의 관계
	- window 객체는 JS에서 만든 것이 아니며 글로벌 오브젝트의 스코프도 아님
	- window 와 글로벌 오브젝트를 같은 선상에서 사용
		- 브라우저에서 window가 글로벌 오브젝트를 참조하므로 window.value 형태로 글로벌 변수가 사용 가능하다.
	- 이는 host 오브젝트 개념을 사용한 것이다.
		- window 오브젝트와 같이 다른 오브젝트를 사용하는 개념을 Host 오브젝트라고 한다.
		- DOM 오브젝트도 Host 오브젝트이다.
- 함수 안에서 작성한 this는 일반적으로 글로버 오브젝트를 참조한다.
	- 객체