해당 내용은 인프런 인강을[강의](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A4%91%EA%B3%A0%EA%B8%89/dashboard)내용을 정리 하였습니다.
- [ECMAScript2025](https://tc39.es/ecma262/#sec-intro)
- https://gamguma.dev/post/2022/04/js_execution_context

### ES3/ES5 스펙의 아키텍처, 메커니즘 관련 키워드

엔진 처리는 해석과 실행으로 나눌 수 있다.
- 해석이란: 컴파일과 실행할 환경을 설정하는 것이다.
- 실행이란: 해석 단계에서 설정된 환경을 바탕으로 코드를 실행하는 것이다.
	- 함수가 호출 된 다음의 실행이 이행.
- EC(Execution Contexts): 실행 컨테스트
	- 실행 컨테스트란 함수가 호출되었을 때 ==함수가 실행 될 수 있는 환경==
		- 실행 할 코드에 필요한 환경정보를 모아 놓은 객체이다.
		- 실행 컨테스트는 함수 선언 시 정적으로 생성된다.
	- 함수가 실행 되었을때 결과를 저장하는 영역
	- 즉 실행하는 코드의 묶음(contexts)이다.
		- 함수가 호출 되었을 때 어떻게 실행하는 묶음을 가져갈 것인지 결정하는 것
		- 식별자 해결을 통해 컨테스트를 생성
	- LEC(Lexical Environments): 렉시컬 환경 컴포넌트
		- ER(Environment Record): 환경 레코드
			- 스코프에 포함된 식별자와 식별자에 바인딩 된 값을 저장하는 자료구조
			- DER: 선언적 환경 레코드
			- OER: 오브젝트 환경 레코드
		- OLER: 외부 렉시컬 환경 참조
			- 상위 스코프에 접근할 수 있는 참조(스코프 체인)
			- 함수 선언 시 [ scope ] 에 외부 렉시컬 환경을 등록
	- VEC(Variable Environment Component): 변수 환경 컴포넌트: 컨테스트 내부의 식별자 정보, 외부 환경 정보가 포함되어 있다.
	- TBC(This Binding Component): this 바인딩 컴포넌트
		- this로 참조할 객체를 바인딩 한다.

![[Pasted image 20241112175537.png]]
##### 실행 컨테스트 형태
![[Pasted image 20241112173926.png]]

---
### Argument 처리 구조

함수가 호출되면 함수 안에서 argument 오브젝트를 생성한다.
- 파라미터를 { key : value} 형태로 저장
	- 파라미터 수만큼 인덱스 생성
		- 인덱스는 key로 사용
	- 파라미터로 받은 값을 value에 설정한다.
- Array-like 형태
	- key 값이 0부터 1씩 증가한다.
	- length 프로퍼티가 있음

엔진의 파라미터 처리 과정

``` js
const get = function(one){
	return one;
}

get(77,100)
```

- get 함수를 호출하면서 77과 100을 파라미터 값으로 넘긴다.
- 넘겨받은 값을 함수의 파라미터 이름에 설정한다.
	- 정적 환경의 선언적 환경 레코드에 설정한다.
		- 스코프에 등록한다.
	- one:77
-  argument 오브젝트를 생성한다.
	- 파라미터 수를 argument 오브젝트의 length 프로퍼티에 설정
- 넘겨받은 파라미터 수만큼 반복하면서 0 부터 key로 하여 순서대로 파라미터 값을 설정한다.
- 함수의 초기화 단계에서 실행

---
### 글로벌 오브젝트

글로벌 오브젝트의 특징
- JS 소스 파일 전체에서 글로벌 오브젝트는 하나만 존재한다.
	- new 연산자로 인스턴스 생성이 불가하다.
- JS 소프 파일 전체 기준
	-  <script/> 에 작성된 모든 코드
		- 모든 코드에서 사용 가능하다.

글로벌 스코프
- 글로벌 오브젝트가 글로벌 스코프
	- 글로벌 오브젝트는 실제 존재하지 않는다. ex) Number , String  등의 오브젝트
	- 호스트 오브젝트에 함수와 변수를 등록
		-  window, global 오브젝트
	- 글로벌 스코프는 최상위 스코프
		- 스코프 체인에서 최상위 스코프이다.

스코프 바인딩
 - 바인딩이란 구조적으로 결속된 상태로 만드는 것이다
	 - 대상: 프로퍼티 이름
 - 바인딩의 목적
	 - 스코프 설정,식별자 해결
 - 바인딩 시점 구분 
	 - 정적 바인딩 : lexical, static 바인딩
		 - 초기화 단계에서 바인딩
		 - 함수 선언문 이름을 바인딩
		 - 표현식(변수, 함수) 이름을 바인딩
	 - 동적 바인딩 : dynamic 바인딩
		 - 실행시 바인딩 처리
		 - eval함수, with문
 - 바인딩 시점의 중요성
	 - 바인딩할 때 스코프가 결정된다.
	 - function 오브젝의 경우 생성 시점에 스코프 결정
		 - 스코프를 function 오브젝트 내부 프로퍼티 Scope에 설정
		 - 스코프는 변경되지 않음

``` js
function book() {  
	var point = 100;  
	  
	function add(param) {  
		return (point += param);  
	}  
	  
	var get = function () {  
		return point;  
	};  
	  
	add(200);  
	console.log(point);  
}    
book();
```

1. book() 함수 호출 시 - 초기화 단계에서 함수와 변수 이름을 book 함수의 선언적 환경 레코드에 바인딩(식별자 해결)
2. function 오브젝트 add 생성
	1. add 함수가 속한 스코프 영역을 add 함수 오브젝트 프로퍼티 scope에 설정
	2. add 이름을 선언적 환경 레코드에 바인딩
3. point, get 이름을 선언적 환경 레코드에 바인딩
	1. 값은 undefined
	2. 여기 까지가 호이스팅
4. 함수와 변수의 식별자가 해결
---
### 식별자

식별자는 코드 내의 변수,함수, 혹은 속성을 식별하는 문자열이다.

자바스크립트에서 식별자는 대소문자를 구별하며 유니코드 글자 `$`, `_`, 숫자(0-9)로 구성할 수 있지만, 숫자로 시작할 수는 없다.

식별자는 코드의 일부이지만 문자열은 데이터이기 때문에, 식별자와 문자열은 다르다.JavaScript에서 식별자를 문자열로 변환하는 방법은 없지만, 어떤 경우 문자열을 분석해 식별자로 사용할 수 있습니다.

> https://developer.mozilla.org/ko/docs/Glossary/Identifier
---
### 스코프

스코프는 컨테스트의 값과 표현식이 표현되거나 참조 될 수 있는 현재 실행되는 컨테스트를 의미한다. 만약 변수 또는 표현식이 해당 스코프 내에 있지 않다면, 사용할 수 없다. 스코프는 계층적인 구조를 가지기 때문에, 하위 스코프는 상위 스코프에 접근 할 수 있다.
- 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다.
- 스코프의 목적은 범위를 제한하여 식별자를 해결하는 것이다.

함수는 자바스크립트에서 클로저 역할을 하기 때문에 스코프를 생성한다. 함수 내에 정의된 변수는 외부 함수나 다름 함수 내에서 접근 할 수 없다.

자바스크립트는 렉시컬 스코프를 따른다.함수가 정의된 위치에 따라 상위 스코프를 결정한다. 함수가 호출된 상위 스코프 결정에 영향을 주지 않는다. 함수의 상위 스코프는 언제나 정의된 스코프이다.

- 키워드를 만나 스코프를 결정하는 것을 정적 스코프라고 한다.
- 호출될 때 스크프를 결정하는 것을 동적스코프라고 한다.

자바스크립트에서는 다음과 같은 종류의 스코프가 있다.
- 전역 범위: 스크립트 모드에서 실행되는 모든 코드의 기본 범위이다.
- 모듈 범위: 모듈 모드에서 실행되는 코드의 범위이다.
	- module.exports
- 함수 범위: [function](https://developer.mozilla.org/ko/docs/Glossary/Function)로 생성된 범위입니다.
	- var키워드로 선언된 변수는 오로지 함수의 코드 블록 만을 **지역 스코프**로 인정한다.
		- 함수 레벨 스코프라고 한다.
	- 함수 외에서 var키워드로 선언한 변수는 전역 변수이다.
- 블록 범위: 중괄호 쌍(블록)으로 생성된 범위이다.
	- let,const 키워드로 변순 선언시 블록 레벨 스코프이다.
		- 변수 자체에 스코프 제약을 둔다.
	- 모든 코드 블록 (함수, if, for ,while , try/catch 등)을 지역 스코프로 인정

> https://developer.mozilla.org/ko/docs/Glossary/Scope
---
### 식별자 해결

스코프(유효 범위)를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용하게 하는것.
스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용 할 수 있다.

- 식별자 해결
	- 사용할 변수/함수를 결정하는것
	- 신속,정확한 검색을 위한 스코프 필요
- 스코프에서 이름을 찾기 위해 사용
	- 스코프에 이름을 설정
	- 값을 변경되지만, 이름은 변경되지 않음
    - 자바스크립트의 값 저장형태가 프로퍼티{key:value}이기 때문이다.
    - **식별자 해결 대상은 이름이다**.
- 스코프의 용도
  - 식별자 해결을 위한 수단,방법
  - 스코프가 목적이 아님
  - 식별자가 유일하면 스코프는 필요하지 않음
    - 하지만 유일하게 작성이 불가능 그래서 스코프가 필요
    - 계층적으로 스코프를 사용하는 이유이다.
---
### 스코프 체인

모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 스코프는 계층적으로 연결되어 있고 이를 스코프 체인이라 한다.
- 엔진은 스코프체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

##### ES3
  - 스코프 체인은 식별자를 해결을 위한 프로퍼티이다
    - {name:value} 리스트
    - ES5는 스코프는 사용하지만 스코프 체인은 사용하지 않는다.
  - 함수가 호출되면 스코프를 생성하고 {name:value} 형태로 설정한다. 
  - 생성한 스코프를 스코프 체인에 연결하고, 스코프 체인에서 식별자를 해결한다.
	  - 동적으로 처리된다.
	  - 이는 함수가 생성될 때 마다 스코프 체인이 동적으로 생성된다.
  - es5 에서는 스코프 체인은 없고, Activation object에 대응하는 렉시컬 환경이 있다.
	  - Activation object은 실행환경을 만드는것
##### ES5
- 렉시컬 환경의 선언적 환경 레코드에 함수의 변수와 함수 이름을 바인드
- 스코프 체인을 사용하지 않고, 선언적 환경 레코드에서 변수와 함수 이름을 검색


---
### 실행 컨테스트

실행 컨테스트의 개념은 코드가 내부에서 어떻게 작동 하는지 설명하는데 사용된다.  JavaScript 실행 컨텍스트는 코드를 실행할 수 있는 환경을 말한다. 실행 컨테스트는 코드 섹션이 코드의 함수, 변수 및 객체에 엑세스할 수 있는지 결정한다. 코드는 실행 컨테스트에서 줄별로 구분 분석되고, 변수와 함수는 메모리에 저장된다. 코드는 평가 후 실행 컨테스트에서 실행된다. 결과적으로 실행 컨테스트는 주어진 코드가 실행될 수 있는 환경을 만든는 것이다.
- 실행 컨테스트 런타임 동안 특정 코드는 파서에 의해 구문 분석되고, 변수와 함수는 메모리에 저장되고, 실행 가능한 바이트 코드가 생성되고, 코드가 실행된다.

자바스크립트에는 두 가지 종류의 실행 컨테스트가 있다
- 글로벌 실행 컨텍스트(GEC)
- 함수 실행 컨텍스트(FEC)

#### 글로벌 실행 컨텍스트(Global Execution Context ) 
JavaScript 엔진이 스크립트 파일을 로드 하고 파싱 후 생성되는 기본 컨텍스트이다.

JavaScript 코드를 로드하고 파싱한 후, JS 엔진은 기본 실행 환경으로 들어간다. JS 엔진이 글로벌 실행 환경 내부에 들어가면 기본적으로 window 객체와  this 객체가 글로벌 메모리에 생성됩니다.

window 객체는 글로벌 오브젝트를 참조한다. 전역 객체는 JS 엔진이 전역 실행 환경에 들어가기 전에 항상 생성되며 localStorage, innerWidth, 이벤트 핸들러 등의 속성과 메서드를 포함한다.



> 
> **#2 로컬/함수 실행 컨텍스트**
> 
> 함수가 호출되거나 호출되면 해당 함수에 대한 새로운 실행 컨텍스트가 형성됩니다. JS 엔진이 함수 호출을 보면 해당 함수에 대한 로컬 실행 컨텍스트를 만듭니다. 기본적으로 JS 엔진은 로컬 실행 컨텍스트 내에 arguments 객체와 _**this**_ 객체를 만듭니다.
> 
> 함수 내부에서 예상되는 매개변수의 키:값 쌍은 arguments 객체에 저장됩니다. 또한 함수가 가진 매개변수의 수를 세는 length라는 기본 속성도 있습니다. 함수의 인수가 비어 있으면 argument 객체는 기본적으로 길이 0 **으로** **설정** 됩니다 .
> 
> 함수가 호출되는 방식에 따라 함수 실행 컨텍스트의 _**this**_ 객체가 변경됩니다. 객체 참조를 사용하여 호출하는 경우 this의 값은 해당 객체로 설정됩니다. 그렇지 않으면 this 변수의 값은 window 객체 또는 _"undefined"_ 로 설정됩니다 .
> 
> **#3 Eval 함수 실행 컨텍스트**
> 
> eval 함수는 어떤 대가를 치르더라도 피해야 할 함수입니다. 실행 컨텍스트는 JS 엔진이 **eval()** 함수를 만날 때마다 생성되어 호출 스택에 푸시됩니다. 인수로 전달된 문자열을 평가합니다.
> 
> 결과적으로, 당신이 실수로 해로운 코드를 인수로 보냈거나, 적대적인 당사자가 당신의 코드의 이 부분을 사용한다면, 당신의 웹사이트는 심하게 손상될 수 있습니다. 이 기능은 더 나은 대안이 있기 때문에 권장되지 않습니다.**_


실행 컨테스트(Execution Contexts)
- 함수가 실행되는 영역,묶음
- 함수 코드를 실행하고, 실행 결과를 저장
- [스펙](https://tc39.es/ecma262/#sec-executable-code-and-execution-contexts)

#### 실행 단계
- 준비 단계
- 초기화 단계
- 코드 실행 단계

```javascript
function book() {
  var point = 123

  function show() {
    var title = 'JS책'
  }

  function getPoint() {
    return point
  }

  show()
}

book()
```

- book 함수의 호출과정
  - show Function 오브젝트 생성
  - show의 [[scope]]에 스크프 설정
- show 함수의 호출과정(실행과정)
  - EC(실행 컨테스트) 생성
    - 함수는 실행전 선언단계에서 이미 [ scope ] 에 스크프 설정을 한다.
  - 이는 함수 실행을 위한 Context 환경 구축이다.
    - 함수가 메모리에 올라가기 전 참조 환경(정적 환경)을 구축한다. 이를 실행 컨테스트라고 한다.
      - 함수 실행시 컨테스트가 참조된다.
    - LEC(렉시컬 환경 컴포넌트) 생성
      - 정적인 렉시컬 환경 컴포넌트를 생성한다.
      - ER(환경 레코드)
        - DER (선언적 환경 레코드)
        - 함수에서 값을 구하는 형태
          - 파라메터 에서 값을 구한다.
          - 선언된 변수 로 부터 값을 구한다.
          - 함수 호출로 호출 된 함수의 반환값을 사용 할 수 있다.
          - 함수 밖의 값을 구할수 있다.
            - show 함수의 [[scope]]에 함수가 선언된 스코프를 알 수 있다.
          - this를 통해 값을 구한다.
            - this는 해당 함수가 선언된 오브젝트를 참조한다.
              - 오브젝트가 없을시 글로벌 오브젝트 = 호스트 오브젝트를 참조한다.
              - window | global
            - 이는 TBC의해 일어난다.
        - OER(오브젝트 환경 레코드)
      - OLER(외부 렉시컬 환경 레코드)
        ```javascript
        {
          point:123
          getPoint:funcion(){}
        }
        ```
    - VEC 생성
	    - 변수 환경 컴포넌트로 초기 렉시컬 환경 컴포넌트와 변수 환경 컴포넌트의 값은 동일하다.
	    - TBC에 글로벌 오브젝트 바인딩
	- LEC에 ER, OLER 첨부
	- ER에 DER, OER 첨부
		- DER에 show 함수의 변수, 함수 기록
		- OLER에 show의 [ scope ]를 설정
	- this 바인딩 컴포넌트에 this 참조 설정
---

### Function 오브젝트

##### function 오브젝트 형태와 생성과정

- 빌트인 Function 오브젝트
	- Function.prototype.call()
	- 엔진이 function 키워드를 만나면 function 오브젝트 생성
- function 오브젝트
	- function book(){}: 함수 선언식
	- const book = function (){}: 함수 표현식
	- 저장 형태
		- { name : value } 형태로 저장
		- ex) { book : function 오브젝트} 형태
	- 호출
		- 저장된 오브젝트에서 함수 이름으로 검색
		- value을 구하고
		- value가 function 오브젝트이면 호출
	- 생성 과정
		- book function 오브젝트에 prototype 오브젝트 생성
		- prototype에 constructor 프로퍼티 생성
			- prototype.constructor가 book 참조
		- prototype에 __ proto __ 오브젝트 생성
			- ES6 스펙에 기술되어 있음
- function 인스턴스
	- new Book() 처럼 new 연산자를 사용
	- Book.prototype에 연결된 메서드로 생성

```js
book = {  
	prototype: {  
		constructor: book,  
		__proto__: Object.prototpye
	},
	__proto__: Function.prototpye  
};

```

---
### 렉시컬 환경(정적 환경)

```javascript
var point = 100

function book() {
  return getPoint()
}

book()
```

- function 키워드를 만나면
	- function 오브젝트를 생성한다.
	- 스코프(함수가 선언된 스코프)를 Function object [ Scope ]에 설정
		- 이것은 함수 밖의(함수가 선언된 위치의) 스코프가 설정된다.
		- function 키워드를 만났을때 함수밖(상위)의 스코프가 결정된다.
		- 함수가 호출 될 때 스코프가 결정되는 것이 아닌 function 키워드를 만났을 때 스코프가 결정된다.
		- 정적으로 결정된다 === 렉시컬 환경
- 함수가 호출되면
	- Function object 의 [ Scope ]를 실행 컨테스트의 렉시컬 환경 컴포넌트의 외부 렉시컬 환경 참조에 설정한다.
	- 함수가 호출 되었을때 함수의 선언된 변수와 함수를 선언적 환경 레코드에 등록하고
	- 스코프 정보를 통래 렉시컬 환경을 구성한다.

##### 고전적인 var의 문제
- var 키워드는 함수에서 선언시 내부 스코프를 참조
	- 하지만 함수가 아닌곳에서 선언시 글로벌 오브젝트에 설정됨
	- 최상위 글로벌 오브젝트에 선언되어 렉시컬 체인이 발생
	- 이는 렉시컬 환경 구조에 맞지 않음
- 해결법 
	- use strict, let, const 키워드 사용
- 동적 환경을 구성 요소
	- with문, eval()함수
		- with문 은 strict 모드에서 에러 발생
	- eval()함수는 보안의 문제가 있음.


---
### this

this의 값은 함수를 호출한 방법의 의해 결정된다. 실행 중 할당으로 설정할 수 없고, 함수를 호출할 때 마다 다를 수 있다. es5는 함수를 어떻게 호출 했는지 상관하지 않고 this값을 설정할 수 있는 bind 메서드를 도입했고, es2015는 스스로의 this바인딩을 제공하지 않는 화살표 함수를 추가했다(렉시컬 컨테스트안의 this 값을 유지).
- this의 값은 런타임에 결정된다. 컨테스트에 따라 달라진다.
	- 어떤 객채를 참조하여 호출했는지에 따라 this의 값은 변경된다. 이를 동적 스코프라고 한다.
- 메서드가 어디서 정의되었는지(정적 렉시컬 환경)에 상관없이 this는 참조 객체가 무엇이지에 따라 결정된다.

#### 값

실행 컨텍스트(global, function 또는 eval)의 프로퍼티는 비엄격 모드에서 항상 객체(글로벌 오브젝트)를 참조한다. 엄격 모드에서는 어떠한 값이든 될 수 있다.

- 전역 문맥: 글로벌 오브젝트에서 this는 글로벌 오브젝트 참조
	- 전역 실행 맥락에서 this는 엄격 모드 여부에 관계 없이 전역 객체를 참조한다.
- 함수 문맥: 함수 내부에서 this의 값은 함수를 호출한 방법에 의해 좌우된다.
	- 비엄격 모드 - this의 값이 호출에 의해 설정되지 않으므로, host 오브젝트(window)를 참조
	- 엄격 모드 - this 값은 실행 문맥에 진입하며 설정되는 값을 유지한다.
- this와 window 오브젝트의 관계
	- window 객체는 JS에서 만든 것이 아니며 글로벌 오브젝트의 스코프도 아님
	- window 와 글로벌 오브젝트를 같은 선상에서 사용
		- 브라우저에서 window가 글로벌 오브젝트를 참조하므로 window.value 형태로 글로벌 변수가 사용 가능하다.
	- 이는 host 오브젝트 개념을 사용한 것이다.
		- window 오브젝트와 같이 다른 오브젝트를 사용하는 개념을 Host 오브젝트라고 한다.
		- DOM 오브젝트도 Host 오브젝트이다.
- 전역 스코프 내 함수 안에서 작성한 this는 글로버 오브젝트를 참조한다.
	- 함수 내부 this는 함수 앞에 작성한 오브젝트를 참조한다.

#### this 참조 범위
- 오브젝트.함수이름() 형태로 함수 호출
	- 글로벌 오브젝트는 오브젝트 이름이 없으므로 함수 이름만 작성하여 호출
- strict 모드에서는 window.book() 처럼 book() 앞에 window를 글로벌 오브젝트로 작성
- 함수 앞에 오브젝트를 작성하지 않으면
	- this 바인딩 컴포넌트에 undefined가 설정되어 this로 window를 참조 할 수 없음.

```js
function book() {  
	'use strict';  
	// undefined  
	return this;  
}

function book1() {  
	'use strict';  
	// undefined  
	return this;  
}

var obj = window.book();
obj === window // true
```

this가 참조하는 object
``` ts
const book = {  
	point: 200,  
	member: {  
		point: 100,
		// get 함수의 this 바인딩 컴포넌트는 book.member를 참조하고 있음.  
		get: function () {  
			console.log(this === book.member); // true  
			return this.point;  
	},  
		getArrow: () => {  
			console.log(this); // {}  
			return this.point;  
		},  
	},  
};  
  
console.log(book.member.get()); // 100  
console.log(book.member.getArrow()); // undefined
```

#### this와 인스턴스
- 인스턴스 목적 - 인스턴스마다 고유 값 유지
	- this로 인스턴스 참조
	- this.[value] 형태로 프로퍼티에 접근
- __ proto __ 프로프티 접근
	- prototype에 연결된 프로퍼티가 인스턴스의 __ proto __ 에 첨부되며
		- prototype에 연결된 프로퍼티는 모든 인스턴스가 공유하고,
	- this.method()형태로 __ proto __ 에 첨부된 method 호출
#### this 호출

`this`의 값을 한 문맥에서 다른 문맥으로 넘기려면 다음 예시와 같이 [`call()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call)이나 [`apply()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)를 사용해야 한다.

``` js
function add(c, d) {
  return this.a + this.b + c + d;
}

var o = { a: 1, b: 3 };

// 첫 번째 인자는 'this'로 사용할 객체이고,
// 이어지는 인자들은 함수 호출에서 인수로 전달된다.
add.call(o, 5, 7); // 16

// 첫 번째 인자는 'this'로 사용할 객체이고,
// 두 번째 인자는 함수 호출에서 인수로 사용될 멤버들이 위치한 배열이다.
add.apply(o, [10, 20]); // 34
```

> 비엄격 모드에서 `this`로 전달된 값이 객체가 아닌 경우, `call`과 `apply`는 이를 객체로 변환하기 위한 시도를 합니다. `null`과 `undefined` 값은 전역 객체가 됩니다. `7`이나 `'foo'`와 같은 원시값은 관련된 생성자를 사용해 객체로 변환되며, 따라서 원시 숫자 `7`은 `new Number(7)`에 의해 객체로 변환되고 문자열 `'foo'`는 `new String('foo')`에 의해 객체로 변환됩니다.

#### bind 메서드

`f.bind(someObject)`를 호출하면 `f`와 같은 본문(코드)과 범위를 가졌지만 this는 원본 함수를 가진 새로운 함수를 생성한다. 새 함수의 `this`는 호출 방식과 상관없이 영구적으로`bind()`의 첫 번째 매개변수로 고정된다.

#### 화살표 함수

화살표 함수에서 this는 자신을 감싼 렉시컬 스코프이다. 전역 코드에서는 전역 객체를 가르킨다.
화살표 함수 call(), bind(), apply() 를 사용해 호출 해도 생성 시점의 ==렉시컬 컨텍스트가== 유지 된다.

> **참고**: 화살표 함수를 `call()`, `bind()`, `apply()`를 사용해 호출할 때 `this`의 값을 정해주더라도 무시합니다. 사용할 매개변수를 정해주는 건 문제 없지만, 첫 번째 매개변수(`thisArg`)는 `null`을 지정해야 합니다.

#### 객체의 프로토타입 체인에서의 this

객체의 프로토타입 체인 어딘가에 정의한 메서드가 어떤 객체의 프로토타입 체인 위에 존재하면, this의 값은 그 객체가 메서드를 가진 것 마냥 설정 된다.