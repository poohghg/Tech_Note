### # 변수 구분

- 로컬(지역) 변수, 글로벌(전역) 변수
- 변수를 구분하는 이유?
	- 기능과 목적이 다르기 때문이다.
- 글로벌 변수의 기능,목적
	- 다른 JS 파일에서 변수값을 공유
	- 파일에서 공통 변수 개념으로 사용
	- 의도는 좋아나 처리 속도가 떨어짐
- 글로벌 변수는
	- 글로벌 오브젝트의 로컬 변수이다.
	- var value = 100
	- var 키워드 사용이 정상이다.
- 로컬 변수의 기능
	- 빠르게 식별자를 해결하기 위해 가까운 스코프의 변수를 사용
- use strict 사용
	- 함수안에서 var 키워드를 사용하지 않으면 에러 발생
	- ES5에서 도입 근본적인 접근은 아님
	- ES6에서 use strict 모드가 디폴트 환경
		- 전체는 아님

#### 블록 스코프 유형

- function 블록
	- function 블록도 블록 스코프이다.
	- function 오브젝트의 바디 부분
	- function 안과 밖에 같은이름의 변수를 사용이 가능
		- 스코프가 다르기 때문
- try-catch
	- try-catch는 블록 스코프
	- try 블록{} 기준으로 안과 밖에 같은 이름의 let 변수 선언 가능
- switch-case
	- switch문은 블록 스코프
	- case, default는 블록 스코프가 아니다.

#### let 변수

- 블록 스코프를 가진 변수
	- 블록 단위로 스코프를 가진다.
	- 블록 내 작성 되지 않으면 Script 스코프 블록 개념에 등록된다.
	- 블록 내 작성 되면 Block 스코프에 등록된다.
	- ![[Pasted image 20250115175540.png]]
- 변수가 선언된 블록이 스코프이다.
- 스코프 적용 기준
	- 블록{}, 문 , 표현식
- 블록은 안과 밖의 스코프가 다름
	- 변수 이름이 같아도 값이 대체되지 않음
- let 변수와 this
	- 글로벌 오브젝트에서 let 변수를 this로 참조는 불가하다.
	- 

---
### # ArrayBuffer

#### TypedArray 개요

- Type 가진 Array와 비슷한 형태이다.
- 스펙: Integer-Indexed exotic object Byte Offset 개념
	- 인덱스 개념의 오프셋이 아니라 바이트이다.
- Int8Array, Int16Array, Float32Array 등
	- 정수(Int), 실수(Float) 타입
	- 8비트, 16비트, 32비트, 64비트
	- 8비트(1 바이트), 16비트(2 바이트), 32비트(4바이트), 64비트(8바이트)
- 값은 ==오직 숫자만== 사용할 수 있으며 바이너리로 저장된다.
	- 처리 속도가 빠르다.

```ts
const obj = new Int8Array(3);  

// [0,0,0]  
console.log(obj);

obj[0] = 1;  
obj[1] = 2;  
obj[2] = 3;  
obj[3] = 4;  
  
// [1, 2, 3]  
console.log(obj);  
  
const test: Int8Array = obj;

```

- 해설
	- 8비트 크기의 정수타입의 TypedArray 인스턴스 생성
	- 파리미터는 엘리먼트의 사이즈이다.
	- 각 엘리먼트의 타입과 크기는 같다
	- 엘리먼트에 초기값으로 0이 설정된다.
	- 각 인덱스는 integer index property keys로 기술되어 있다.

#### TypedArray의 필요성

##### Array 처리 매커니즘

- [[array 와 set]] 참조
- 자바스크립트 배열은 추가,삭제 시 배열의 크기를 조절 한다.
	- O(n) 시간 복잡도
	- 처리 속도가 일반적으로 떨어진다.

#### 메모리 사용 측면

- 자바스크립트의 메모리 사용
	- 값의 크기에 관계없이 64비트(8바이트)를 사용한다.
	- 숫자1은 8비트이면 되므로 64비트는 필요 이상의 메모리를 사용한다.
- 데이터 크기가 작으면 실제 영향도는 적다.
	- 하지만 이미지 같은 청크 데이터는 메모리 사용의 효율이 떨어지며 처리 속도에는 영향을 미친다.
	- 반복 처리를 많이 하는 머신런닝은 실행 여부 자체에 영향이 미칠 수 있다.

#### 필요성

- 배열 길이가 변하지 않는 형태가 필요
	- 처리 속도를 향상시킬 수 있다.
- 메모리 사용의 최적화
	- 값 크기에 맞는 메모리를 사용한다.
	- Int8Array(100): 1은 8비트로 충분하다.
- 바이너리로 데이터 처리
	- 메모리에 값을 저장할 때 0과1의 바이너리로 변환하지만 값이 바이너리로 처리가 빠르다.

#### 출현 배경

- webGL에서 처음 스펙을 작성
	- ES6에서 통합되었다.
- webGL 에서 스팩을 만든 이유
	- 웹에서 청크 데이터 처리를 위해
	- 메모리 사용의 최소화와 빠른 처리가 필요하기 때문이다.
- ﻿﻿TypedArray를 사용하는 Web API
	- ﻿﻿Canvas의 ImageData.data
	- ﻿﻿FileReader.prototype.readAsArrayBuffer()
	- ﻿﻿이런 데이터를 사용하는 Web API에 적용 한다.

#### ArrayBuffer

- 바이너리 데이터를 저장하는 오브젝트이다.
	- new ArrayBuffer(바이트 수)로 생성하며
	- 생성한 인스턴스의 바이트 수를 변경할 수 없다.
- ArrayBuffer에 직접 데이터를 CRUD를 할 수 없다.
	- TypedArray, DateView로 view


```ts
const buffer = new ArrayBuffer(4);
// 엘레민터 하나가 1바이트인 Int8Array 뷰를 생성
const view = new Int8Array(buffer);  
// [0, 0, 0, 0]  
console.log(view);

// view에서 데이터를 CRUD
// 데이터는 ArrayBuffer에 저장된다.
```









