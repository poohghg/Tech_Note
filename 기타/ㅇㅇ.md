##   1.기술 스택

- **프론트엔드**: React, TypeScript
    
- **상태 관리**: React Query, Context API
    
- **WebSocket 관리**: 커스텀 소켓 매니저
    
- **스타일링**: Tailwind CSS
    
- **빌드 도구**: Craco (경로 설정 및 초기 구성)
    

## 2.주요 기능 및 구현 스펙

### 실시간 데이터 (Real-Time Data)

| **구분**     | **내용**                                       | **데이터 소스**                            |
| ---------- | -------------------------------------------- | ------------------------------------- |
| **시장 정보**  | 한국(KR), 미국(US) 시장의 현재 인덱스 및 시세 실시간 갱신        | API `/info` 및 useInfoSocket           |
| **환율 정보**  | KRW/USD 환율 실시간 갱신                            | API `/rate` 및 useExchangeRateSocket   |
| **종목별 시세** | 한국/미국 종목의 현재가, 등락률 등 실시간 갱신 및 등락률 순 정렬       | API `/stock-price/*` 및 usePriceSocket |
| **보유 자산**  | 보유 수량, 현재가, 평가 금액의 실시간 갱신 및 체결(NEW_TRADE) 반영 | API `/assets*` 및 useNewTradeSocket    |
|            |                                              |                                       |

- API는  **FetchBuilder**를 사용하여 API 요청을 체계적으로 구성합니다.
	- `params`, `httpMethod`, `headers`, `initConfig` 등 다양한 메서드를 체인 형태로 호출 가능하므로, 가독성과 재사용성이 높습니다.
	- 빌더 패턴을 활용하면 요청 구성을 명시적으로 표현할 수 있어, 유지보수성과 확장성이 뛰어납니다.
	-  `FetchFactory.success`와 `FetchFactory.error`를 통해 성공 응답과 에러 응답의 구조를 통일합니다.
	- 이를 통해 API 요청 결과를 처리하는 코드의 일관성을 높이고, 추가적인 데이터 가공 작업을 줄일 수 있습니다.
- 웹 소켓데이터는 각 메시지 특성에 맞게 미리 생성된 useSocket Hook을 통해 구독합니다.
	-  `useSocket` 훅은 `useSyncExternalStore`를 활용하여 소켓 데이터를 효율적으로 구독하고, 필요한 컴포넌트만 리렌더링되도록 최적화합니다.

### 주요 사용자 인터페이스 (UI)

- **탭 :** 종목별 시세 영역과 내 보유 주식 영역 모두 한국/미국 탭을 제공하여 국가별 정보 필터링을 지원합니다
	- 탭 컴포넌트는 uiKitd에서 컴파운드 컴포넌트로 제작하여 재사용성을 높였고 명시적인 API를 제공합니다.

- ReactQueryHandler: 리액트 쿼리의 로딩, 에러, 빈 데이터 상태를 처리하는 컴포넌트로, 중복 코드를 줄이고 일관된 사용자 경험을 제공합니다.

### 공통 포맷팅 규칙 (Formatter 클래스 참조)

- 웹 전체에 필요한 공통 포멧팅 로직을 Formatter 클래스에 static메서드로 생성하여 웹 전체가 참조하도록 하였습니다.
    
- **달러 (USD):** `$00,000.0000` (최대 소수점 4자리, 반올림)
    
- **일반 숫자:** 최대 소수점 2자리 (반올림)
    
- **환산 표기:** 달러를 환율 적용하여 원화로 표시할 경우 앞에 `≈` (예: `≈15,000원`)를 붙입니다.
    

## 3. 아키텍처 및 설계 원칙

프로젝트 폴더 구조는 Feature-Sliced Design(FSD) 아키텍처를 기반으로 구성되었습니다. 이 구조는 확장성과 유지보수성을 극대화합니다

src/  
├── app/               # 애플리케이션 진입점 및 글로벌 설정  
├── entities/          # 비즈니스 로직 및 데이터 모델 (예: MyStockAsset)  
├── features/          # 독립된 사용자 기능 (예: MyAssetsList)  
├── pages/             # 페이지 수준 컴포넌트  
├── shared/            # 재사용 가능한 유틸리티, 컴포넌트, 상수  
 │   ├── lib/           # 전역적으로 사용하는 라이브러리 (예: 포맷팅, 소켓 관리)  
 │   ├── uikit/         # 재사용 가능한 UI 컴포넌트 (예: 탭, 버튼)  
├── widgets/           # 복합 컴포넌트 (예: MarketHeader)

### 3.1. FSD (Feature-Sliced Design) 아키텍처 채택

프로젝트 구조는 **FSD (Feature-Sliced Design)**를 기반으로 설계되었습니다. FSD는 애플리케이션의 복잡성을 관리하고 코드 재사용성 및 유지보수성을 극대화하기 위한 구조입니다.

**FSD 채택한 이유:**

1. **확장성 및 독립성:** 각 슬라이스(레이어)가 독립적이므로, 새로운 기능을 추가하거나 기존 기능을 수정할 때 영향 범위 예측이 용이합니다.
    
2. **재사용성 극대화:** `entities`와 `shared` 레이어에서 정의된 로직과 컴포넌트는 상위 레이어에서 자유롭게 재사용될 수 있습니다. (예: `uikit`의 `Tabs` 컴파운드 컴포넌트)
    
3. **엄격한 의존성 관리:** 하위 레이어는 상위 레이어를 가져올 수 없으므로, 순환 참조를 방지하고 안정적인 구조를 유지합니다.
    
4. 관심사의 명확한 분리:  각 레이어는 특정 역할에 집중하여 코드의 가독성과 유지보수성을 향상시킵니다.  

### 3.2. 데이터 모델링 (Entities)


- **패칭 → 모델링 → 쿼리 → 뷰**: 데이터는 패칭 후 모델링되고, 캐싱을 통해 효율적으로 관리된 뒤 뷰로 전달됩니다.
- **반응형 설계**: WebSocket 데이터나 React Query 상태 변경에 따라 뷰가 자동으로 업데이트됩니다.

1. **패칭 (Fetching):** `fetch` API를 사용하여 백엔드 데이터를 가져옵니다.
    
2. **모델링 (Modeling) - TypeScript 클래스 활용:**
    
    - API에서 수신된 Raw 데이터를 곧바로 View에 사용하지 않고, **`MyStockAsset` 추상 클래스**와 **`MyStockAssetKr` / `MyStockAssetUs`  ** 과 같은 구체 클래스**로 모델링합니다.
    - 
    - **장점:**
        
        - **응집도 강화:** 뷰에 필요한 모든 포맷팅 로직 (`formattedPrice`, `formattedEvaluationAmount` 등)은 모델 클래스 내부에 캡슐화됩니다. 뷰는 모델의 속성만 사용하면 되므로 관심사를 분리합니다.
            
        - **타입 안전성:** TypeScript 클래스를 통해 데이터의 구조와 행위가 명확히 정의되어 런타임 오류를 줄입니다.
            
        - **다형성 (Polymorphism):**  예를 들어 한국과 미국 주식의 통화 표기 방식이 다르지만, `formattedEvaluationAmount(exchangeRate)`와 같은 추상 메서드를 오버라이드(Override)하여 **동일한 인터페이스**로 다른 출력 결과를 생성할 수 있어 뷰 로직이 단순해집니다.
        
	    -  **캡슐화**: `MyStockAsset`과 같은 엔티티는 주식 자산과 관련된 모든 데이터와 로직을 캡슐화합니다.
	      
		- **일관성 유지**: 추상 클래스를 통해 공통 로직을 정의하고, 이를 확장하여 구체적인 동작을 구현합니다.
		            
3. **쿼리 (Query) - React Query:**
    
    - 모델링된 데이터를 React Query 훅을 통해 캐싱하고 관리하여 **로딩 상태, 오류 처리, 데이터의 stale 관리**를 간편하게 처리합니다.
        
    
### 3.3. 소켓 관리 시스템 (`useSyncExternalStore` 및 `SocketManager`)

실시간 데이터 처리를 위해 **단일 소켓 연결 (`SocketManager`)**과 **`useSyncExternalStore` 훅**을 결합한  상태 관리 시스템을 구축했습니다.

#### A. 단일 소켓 매니저의 기능 및 장점

- **단일 연결 유지:** 애플리케이션 전체에서 단 하나의 WebSocket 연결만 관리합니다.
    
    - **장점:** 백엔드 리소스와 클라이언트 네트워크 부하를 최소화하여 **성능 최적화**에 기여합니다.
        
- **재연결 로직:** 연결이 끊어지면 자동으로 재연결을 시도합니다.
    
    - **장점:** 네트워크 환경에 관계없이 데이터 연속성을 보장합니다.
        
- **구독 상태 관리:** `activeSubscriptions` Map을 통해 컴포넌트가 마운트될 때 구독 메시지를 보내고, 모든 구독자가 해제되었을 때만 `UNSUBSCRIBE` 메시지를 보냅니다.
    
    - **장점:** 불필요한 서버 메시지 전송을 막아 **네트워크 트래픽을 효율적으로 관리**합니다.
        

#### B. `useSyncExternalStore`를 사용한 최적화

- **메커니즘:** `useSocket` 훅은 React 18에 도입된 `useSyncExternalStore`를 사용합니다. 이 훅은 React 외부의 데이터 저장소(여기서는 `SocketAtomStore`)와 React의 렌더링 시스템을 효율적으로 동기화합니다.
    
    - **`SocketAtomStore`:** 소켓을 통해 들어오는 데이터(`atomKey` 기반)를 저장하고, 변경 시 구독자에게 알리는 역할을 합니다.
        
- **최적화 과정 및 이점:**
    
    1. **Atom 기반 데이터 관리:** 각 데이터 스트림은 고유한 `Symbol` 키(`atomKey`)로 관리됩니다.
        
    2. **우선순위 기반 업데이트:** `SocketAtomStore`는 **`high`** (즉시 `queueMicrotask` 사용)와 **`normal`** (다음 `requestAnimationFrame` 사용) 두 가지 우선순위로 업데이트를 분리합니다.
        
        - **`high` ** 중요하고 즉각적인 업데이트(예: 체결)는 **마이크로태스크 큐**를 사용하여 브라우저 렌더링 전에 즉시 처리하여 **최소 지연 시간**을 달성합니다.
            
        - **`normal` :** 렌더링에 치명적이지 않은 업데이트는 **RAF**를 사용하여 브라우저의 프레임과 동기화함으로써, 여러 업데이트를 단일 프레임으로 묶어 **불필요한 리렌더링과 프레임 드롭**을 방지합니다.
            
    3. **React 외부 상태:** `SocketAtomStore`가 React 외부에 존재하므로, 소켓 데이터가 갱신되어도 **전체 앱이 아닌 해당 데이터를 구독하는 컴포넌트만** 효율적으로 리렌더링됩니다.
#### C. 소켓 프로바이더 (`SocketProvider` 및 `SocketManager`)

애플리케이션 최상단에서 **`SocketProvider`**를 사용하여 단일 `SocketManager` 인스턴스를 생성하고 관리합니다.
        
- **메시지 키 생성 위임:** `SocketManager`는 초기화 시 **`handleMakeKeyFromMessage`**콜백 함수를 인수로 받아, 웹소켓으로 수신된 메시지를 파싱하여 **고유한 키 값**을 생성하는 역할을 위임합니다. 이 키는 개별 데이터 스트림(Atom)을 식별하는 데 사용됩니다.
    
- **단일 연결 유지:** 애플리케이션 전체에서 단 하나의 WebSocket 연결만 관리합니다.
    
    - **장점:** 백엔드 리소스와 클라이언트 네트워크 부하를 최소화하여 **성능 최적화**에 기여합니다.
## 4.최적화 전략

### 1. WebSocket 관리

- **중앙 집중식 소켓 매니저**: 단일 WebSocket 연결을 관리하며, 효율적으로 업데이트를 배포합니다.
- **우선순위 업데이트**: 높은 우선순위의 업데이트는 즉시 처리하고, 일반 업데이트는 `requestAnimationFrame`을 통해 배치 처리합니다.

### 2. 가상 스크롤링

- **react-virtuoso**: 뷰포트에 보이는 데이터만 렌더링하여 DOM 노드 수를 줄이고 성능을 최적화합니다.

### 3. API 및 캐시 최적화

- **React Query**: API 응답을 캐싱하여 불필요한 네트워크 요청을 최소화합니다.
- **관심사의 분리**: 데이터 패칭, 모델링, 렌더링을 분리하여 모듈화와 테스트 가능성을 높였습니다.

## 5. 아쉬웠던 점 및 백엔드 개발자와의 소통 (API 피드백)

제공된 API 및 웹소켓 스펙을 기반으로 프로젝트를 진행하면서 발견된 몇 가지 아쉬운 점을 공유드립니다.

### 1. **일관되지 않은 API 디자인**:

   - 현재: `/closed-price/kr`와 `/closed-price/us` 엔드포인트가 서로 다른 형식의 데이터를 반환.
   
   - **해결 방법**: 프론트엔드에서 DTO를 사용하여 데이터를 통일된 형식으로 변환.

   - **제안**: API 응답 형식을 일관되게 맞춰주시면, 프론트엔드에서의 데이터 처리 로직이 단순해지고 유지보수가 용이해집니다.

### 2. 웹소켓 키 생성에 대한 협의 필요성

- **현재:** 소켓 메시지 핸들러에서 메시지의 `type`, `country`, `name` 등의 필드를 조합하여 고유한 키를 생성하고 있습니다.
    
- **제안:** 백엔드에서 내려주는 메시지에 **이미 약속된 형태의 고유 식별 키 (예: `socket_id` 또는 `stream_key`)**를 포함하여 전송해 주시면, 프론트엔드에서 키 생성 로직이 불필요해지고 데이터 매칭의 안정성이 더욱 보장될 수 있습니다.
    
