## ✅ 기술 선택의 이유 및 대안 고려 관련 질문

1. Nuxt 2에서 Next.js 14로 기술 전환을 결정하게 된 배경은 무엇인가요? Vue 3로의 업그레이드나 다른 SSR 프레임워크는 고려하지 않았나요?
	- Nuxt2의 기술 지원 종료 와 vue 개발자 퇴사로 유지보수의 어러움이 있었다.
	- Next.js 14의 App Router 구조로 전환하면서 Server Component, Streaming SSR 등을 활용하여 성능적 이점을 가져 갈 수 있다고 생각했다.

2. 서버 컴포넌트를 도입할 때 어떤 트레이드오프(성능/복잡성/러닝 커브 등)를 고려했나요?
	- Server/Client Component 구분, `use client` 키워드 사용 조건, hook 제약 등 새로운 학습 요소가 존재.
	- 컴포넌트 간 의존성에 따라 Server → Client 경계를 명확히 나눠야 해서, **리팩토링 시 신경 쓸 부분이 많아짐**.
    
3. Recoil과 React Query를 조합해 상태를 관리한 이유는 무엇인가요? 전역 상태 관리와 서버 상태 관리를 나눈 기준은 무엇이었나요?
	- 역할 분리: 서버데이터와 클라이언트 상태를 명확하게 나눠 관리할 필요성이 있었음
		- 관심사 분리를 통해 코드의 유지보수성과 가독성을 높일 수 있었음
	- 복잡한 전역  상태 관리에 유리: 리코일은 Selector로 파생상태를 만들 수 있어 계산된 값 공유에 유리했음
	- 서버 데이터는 자동관리 : React Query를 사용하여 서버 데이터를 캐싱하고, 자동으로 갱신할 수 있어 효율적이었음
		- 또한 상태처리를 자동으로 해줌
	- Context와 비교
		- 렌더링 최적화: Context는 소비 컴포넌트 전체가 리렌더링되지만, 리코일은 해당 Atom을 참조한 컴포넌트만 리렌더링 된다.
		- 상태 분리: 리코일은 상태 단위로 나눌수 있어 모듈화 용이
		- 파생 상태 계산 : 리코일의 셀릭터는 파생 상태를 쉽게 만들 수 있어 복잡한 계산을 효율적으로 처리 가능
    
4. SCSS와 Styled Components를 함께 사용한 이유는 무엇인가요? CSS-in-JS 도구 중 어떤 기준으로 선택했는지 설명해 주세요.
    
5. Compound Component Pattern을 선택한 이유와 다른 패턴(예: Render Props, HOC)과의 비교 분석이 가능할까요?
	- 컴포넌트 간의 자연스러운 부모-자식 관계를 유지하면서, 내부 상태 공유를 명확하게 통제할 수 있기 때문이다.
	- 의미적으로 결합된 컴포넌트를 그룹화해 사용자가 더 명확하게 컴포넌트를 구성할 수 있게 해준다.
	- 장점
		- API가 직관적이고 읽기 쉽다.
		- 내부 상태를 Context로 공유 가능하다.
		- 사용자가 조합 방식에 유연성이 있다.
	- 단점
		- 컨텍스트나 제한된 범위에서만 사용이 적절하다.
    
6. React Query의 staleTime과 gcTime 설정을 Infinity로 고정할 때 발생 가능한 단점이나 주의점은 어떤 게 있다고 생각하시나요?
	- 장점
		- 동일 데이터에 반복 접근시 네트워크 요청이 발생하지 않아 성능 최적화에 유리하다.
		- 데이터가 변화는 않는 경우 매우 우용
	- 단점 및 주의점
		- 메모리 누수의 위험
			- 캐시가 무한히 유지되므로, 많은 데이터가 쌓이면 브라우저 메모리를 과도하게 사용할 수 있다.
		- 데이터 신선도 보장 불가
			- 외부에서 변경된 서버 데이터를 반영하지 못해 구식 정보를 보여줄수 있다.
    

8. Next.js Page Router vs App Router 차이점
	- App Router의 장점
		- 중첩 레이아웃과 페이지별 layout 구성 가능
		- 서버컴포넌트 지원 및 사용을 통한 번들 크기 감소 가능
		- 클라이언트/서보 로직 분리 용이
	- App Router의 단점
		- 초기 학습 비용
		- 일부 서드파티 라이브러리 호환 이슈

9. FSD 아키텍처 적용 경험
	- 기존 개발시 프로젝트마다 폴더구조의 컨벤션이 없어 컨테스트 스위칭 비용이 컸다.
	- FSD 도입을 통해 관심사 기반으로 레이어 및 슬라이스를 구분해 코드의 위치가 명확해졌다.
		- 결합도는 낮추고 응집도를 높였다.
	- 코드 발견성이 높아졌다.
	- FSD 도입 후 코드 품질이 높아졌고, 테스트 커버리지도 높아졌다.
	- layers - slices - segments 로 구조화

10. GA4 이벤트 태깅 모듈을 직접 개발한 이유와 방식은?
	- 기존 이벤트 관리가 너무 큰 인터페이스를 가지고 있어 코드의 복잡성이 증가하고, 코드 발견성이 떨어졌다.
	- 확장 가능한 타입 기반 인터페이스를 설계하고, 페이지뷰,가상페이지뷰,사용자 태그에 대응하는 래퍼 컴포넌트 및 모듈을 개발했다.
		- 각 GTM마다 필용한 정보는 다르기 때문에 각 GTM에 맞는 인터페이스를 제공했다.
	- 이러한 구조는 추가 이벤트 추가에대한 타입 안정성을 확보하여 유지보수에 강한 구조가 되었다.
	  
11. API 호출 방식을 래퍼 클래스로 표준화했다고 하셨는데, 어떤 문제를 해결하기 위한 것이었고, 어떤 방식으로 구현하셨나요?
	- 명시적으로 조립하여 호출을 표준화
		- **DSL**은 **Domain-Specific Language**의 약자로,  직역하면 **"도메인 특화 언어"**, 즉 **특정 목적에 최적화된 작은 언어**이다.
	- Builder Pattern 기반의 `FetchBuilder` 클래스를 도입했다.
		- 체이닝 API로 명시적 구성
	- 일관된 응답 객체가 필요했다.
		- 예외 상황을 모두 공통 처리해 **서비스 레벨에서 분기 최소화**
	- 목적에 맞는 URL 분기 와 헤더처리 방식의 통일
	- HMAC, 로그 관리 등의 모듈관리가 필요했다.
	- **도메인별 인증, 캐시 정책, tag 기반 revalidation, mock 대응** 등이 필요한 경우에는 유지보수성과 팀 생산성을 동시에 확보할 수 있었다.
12. 헤드리스 컴포넌트를 사용한 이유는?
	- Headless 컴포넌트, 또는 'presentational-less' 컴포넌트라고도 불리는 이 개념은  일종의 디자인 패턴으로, UI 로직과 표현(presentation)을 분리함으로써 컴포넌트의 재사용성, 유지보수성, 그리고 테스트 용이성을 크게 향상시킬 수 있다.
		- 재사용성과 접근성과 같은 부분에만 신경을씀
	- radix ui는 css가 전혀 포함되지 않은 headless ui이므로 디자인 부분은 온전히 개발자의 몫
	- https://velog.io/@leehyewon0531/Radix-ui-%EC%9A%94%EC%A0%90-%EC%A0%95%EB%A6%AC

---

## ✅ 새로운 기술 습득력 및 학습 방식 관련 질문

1. React Core 파헤치기 과정에서 직접 `useState`, `useEffect`를 구현했다고 하셨는데, 해당 구현 경험을 통해 얻게 된 가장 큰 인사이트는 무엇이었나요?
    
2. 새로운 기술을 학습할 때, “개념 → 사용 → 내재화”의 어떤 순서와 방식으로 접근하시나요?
    
3. 처음 접한 App Router, Server Component, Streaming SSR 등의 Next.js 13+ 기능 중에서 가장 어려웠던 개념은 무엇이었고, 어떻게 학습하셨나요?
    
4. 학습한 내용을 팀에 전파하거나 문서화할 때 어떤 접근 방식을 사용하나요?
    
5. 단기간에 FSD 아키텍처, 아토믹 디자인, Compound Pattern을 도입하고자 했을 때 어떤 순서로 학습하고 적용했는지 설명해 주세요.
    

---

## ✅ 아키텍처 설계 및 큰 그림을 보는 능력

1. 미스터블루 프로젝트에서 **도메인 로직 이관**, **모놀리식 구조 탈피**, **API 표준화**를 수행하셨는데, 각 계층을 어떤 기준으로 분리했는지 설명해주세요.
    
2. FSD 아키텍처 도입 시, 프로젝트마다 다른 폴더 구조 문제를 어떻게 진단하고 설계 기준을 정의했나요?
    
3. Adaptor Pattern이나 Builder Pattern을 실제 코드에 어떻게 적용했는지 설명해 주세요. 각 패턴이 어떤 문제를 해결해주었나요?
    
4. API 래퍼 클래스에 도입한 HMAC 인증 구조와 보안 강화 방식에 대해 설명해주세요. OAuth나 JWT와 비교한 이유도 함께요.
    
5. WebView 통신 구조 개선 시 scheme 기반 통합을 설계할 때, 고려한 인터페이스 설계 원칙은 무엇인가요?
    
6. 상태를 서버 → 클라이언트 단방향으로 유지했다고 했는데, CSR/SSR/Hybrid 환경에서 이 구조의 장단점은 무엇이라고 생각하시나요?
    
7. 뷰어 초기 렌더링 최적화에서 이미지 처리 레이어를 도입하셨다고 했는데, 해당 레이어의 구조를 계층적으로 설명해 주세요.
	- 메타데이터 패칭
	- 메타데이터 + 레이아웃 정보를 기반으로 전체 뷰포트 높이 설정
	- 뷰포트 내 페이지 생성
	- 이미지처리
		- 현재 뷰포트 위치로 프로로드 나머지는 레이지 로드
		- 이미지 관리 객체를 통해 이미지 로드 상태 관리
			- 비동기 렌더링을 위해 Intersection Observer 사용
		- 및 디코딩 관리
    
8. 서버 리소스 최적화를 위해 도입한 PM2 클러스터링과 Ping 요청 방식은 어떤 원리로 작동하며, 다른 대안(AWS Lambda, Vercel 등)은 고려하지 않았나요?
    

---

## ✅ 성능 개선과 코드 품질 향상 노력

1. 초기 렌더링 속도를 30% 이상 개선했다고 했는데, 성능 측정 도구나 지표는 어떤 것을 기준으로 사용하셨나요?
	- **Lighthouse (DevTools + CI 자동 리포트)**  
	    → FCP, LCP, TTI, TBT 등 실측 성능 확인
	- **Web Vitals via GA4**  
	    → 실제 유저 기반 FCP/LCP 수집
	- **Chrome DevTools Performance 탭**  
	    → 렌더링 트리, 스크립트 실행 시간 분석
    
2. Bundle 크기 최적화에서 어떤 기준으로 dynamic import를 적용했는지, 그 기준을 코드 레벨에서 설명해 주세요.
    
3. 이미지 Lazy Load를 직접 구현하셨다고 했는데, IntersectionObserver를 사용할 때 주의할 점은 무엇이라고 보시나요?
    
4. 코드 응집도와 결합도를 개선할 때 가장 신경 쓴 부분은 어떤 부분이었고, 그에 따른 구체적인 리팩토링 사례를 설명해주세요.
    
5. `any` 타입 제거 과정에서 가장 어려웠던 타입 추론/정의 사례는 무엇이었고, 이를 어떻게 해결하셨나요?
    

---

## ✅ 협업 및 팀워크 중심 아키텍처 개선

1. 신규 팀원이 기존 구조를 빠르게 이해하도록 문서화 및 컨벤션 정립을 어떻게 하셨나요?
    
2. 아토믹 디자인 시스템 도입 시, 디자인팀과의 협업에서 생긴 충돌이나 문제를 어떻게 해결하셨나요?
    
3. 디자인 시스템을 코드로 옮길 때, 단방향 의존성을 유지하는 구조는 어떤 식으로 만들었는지 설명해 주세요.
    
4. 디자인 변경이 반복될 경우, 컴포넌트 구조가 이를 어떻게 수용할 수 있도록 설계되었나요?
    

---

## ✅ 크로스 브라우징 및 사용자 경험 최적화

1. 사파리에서 주소 바 활성화 시 스크롤 이슈를 해결한 로직을 구체적으로 설명해 주세요.
    
2. IE11 대응을 위해 어떤 폴리필이나 대체 전략을 사용하셨나요? 관련해서 렌더링 이슈는 없었나요?
    
3. WebView 기반의 height 계산 및 scrolling 이슈 해결 방식은 어떤 기준으로 설계하셨나요?
    

---

## 🔚 마무리형 질문 (정리, 회고, 성장)

1. 지금까지의 프로젝트 중, 기술적으로 가장 많은 성장을 한 프로젝트는 어떤 것이며, 왜 그렇게 생각하시나요?
    
2. 가장 실패했던 설계 또는 기술 선택은 무엇이었고, 그것이 현재의 설계/개발에 어떻게 반영되었나요?
    
3. 프론트엔드 개발자로서 앞으로 어떤 아키텍처나 기술 분야에 더 깊이 관여하고 싶으신가요?

---
### 🔹 기술 아키텍처 및 구조

1. FSD 아키텍처를 어떻게 설계하고 어떤 기준으로 나눴나요?
    
2. Compound Component 패턴을 도입한 이유와 장단점은?
    
3. API 래퍼 구조와 HMAC 인증 방식 적용 방법은?
    

### 🔹 성능 최적화

4. LazyLoad 커스텀 구현 방식과 IntersectionObserver 활용법은?
    
5. Streaming SSR 도입 시 고려한 조건과 효과는?
    
6. 번들 사이즈를 4MB → 900KB로 줄인 과정은?
    

### 🔹 협업 & 유지보수

7. 신규 팀원 온보딩을 위해 어떤 문서화와 컨벤션을 준비하셨나요?
    
8. GA4 이벤트 태깅 모듈을 직접 설계한 이유는?
    
9. 디자인 시스템을 코드에 이식할 때 어떤 기준으로 네이밍했나요?
    

### 🔹 프론트엔드 핵심 개념

10. useEffect 최적화는 어떻게 접근하시나요?
    
11. React에서 상태 변경 시 렌더링 최적화를 어떻게 하나요?
    
12. JSX → Virtual DOM → 실제 DOM 변경 흐름을 설명해주세요.
---
#### 고차 함수

고차 함수는 함수를 인자로 받거나 함수를 반환하는 함수입니다. 자바스크립트에서는 함수가 일급 객체이기 때문에 고차 함수를 쉽게 구현할 수 있습니다. 고차 함수는 주로 다음과 같은 용도로 사용됩니다:
- **콜백 함수**: 다른 함수에 인자로 전달되어 특정 작업을 수행합니다.
- **함수 조합**: 여러 함수를 결합하여 새로운 함수를 생성합니다.
- **커링(Currying)**: 여러 인자를 받는 함수를 단일 인자를 받는 함수로 변환합니다.
##### 예시

```javascript
// 함수를 인자로 받는 고차 함수
function higherOrderFunction(callback) {
    // 콜백 함수를 호출
    callback();
}
// 콜백 함수 정의
function sayHello() {
    console.log("Hello, World!");
}
// 고차 함수 호출
higherOrderFunction(sayHello);

// 함수를 반환하는 고차 함수
function createMultiplier(multiplier) {
    return function (x) {
        return x * multiplier;
    };
}

// 반환된 함수를 사용
const double = createMultiplier(2);

console.log(double(5)); // 10

// 커링 예시
function add(a) {
    return function (b) {
        return a + b;
    };
}


console.log(add(5)(10)); // 15
```

#### 제너릭

제너릭은 **타입을 함수나 클래스, 인터페이스 등에서 동적으로 사용할 수 있게 해주는 기능**이다.  
코드를 **재사용 가능하면서도 타입 안정성**을 유지할 수 있다.

- 유연한 타입 처리를 가능하게 해준다.
- 타입 코드의 재사용이 가능하면, 코드의 중복을 줄이고 유지보수를 용이하게 한다.